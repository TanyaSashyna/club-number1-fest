/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 265);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js
;

(function (global, factory) {
   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
})(this, function () {
  'use strict';

  var hookCallback;

  function hooks() {
    return hookCallback.apply(null, arguments);
  } // This is done to register the method called with moment()
  // without creating circular dependencies.


  function setHookCallback(callback) {
    hookCallback = callback;
  }

  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }

  function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
  }

  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;

      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          return false;
        }
      }

      return true;
    }
  }

  function isUndefined(input) {
    return input === void 0;
  }

  function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
  }

  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }

  function map(arr, fn) {
    var res = [],
        i;

    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }

    return res;
  }

  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }

  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }

    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }

    return a;
  }

  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }

  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }

  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }

    return m._pf;
  }

  var some;

  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function (fun) {
      var t = Object(this);
      var len = t.length >>> 0;

      for (var i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }

      return false;
    };
  }

  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      var parsedParts = some.call(flags.parsedDateParts, function (i) {
        return i != null;
      });
      var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }

      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }

    return m._isValid;
  }

  function createInvalid(flags) {
    var m = createUTC(NaN);

    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }

    return m;
  } // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.


  var momentProperties = hooks.momentProperties = [];

  function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }

    if (!isUndefined(from._i)) {
      to._i = from._i;
    }

    if (!isUndefined(from._f)) {
      to._f = from._f;
    }

    if (!isUndefined(from._l)) {
      to._l = from._l;
    }

    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }

    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }

    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }

    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }

    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }

    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
      for (i = 0; i < momentProperties.length; i++) {
        prop = momentProperties[i];
        val = from[prop];

        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }

    return to;
  }

  var updateInProgress = false; // Moment prototype object

  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);

    if (!this.isValid()) {
      this._d = new Date(NaN);
    } // Prevent infinite loop in case updateOffset creates new moment
    // objects.


    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }

  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }

  function absFloor(number) {
    if (number < 0) {
      // -0 -> 0
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }

  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }

    return value;
  } // compare two arrays, return the number of differences


  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;

    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }

    return diffs + lengthDiff;
  }

  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }

  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function () {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }

      if (firstTime) {
        var args = [];
        var arg;

        for (var i = 0; i < arguments.length; i++) {
          arg = '';

          if (typeof arguments[i] === 'object') {
            arg += '\n[' + i + '] ';

            for (var key in arguments[0]) {
              arg += key + ': ' + arguments[0][key] + ', ';
            }

            arg = arg.slice(0, -2); // Remove trailing comma and space
          } else {
            arg = arguments[i];
          }

          args.push(arg);
        }

        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
        firstTime = false;
      }

      return fn.apply(this, arguments);
    }, fn);
  }

  var deprecations = {};

  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }

    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }

  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;

  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  function set(config) {
    var prop, i;

    for (i in config) {
      prop = config[i];

      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this['_' + i] = prop;
      }
    }

    this._config = config; // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.

    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
  }

  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;

    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }

    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        // make sure changes to properties don't modify parent config
        res[prop] = extend({}, res[prop]);
      }
    }

    return res;
  }

  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }

  var keys;

  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function (obj) {
      var i,
          res = [];

      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }

      return res;
    };
  }

  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };

  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }

  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };

  function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
      return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
      return val.slice(1);
    });
    return this._longDateFormat[key];
  }

  var defaultInvalidDate = 'Invalid date';

  function invalidDate() {
    return this._invalidDate;
  }

  var defaultOrdinal = '%d';
  var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }

  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    ss: '%d seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };

  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }

  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }

  var aliases = {};

  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }

  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }

  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);

        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }

    return normalizedInput;
  }

  var priorities = {};

  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }

  function getPrioritizedUnits(unitsObj) {
    var units = [];

    for (var u in unitsObj) {
      units.push({
        unit: u,
        priority: priorities[u]
      });
    }

    units.sort(function (a, b) {
      return a.priority - b.priority;
    });
    return units;
  }

  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }

  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {}; // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }

  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;

    if (typeof callback === 'string') {
      func = function () {
        return this[callback]();
      };
    }

    if (token) {
      formatTokenFunctions[token] = func;
    }

    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }

    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }

  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }

    return input.replace(/\\/g, '');
  }

  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;

    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }

    return function (mom) {
      var output = '',
          i;

      for (i = 0; i < length; i++) {
        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      }

      return output;
    };
  } // format date using native date object


  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;

    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }

    return format;
  }

  var match1 = /\d/; //       0 - 9

  var match2 = /\d\d/; //      00 - 99

  var match3 = /\d{3}/; //     000 - 999

  var match4 = /\d{4}/; //    0000 - 9999

  var match6 = /[+-]?\d{6}/; // -999999 - 999999

  var match1to2 = /\d\d?/; //       0 - 99

  var match3to4 = /\d\d\d\d?/; //     999 - 9999

  var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

  var match1to3 = /\d{1,3}/; //       0 - 999

  var match1to4 = /\d{1,4}/; //       0 - 9999

  var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

  var matchUnsigned = /\d+/; //       0 - inf

  var matchSigned = /[+-]?\d+/; //    -inf - inf

  var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
  // any word (or two) characters or numbers including two/three word month in arabic.
  // includes scottish gaelic two word and hyphenated months

  var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
  var regexes = {};

  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }

  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }

  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  var tokens = {};

  function addParseToken(token, callback) {
    var i,
        func = callback;

    if (typeof token === 'string') {
      token = [token];
    }

    if (isNumber(callback)) {
      func = function (input, array) {
        array[callback] = toInt(input);
      };
    }

    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }

  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }

  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }

  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8; // FORMATTING

  addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

  addUnitAlias('year', 'y'); // PRIORITIES

  addUnitPriority('year', 1); // PARSING

  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
  }); // HELPERS

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }

  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  } // HOOKS


  hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  }; // MOMENTS


  var getSetYear = makeGetSet('FullYear', true);

  function getIsLeapYear() {
    return isLeapYear(this.year());
  }

  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }

  function get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }

  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
      }
    }
  } // MOMENTS


  function stringGet(units) {
    units = normalizeUnits(units);

    if (isFunction(this[units])) {
      return this[units]();
    }

    return this;
  }

  function stringSet(units, value) {
    if (typeof units === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units);

      for (var i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units](value);
      }
    }

    return this;
  }

  function mod(n, x) {
    return (n % x + x) % x;
  }

  var indexOf;

  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function (o) {
      // I know
      var i;

      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }

      return -1;
    };
  }

  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }

    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  } // FORMATTING


  addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
  }); // ALIASES

  addUnitAlias('month', 'M'); // PRIORITY

  addUnitPriority('month', 8); // PARSING

  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  }); // LOCALES

  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

  function localeMonths(m, format) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months['standalone'];
    }

    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }

  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
    }

    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }

  function handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();

    if (!this._monthsParse) {
      // this is not used
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];

      for (i = 0; i < 12; ++i) {
        mom = createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    } // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse


    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);

      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }

      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      } // test the regex


      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  } // MOMENTS


  function setMonth(mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
      // No op
      return mom;
    }

    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

        if (!isNumber(value)) {
          return mom;
        }
      }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

    return mom;
  }

  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, 'Month');
    }
  }

  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }

  var defaultMonthsShortRegex = matchWord;

  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }

      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }

      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }

  var defaultMonthsRegex = matchWord;

  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }

      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }

      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }

  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;

    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    } // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.


    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);

    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }

    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }

  function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms); // the date constructor remaps years 0-99 to 1900-1999

    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }

    return date;
  }

  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments)); // the Date.UTC function remaps years 0-99 to 1900-1999

    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }

    return date;
  } // start-of-first-week - start-of-year


  function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;

    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }

    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }

  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;

    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }

    return {
      week: resWeek,
      year: resYear
    };
  }

  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  } // FORMATTING


  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W'); // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5); // PARSING

  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  }); // HELPERS
  // LOCALES

  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }

  var defaultLocaleWeek = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6 // The week that contains Jan 6th is the first week of the year.

  };

  function localeFirstDayOfWeek() {
    return this._week.dow;
  }

  function localeFirstDayOfYear() {
    return this._week.doy;
  } // MOMENTS


  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }

  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  } // FORMATTING


  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E'); // PRIORITY

  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11); // PARSING

  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
  }); // HELPERS

  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }

    if (!isNaN(input)) {
      return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);

    if (typeof input === 'number') {
      return input;
    }

    return null;
  }

  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }

    return isNaN(input) ? null : input;
  } // LOCALES


  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

  function localeWeekdays(m, format) {
    if (!m) {
      return isArray(this._weekdays) ? this._weekdays : this._weekdays['standalone'];
    }

    return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
  }

  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

  function localeWeekdaysShort(m) {
    return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }

  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

  function localeWeekdaysMin(m) {
    return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }

  function handleStrictParse$1(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];

      for (i = 0; i < 7; ++i) {
        mom = createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);

      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
      }

      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      } // test the regex


      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  } // MOMENTS


  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }

  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }

  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    } // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.


    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }

  var defaultWeekdaysRegex = matchWord;

  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }

      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }

  var defaultWeekdaysShortRegex = matchWord;

  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }

      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }

  var defaultWeekdaysMinRegex = matchWord;

  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }

      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }

  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);
      minp = this.weekdaysMin(mom, '');
      shortp = this.weekdaysShort(mom, '');
      longp = this.weekdays(mom, '');
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.


    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);

    for (i = 0; i < 7; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  } // FORMATTING


  function hFormat() {
    return this.hours() % 12 || 12;
  }

  function kFormat() {
    return this.hours() || 24;
  }

  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });

  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }

  meridiem('a', true);
  meridiem('A', false); // ALIASES

  addUnitAlias('hour', 'h'); // PRIORITY

  addUnitPriority('hour', 13); // PARSING

  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }

  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('k', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  }); // LOCALES

  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
  }

  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  } // MOMENTS
  // Setting the hour should keep the time, because the user explicitly
  // specified which hour they want. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.


  var getSetHour = makeGetSet('Hours', true);
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  }; // internal storage for locale config files

  var locales = {};
  var localeFamilies = {};
  var globalLocale;

  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  } // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


  function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;

    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;

      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));

        if (locale) {
          return locale;
        }

        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
          //the next array item is better than a shallower substring of this one
          break;
        }

        j--;
      }

      i++;
    }

    return globalLocale;
  }

  function loadLocale(name) {
    var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

    if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        var aliasedRequire = require;
        __webpack_require__(479)("./" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }

    return locales[name];
  } // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.


  function getSetGlobalLocale(key, values) {
    var data;

    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }

      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      } else {
        if (typeof console !== 'undefined' && console.warn) {
          //warn user if arguments are passed but the locale could not be set
          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
        }
      }
    }

    return globalLocale._abbr;
  }

  function defineLocale(name, config) {
    if (config !== null) {
      var locale,
          parentConfig = baseConfig;
      config.abbr = name;

      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);

          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }

            localeFamilies[config.parentLocale].push({
              name: name,
              config: config
            });
            return null;
          }
        }
      }

      locales[name] = new Locale(mergeConfigs(parentConfig, config));

      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function (x) {
          defineLocale(x.name, x.config);
        });
      } // backwards compat for now: also set the locale
      // make sure we set the locale AFTER all child locales have been
      // created, so we won't end up with the child locale set.


      getSetGlobalLocale(name);
      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }

  function updateLocale(name, config) {
    if (config != null) {
      var locale,
          tmpLocale,
          parentConfig = baseConfig; // MERGE

      tmpLocale = loadLocale(name);

      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }

      config = mergeConfigs(parentConfig, config);
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale; // backwards compat for now: also set the locale

      getSetGlobalLocale(name);
    } else {
      // pass null for config to unupdate, useful for tests
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }

    return locales[name];
  } // returns locale data


  function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }

    if (!key) {
      return globalLocale;
    }

    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);

      if (locale) {
        return locale;
      }

      key = [key];
    }

    return chooseLocale(key);
  }

  function listLocales() {
    return keys(locales);
  }

  function checkOverflow(m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }

      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }

      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }

      getParsingFlags(m).overflow = overflow;
    }

    return m;
  } // Pick the first defined of two or three arguments.


  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }

    if (b != null) {
      return b;
    }

    return c;
  }

  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());

    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }

    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  } // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]


  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        expectedWeekday,
        yearToUse;

    if (config._d) {
      return;
    }

    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    } //if the day of the year is set, figure out what it is


    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }

      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    } // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything


    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    } // Zero out whatever was not defaulted, including time


    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    } // Check for 24:00:00.000


    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.

    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
      config._a[HOUR] = 24;
    } // check for mismatching day of week


    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }

  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
    w = config._w;

    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).

      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);

      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      var curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

      week = defaults(w.w, curWeek.week);

      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;

        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from beginning of week
        weekday = w.e + dow;

        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to beginning of week
        weekday = dow;
      }
    }

    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  } // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
  ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

  var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

  function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;

    if (match) {
      getParsingFlags(config).iso = true;

      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }

      if (dateFormat == null) {
        config._isValid = false;
        return;
      }

      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            // match[2] should be 'T' or space
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }

        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }

      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }

      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }

      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }

    return result;
  }

  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);

    if (year <= 49) {
      return 2000 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }

    return year;
  }

  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }

  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }

    return true;
  }

  var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };

  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      // the only allowed military tz is Z
      return 0;
    } else {
      var hm = parseInt(numOffset, 10);
      var m = hm % 100,
          h = (hm - m) / 100;
      return h * 60 + m;
    }
  } // date and time from ref 2822 format


  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));

    if (match) {
      var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }

      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);

      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  } // date from iso format or fallback


  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }

    configFromISO(config);

    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    configFromRFC2822(config);

    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    } // Final attempt, use Input Fallback


    hooks.createFromInputFallback(config);
  }

  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  }); // constant that refers to the ISO standard

  hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


  hooks.RFC_2822 = function () {}; // date from string and format string


  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }

    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }

    config._a = [];
    getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
      //         'regex', getParseRegexForToken(token, config));

      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));

        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }

        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      } // don't parse if it's not a known token


      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }

        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    } // add remaining unparsed input length to the string


    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    } // clear _12h flag if hour is <= 12


    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    configFromArray(config);
    checkOverflow(config);
  }

  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
      // nothing to do
      return hour;
    }

    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);

      if (isPm && hour < 12) {
        hour += 12;
      }

      if (!isPm && hour === 12) {
        hour = 0;
      }

      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  } // date from string and array of format strings


  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;

    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }

    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);

      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }

      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);

      if (!isValid(tempConfig)) {
        continue;
      } // if there is any input that was not parsed add a penalty for that format


      currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;

      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }

    extend(config, bestMoment || tempConfig);
  }

  function configFromObject(config) {
    if (config._d) {
      return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }

  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));

    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, 'd');
      res._nextDay = undefined;
    }

    return res;
  }

  function prepareConfig(config) {
    var input = config._i,
        format = config._f;
    config._locale = config._locale || getLocale(config._l);

    if (input === null || format === undefined && input === '') {
      return createInvalid({
        nullInput: true
      });
    }

    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }

    if (!isValid(config)) {
      config._d = null;
    }

    return config;
  }

  function configFromInput(config) {
    var input = config._i;

    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      // from milliseconds
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }

  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
      strict = locale;
      locale = undefined;
    }

    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
      input = undefined;
    } // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423


    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }

  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }

  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  });
  var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }); // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.

  function pickBy(fn, moments) {
    var res, i;

    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }

    if (!moments.length) {
      return createLocal();
    }

    res = moments[0];

    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }

    return res;
  } // TODO: Use [].sort instead?


  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }

  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }

  var now = function () {
    return Date.now ? Date.now() : +new Date();
  };

  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

  function isDurationValid(m) {
    for (var key in m) {
      if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }

    var unitHasDecimal = false;

    for (var i = 0; i < ordering.length; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false; // only allow non-integers for smallest unit
        }

        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }

    return true;
  }

  function isValid$1() {
    return this._isValid;
  }

  function createInvalid$1() {
    return createDuration(NaN);
  }

  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
    minutes * 6e4 + // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately

    this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.

    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = getLocale();

    this._bubble();
  }

  function isDuration(obj) {
    return obj instanceof Duration;
  }

  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  } // FORMATTING


  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset();
      var sign = '+';

      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }

      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }

  offset('Z', ':');
  offset('ZZ', ''); // PARSING

  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  }); // HELPERS
  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']

  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
      return null;
    }

    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
  } // Return a moment from input, that is local/utc/zone equivalent to model.


  function cloneWithOffset(input, model) {
    var res, diff;

    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

      res._d.setTime(res._d.valueOf() + diff);

      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }

  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  } // HOOKS
  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.


  hooks.updateOffset = function () {}; // MOMENTS
  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.


  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;

    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);

        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }

      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }

      this._offset = input;
      this._isUTC = true;

      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }

      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }

      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }

  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }

      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }

  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;

      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }

    return this;
  }

  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
      var tZone = offsetFromString(matchOffset, this._i);

      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }

    return this;
  }

  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }

    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }

  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }

    var c = {};
    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
      var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }

    return this._isDSTShifted;
  }

  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }

  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  } // ASP.NET json date format regex


  var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  // and further modified to allow for strings containing both week and day

  var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

  function createDuration(input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
    match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input)) {
      duration = {};

      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

      };
    } else if (!!(match = isoRegex.exec(input))) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }

    return ret;
  }

  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;

  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

    return (isNaN(res) ? 0 : res) * sign;
  }

  function positiveMomentsDifference(base, other) {
    var res = {
      milliseconds: 0,
      months: 0
    };
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }

    res.milliseconds = +other - +base.clone().add(res.months, 'M');
    return res;
  }

  function momentsDifference(base, other) {
    var res;

    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }

    other = cloneWithOffset(other, base);

    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }

    return res;
  } // TODO: remove 'name' arg after deprecation is removed


  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp; //invert the arguments, but complain about it

      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }

      val = typeof val === 'string' ? +val : val;
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }

  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
      // No op
      return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
      setMonth(mom, get(mom, 'Month') + months * isAdding);
    }

    if (days) {
      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }

    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }

    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }

  var add = createAdder(1, 'add');
  var subtract = createAdder(-1, 'subtract');

  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }

  function calendar$1(time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';
    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }

  function clone() {
    return new Moment(this);
  }

  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }

  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }

  function isBetween(from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from),
        localTo = isMoment(to) ? to : createLocal(to);

    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }

    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }

  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }

  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }

  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }

  function diff(input, units, asFloat) {
    var that, zoneDelta, output;

    if (!this.isValid()) {
      return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
      return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);

    switch (units) {
      case 'year':
        output = monthDiff(this, that) / 12;
        break;

      case 'month':
        output = monthDiff(this, that);
        break;

      case 'quarter':
        output = monthDiff(this, that) / 3;
        break;

      case 'second':
        output = (this - that) / 1e3;
        break;
      // 1000

      case 'minute':
        output = (this - that) / 6e4;
        break;
      // 1000 * 60

      case 'hour':
        output = (this - that) / 36e5;
        break;
      // 1000 * 60 * 60

      case 'day':
        output = (this - that - zoneDelta) / 864e5;
        break;
      // 1000 * 60 * 60 * 24, negate dst

      case 'week':
        output = (this - that - zoneDelta) / 6048e5;
        break;
      // 1000 * 60 * 60 * 24 * 7, negate dst

      default:
        output = this - that;
    }

    return asFloat ? output : absFloor(output);
  }

  function monthDiff(a, b) {
    // difference in months
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
    anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;

    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

      adjust = (b - anchor) / (anchor2 - anchor);
    } //check for negative zero, return zero if negative zero


    return -(wholeMonthDiff + adjust) || 0;
  }

  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }

  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }

    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;

    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    if (isFunction(Date.prototype.toISOString)) {
      // native implementation is ~50x faster, use it when we can
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
      }
    }

    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
  }
  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */


  function inspect() {
    if (!this.isValid()) {
      return 'moment.invalid(/* ' + this._i + ' */)';
    }

    var func = 'moment';
    var zone = '';

    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
      zone = 'Z';
    }

    var prefix = '[' + func + '("]';
    var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }

  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }

    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }

  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }

  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  } // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.


  function locale(key) {
    var newLocaleData;

    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);

      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }

      return this;
    }
  }

  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });

  function localeData() {
    return this._locale;
  }

  function startOf(units) {
    units = normalizeUnits(units); // the following switch intentionally omits break keywords
    // to utilize falling through the cases.

    switch (units) {
      case 'year':
        this.month(0);

      /* falls through */

      case 'quarter':
      case 'month':
        this.date(1);

      /* falls through */

      case 'week':
      case 'isoWeek':
      case 'day':
      case 'date':
        this.hours(0);

      /* falls through */

      case 'hour':
        this.minutes(0);

      /* falls through */

      case 'minute':
        this.seconds(0);

      /* falls through */

      case 'second':
        this.milliseconds(0);
    } // weeks are a special case


    if (units === 'week') {
      this.weekday(0);
    }

    if (units === 'isoWeek') {
      this.isoWeekday(1);
    } // quarters are also special


    if (units === 'quarter') {
      this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
  }

  function endOf(units) {
    units = normalizeUnits(units);

    if (units === undefined || units === 'millisecond') {
      return this;
    } // 'date' is an alias for 'day', so it should be considered as such.


    if (units === 'date') {
      units = 'day';
    }

    return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
  }

  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
  }

  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }

  function toDate() {
    return new Date(this.valueOf());
  }

  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }

  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }

  function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
  }

  function isValid$2() {
    return isValid(this);
  }

  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }

  function invalidAt() {
    return getParsingFlags(this).overflow;
  }

  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  } // FORMATTING


  addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
  });

  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }

  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1); // PARSING

  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  }); // MOMENTS

  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }

  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }

  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }

  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;

    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }

  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;

    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);

      if (week > weeksTarget) {
        week = weeksTarget;
      }

      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }

  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  } // FORMATTING


  addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

  addUnitAlias('quarter', 'Q'); // PRIORITY

  addUnitPriority('quarter', 7); // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  }); // MOMENTS

  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  } // FORMATTING


  addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

  addUnitAlias('date', 'D'); // PRIORITY

  addUnitPriority('date', 9); // PARSING

  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  }); // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

  addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

  addUnitPriority('dayOfYear', 4); // PARSING

  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
  }); // HELPERS
  // MOMENTS

  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  } // FORMATTING


  addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

  addUnitAlias('minute', 'm'); // PRIORITY

  addUnitPriority('minute', 14); // PARSING

  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE); // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

  addUnitAlias('second', 's'); // PRIORITY

  addUnitPriority('second', 15); // PARSING

  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND); // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

  addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
  }); // ALIASES

  addUnitAlias('millisecond', 'ms'); // PRIORITY

  addUnitPriority('millisecond', 16); // PARSING

  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token;

  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }

  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }

  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  } // MOMENTS


  var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }

  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }

  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

  function createUnix(input) {
    return createLocal(input * 1000);
  }

  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }

  function preParsePostFormat(string) {
    return string;
  }

  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;

  function get$1(format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }

  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }

    format = format || '';

    if (index != null) {
      return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];

    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, 'month');
    }

    return out;
  } // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)


  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;

      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
      return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];

    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }

    return out;
  }

  function listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }

  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }

  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }

  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }

  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }

  getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  }); // Side effect imports

  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
  var mathAbs = Math.abs;

  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }

  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  } // supports only 2.0-style add(1, 's') or add(duration)


  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  } // supports only 2.0-style subtract(1, 's') or subtract(duration)


  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }

  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }

  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166

    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    } // The following code bubbles up values, see the tests for
    // examples of what that means.


    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24); // convert days to months

    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }

  function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
  }

  function monthsToDays(months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
  }

  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }

    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      return units === 'month' ? months : months / 12;
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(monthsToDays(this._months));

      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;

        case 'day':
          return days + milliseconds / 864e5;

        case 'hour':
          return days * 24 + milliseconds / 36e5;

        case 'minute':
          return days * 1440 + milliseconds / 6e4;

        case 'second':
          return days * 86400 + milliseconds / 1000;
        // Math.floor prevents floating point math errors here

        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;

        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  } // TODO: Use this.as('ms')?


  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }

    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }

  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }

  var asMilliseconds = makeAs('ms');
  var asSeconds = makeAs('s');
  var asMinutes = makeAs('m');
  var asHours = makeAs('h');
  var asDays = makeAs('d');
  var asWeeks = makeAs('w');
  var asMonths = makeAs('M');
  var asYears = makeAs('y');

  function clone$1() {
    return createDuration(this);
  }

  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
  }

  function makeGetter(name) {
    return function () {
      return this.isValid() ? this._data[name] : NaN;
    };
  }

  var milliseconds = makeGetter('milliseconds');
  var seconds = makeGetter('seconds');
  var minutes = makeGetter('minutes');
  var hours = makeGetter('hours');
  var days = makeGetter('days');
  var months = makeGetter('months');
  var years = makeGetter('years');

  function weeks() {
    return absFloor(this.days() / 7);
  }

  var round = Math.round;
  var thresholds = {
    ss: 44,
    // a few seconds to seconds
    s: 45,
    // seconds to minute
    m: 45,
    // minutes to hour
    h: 22,
    // hours to day
    d: 26,
    // days to month
    M: 11 // months to year

  }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime$1(posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));
    var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  } // This function allows you to set the rounding function for relative time strings


  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }

    if (typeof roundingFunction === 'function') {
      round = roundingFunction;
      return true;
    }

    return false;
  } // This function allows you to set a threshold for relative time strings


  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }

    if (limit === undefined) {
      return thresholds[threshold];
    }

    thresholds[threshold] = limit;

    if (threshold === 's') {
      thresholds.ss = limit - 1;
    }

    return true;
  }

  function humanize(withSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
  }

  var abs$1 = Math.abs;

  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }

  function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days = abs$1(this._days);
    var months = abs$1(this._months);
    var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60; // 12 months -> 1 year

    years = absFloor(months / 12);
    months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
    return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
  }

  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
  proto$2.lang = lang; // Side effect imports
  // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf'); // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
  }); // Side effect imports

  hooks.version = '2.23.0';
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

  hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
    // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',
    // <input type="date" />
    TIME: 'HH:mm',
    // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',
    // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',
    // <input type="time" step="0.001" />
    WEEK: 'GGGG-[W]WW',
    // <input type="week" />
    MONTH: 'YYYY-MM' // <input type="month" />

  };
  return hooks;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var core = __webpack_require__(13);

var hide = __webpack_require__(18);

var redefine = __webpack_require__(14);

var ctx = __webpack_require__(26);

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(69);
module.exports.easing = __webpack_require__(457);
module.exports.canvas = __webpack_require__(458);
module.exports.options = __webpack_require__(459);

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6);

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);

module.exports = {
  /**
   * @private
   */
  _set: function (scope, values) {
    return helpers.merge(this[scope] || (this[scope] = {}), values);
  }
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export type */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return executeIfFunction; });
/* unused harmony export switchcase */
/* unused harmony export switchcaseF */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return checkExpectedParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return callIfTrue; });
/* unused harmony export flatten */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return removeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return hasClass; });
/* unused harmony export toggleClass */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return manageBodyOverflow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return setAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return removeAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return outerHeight; });
/* unused harmony export outerWidth */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getSiblings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return findAncestor; });
/* unused harmony export findAncestorByTag */
/* unused harmony export matches */
/* unused harmony export getFirstFocusableElement */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getLastFocusableElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getUniqId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return setTabindex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return toggleTabindex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return initAriaControls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return removeAriaControls; });
/* unused harmony export toggleAttribute */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return setAriaControls; });
/* unused harmony export manageAriaControls */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getFocusableElements; });
/* unused harmony export getFocusableChildren */
/* unused harmony export isFocusable */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return setFirstElementFocus; });
/* unused harmony export setLastElementFocus */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return initFocusTrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return generateHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return throttle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return hasElement; });
/* unused harmony export range */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return extendDefaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return insertAfter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return manageTabindex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return setChildrenTabindex; });
var _this = this,
    _arguments = arguments;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/*
* TODO: add slideDown function
* TODO: add slideUp function
* TODO: add fadeIn function
* TODO: add fadeOut function
* TODO: add toggleFade function
* TODO: add easingFunc
* */

/**
 * Check type helpers
 * @example
 * type.isString('val') will return => true
 *
 * @param {obj} any variable to check
 */
var type = {};
['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'].forEach(function (name) {
  type["is".concat(name)] = function (obj) {
    return Object.prototype.toString.call(obj) === "[object ".concat(name, "]");
  };
}); // Better switch cases - https://hackernoon.com/rethinking-javascript-eliminate-the-switch-statement-for-better-code-5c81c044716d

/*
* TODO: add documentation
* */

var executeIfFunction = function executeIfFunction(f) {
  return type.isFunction(f) ? f() : f;
};
/*
* TODO: add documentation
* */

var switchcase = function switchcase(cases) {
  return function (defaultCase) {
    return function (key) {
      return Object.prototype.hasOwnProperty.call(cases, key) ? cases[key] : defaultCase;
    };
  };
};
/*
* TODO: add documentation
* */

var switchcaseF = function switchcaseF(cases) {
  return function (defaultCase) {
    return function (key) {
      return executeIfFunction(switchcase(cases)(defaultCase)(key));
    };
  };
};
/**
 * Checks for expected params (whether they exists and they're right type) before starting main process
 *
 * @example
 * checkExpectedParams({
 *     string: [var1, var2],
 *     array: [var3, var4],
 *     number: [var5],
 *     function: [var6],
 *     boolean: [var7],
 * });
 *
 * @param {Object} params, object with in such order: params type => array of params with this type.
 */

var checkExpectedParams = function checkExpectedParams(params) {
  var types = function types(el) {
    return switchcase({
      string: typeof el === 'string',
      number: typeof el === 'number',
      boolean: typeof el === 'boolean',
      function: typeof el === 'function',
      element: el instanceof Element,
      node: el.nodeType,
      array: Array.isArray(el),
      object: el instanceof Object && !(el instanceof Array)
    })(false);
  };

  Object.keys(params).forEach(function (key) {
    if (!types(params[key])('array')) {
      throw new Error("checkExpectedParams: You should pass values as an Array! Get: ".concat(params[key]));
    }

    params[key].forEach(function (param) {
      if (param === undefined || param === null) {
        throw new Error('checkExpectedParams: Parameter is undefined!');
      }

      if (!types(param)(key)) {
        console.log('Element with wrong type: ', param);
        window.errorExpected = param;
        throw new Error("checkExpectedParams: Parameter has wrong type. See above or check 'window.errorExpected'.\n                    (Expecting '".concat(key, "' type for '").concat(Object.prototype.toString.call(param), "')!"));
      }
    });
  });
};
/**
 * Call passed functions whether condition result
 *
 * @param cond {Boolean}     Condition to check
 * @param f1 {Function}      First function to call if condition is true
 * @param f2 {Function|Null} Optional,second function to call if condition is false
 * @returns {*}              Result of executed function
 */

var callIfTrue = function callIfTrue(cond, f1) {
  var f2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  checkExpectedParams({
    boolean: [cond],
    function: [f1]
  });
  return cond ? f1() : executeIfFunction(f2);
};
/**
 * Flatten array using spread operator.
 * @example
 * flatten(['aa', 'ab', ['ac', 'ad']]) will return => ['aa', 'ab', 'ac', 'ad']
 *
 * @param {array} arr array to flatten
 */

var flatten = function flatten(arr) {
  var _ref;

  return (_ref = []).concat.apply(_ref, _toConsumableArray(arr || []));
};
/**
 * Add class/classes to element.
 * @example
 * addClass(elem, 'your-class')
 * addClass(elem, ['your-class1', 'your-class2', 'your-class3'])
 *
 * @param {Element} el DOM HTML Element
 * @param {String||Array} classNames class or list of classes to add
 */

var addClass = function addClass(el, classNames) {
  checkExpectedParams({
    element: [el]
  });
  [].concat(classNames).forEach(function (className) {
    if (el.classList) {
      el.classList.add(className); // IE 10+
    } else {
      el.className += " ".concat(className); // IE 8+
    }
  });
};
/**
 * Remove element class/classes.
 *
 * @example
 * removeClass(elem, 'your-class')
 * removeClass(elem, ['your-class1', 'your-class2', 'your-class3'])
 *
 * @param {Element} el DOM HTML Element
 * @param {String||Array} classNames class or list of classes to remove
 */

var removeClass = function removeClass(el, classNames) {
  checkExpectedParams({
    element: [el]
  });
  [].concat(classNames).forEach(function (className) {
    if (el.classList) {
      el.classList.remove(className); // IE 10+
    } else {
      el.className = el.className.replace(new RegExp("(^|\\b)".concat(className.split(' ').join('|'), "(\\b|$)"), 'gi'), ' '); // IE 8+
    }
  });
};
/**
 * Checks if element has className.
 *
 * @example
 * hasClass(elem, 'your-class')
 *
 * @param {Element} el DOM HTML Element
 * @param {String} className class to check
 * @returns {Boolean} `true` or `false`
 */

var hasClass = function hasClass(el, className) {
  checkExpectedParams({
    element: [el],
    string: [className]
  });

  if (el.classList) {
    return el.classList.contains(className); // IE 10+
  } // If anchor within a svg element in IE; https://caniuse.com/#search=classList


  var classProp = Object.prototype.toString.call(el) === '[object SVGAElement]' ? el.className.baseVal : el.className;
  return new RegExp("(^| )".concat(className, "( |$)"), 'gi').test(classProp); // IE 8+ ?
};
/**
 * Switch element className.
 *
 * @example
 * toggleClass(elem, 'your-class')
 *
 * @param {Element} el DOM HTML Element
 * @param {String} className class to check
 * @returns {bool} `true` or `false`
 */

var toggleClass = function toggleClass(el, className) {
  checkExpectedParams({
    element: [el],
    string: [className]
  });

  if (hasClass(el, className)) {
    removeClass(el, className);
  } else {
    addClass(el, className);
  }
};
/**
 * Manage body overflow styles.
 *
 * @example
 * manageBodyOverflow('hidden')
 * manageBodyOverflow('visible')
 *
 * @param {String} state by default `value = null`, set `hidden` if you want to add overflow
 * @param {String} wrapper by default `value = site-wrapper`,
 * all wrapper selector
 * set `hidden` if you want to add overflow
 */

var manageBodyOverflow = function manageBodyOverflow() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var wrapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'site-wrapper';
  var wrap = document.querySelector(".".concat(wrapper));

  if (state === 'hidden') {
    addClass(document.body, '-overflow-hidden');
    addClass(wrap, '-overflow-hidden');
  } else {
    removeClass(document.body, '-overflow-hidden');
    removeClass(wrap, '-overflow-hidden');
  }
};
/**
 * Add attributes list.
 *
 * @example
 * setAttributes(elem, {
 *   'role': 'button',
 *   'checked': 'true'
 * })
 *
 * @param {Element} el DOM HTML Element
 * @param {Object} attrs attributes example `{'role':'button', 'aria-hidden': true}`
 */

var setAttributes = function setAttributes(el, attrs) {
  checkExpectedParams({
    element: [el],
    object: [attrs]
  });
  Object.keys(attrs).forEach(function (attribute) {
    el.setAttribute(attribute, attrs[attribute]);
  });
};
/**
 * Remove attributes list from node.
 *
 * @example
 * removeAttributes(elem, ['role', 'aria-hidden', 'aria-controls'])
 *
 * @param {Element} el DOM HTML Element
 * @param {Array} attrsArray attributes array `['role', 'aria-hidden']`
 */

var removeAttributes = function removeAttributes(el, attrsArray) {
  checkExpectedParams({
    element: [el],
    array: [attrsArray]
  });
  attrsArray.forEach(function (attribute) {
    el.removeAttribute(attribute);
  });
};
/**
 * Return height or width contains elem + padding + margin + border.
 *
 * @example
 * outerHeight(elem, )
 *
 * @param {Element} el DOM node
 * @param {String} dimensionType String
 * @returns {Number} height element outer height
 */

var outerDimensions = function outerDimensions(el, dimensionType) {
  checkExpectedParams({
    element: [el],
    string: [dimensionType]
  });
  var value = el["offset".concat(dimensionType)];
  var style = getComputedStyle(el);
  var margins = switchcase({
    Height: ['marginTop', 'marginBottom'],
    Width: ['marginLeft', 'marginRight']
  })('Height');

  var _margins = margins(dimensionType),
      _margins2 = _slicedToArray(_margins, 2),
      m1 = _margins2[0],
      m2 = _margins2[1];

  value += parseInt(style[m1], 10) + parseInt(style[m2], 10);
  return value;
};
/**
 * Return height contains elem + padding + margin + border.
 *
 * @example
 * outerHeight(elem)
 *
 * @param {Element} el DOM node
 * @returns {Number} height element outer height
 */


var outerHeight = function outerHeight(el) {
  return outerDimensions(el, 'Height');
};
/**
 * Return width contains elem + padding + margin + border.
 *
 * @example
 * outerWidth(elem)
 *
 * @param {Element} el DOM node
 * @returns {Number} width element outer width
 */

var outerWidth = function outerWidth(el) {
  return outerDimensions(el, 'Width');
};
/**
 * Get the next, previous or all siblings of an element
 * or retrieve siblings that match a given selector.
 * https://plainjs.com/javascript/traversing/get-siblings-of-an-element-40/
 *
 * @param  {Node} el DOM HTML Element
 * @param {Function} filter
 * @returns {Array} siblings array
 */

var getSiblings = function getSiblings(el, filter) {
  checkExpectedParams({
    node: [el],
    function: filter
  });
  var siblings = [];
  var elem = el.parentElement.firstElementChild;

  do {
    if (!filter || filter(elem)) {
      siblings.push(elem);
    }
  } while ((elem = elem.nextElementSibling) !== null);

  return siblings;
};
/**
 * Find ancestor by className, works like parents() method in jQuery.
 * http://jsfiddle.net/8RfbT/69/
 *
 * @param {Element} el DOM HTML Element
 * @param {String} cls parent class
 * @returns {Node} parent node
 */

var findAncestor = function findAncestor(el, cls) {
  checkExpectedParams({
    element: [el],
    string: [cls]
  });
  var elem = el;

  while (!hasClass(elem, cls)) {
    if (elem === document.body) {
      elem = null;
      break;
    }

    elem = elem.parentNode;
  }

  return elem;
};
/**
 * Find ancestor by tagName
 *
 * @param {Element} el DOM HTML Element
 * @param {String} tagName
 * @returns {Node} parent node
 */

var findAncestorByTag = function findAncestorByTag(el, tagName) {
  checkExpectedParams({
    element: [el],
    string: [tagName]
  });
  var elem = el;

  while (elem.tagName.toUpperCase() !== tagName.toUpperCase() && (elem = elem.parentNode)) {
    ;
  }

  return elem;
};
/**
 * Check the current matched element against a selector,
 * return true if element matches the given arguments.
 *
 * @example
 * matches(elem, '.my-class')
 *
 * @param {Element} el DOM HTML Element
 * @param {String} selector match class
 * @returns {bool} true or false
 */

var matches = function matches(el, selector) {
  (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
};
/**
 * Get first focusable element inside node.
 *
 * @example
 * getFirstFocusableElement(elem)
 *
 * @param {Element|String} el parent selector to search focusable elements
 * @returns {Node} DOM Node
 */

var getFirstFocusableElement = function getFirstFocusableElement(el) {
  var elem = type.isString(el) ? document.querySelector(el) : el;
  return elem.querySelector('a, input, select, button');
};
/**
 * Get last focusable element inside node.
 *
 * @example
 * getLastFocusableElement(elem)
 *
 * @param {Element|String} el parent selector to search focusable elements
 * @returns {Node} DOM Node
 */

var getLastFocusableElement = function getLastFocusableElement(el) {
  var elem = type.isString(el) ? document.querySelector(el) : el;
  var elemItems = elem.querySelectorAll('a, input, select, button');
  return elemItems[elemItems.length - 1];
};
/**
 * Generate unique ID.
 *
 * @example
 * getUniqId()
 *
 * @returns {Number} unique number
 */

var getUniqId = function getUniqId() {
  return Math.random().toString(36).substr(2, 16);
};
/**
 * Set tabindex to all focusable elements.
 *
 * @example
 * setTabindex(elem, 1)
 * setTabindex(elem, 0)
 *
 * @param {Element} el DOM HTML Element
 * @param {Number|String} index tabindex number
 */

var setTabindex = function setTabindex(el, index) {
  var elem = type.isString(el) ? document.querySelector(el) : el;
  var elemItems = elem.querySelectorAll('a, input, select, button');

  for (var i = 0; i < elemItems.length; i++) {
    elemItems[i].setAttribute('tabindex', parseInt(index, 10));
  }
};
/*
* TODO: add documentation
* */

var toggleTabindex = function toggleTabindex(element) {
  var state = element.getAttribute('tabindex') || 0;
  return element.setAttribute('tabindex', state < 0 ? 0 : -1);
};
/**
 * Add a11y aria attributes, dropdown pattern.
 *
 * @example
 * initAriaControls(elementToggle, elementTarget)
 * initAriaControls([elementToggle1, elementToggle2], elementTarget)
 * initAriaControls([elementToggle1, elementToggle2], '#target-selector')
 *
 * @param {(Node|Array)} toggles DOM Node or Nodes array -
 * Nodes or Node which will manipulate target element
 * @param {(Node|String)} target Dom Node or string - element which will be associated with toggles
 * @param {Array} exclude array of classes to exclude some attributes
 */

var initAriaControls = function initAriaControls(toggles, target) {
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['close', 'overlay', 'toggle'];
  var id = "relations-".concat(getUniqId());
  [].concat(toggles).forEach(function (toggle) {
    var attrs = {
      'aria-controls': id,
      'aria-expanded': false
    }; // Add 'aria-haspopup' if it's not a close btn or overlay

    var excluded = exclude.filter(function (word) {
      return toggle.className.indexOf(word) >= 0;
    });

    if (!excluded.length) {
      attrs['aria-haspopup'] = true;
    }

    setAttributes(toggle, attrs);
  });
  var checkedTarget = type.isString(target) ? document.querySelector(target) : target;
  checkedTarget.id = id;
  checkedTarget.setAttribute('aria-hidden', true);
};
/**
 * Remove all Aria attributes inside element
 *
 * @example
 * removeAriaControls(elem)
 *
 * @param {Element} el DOM HTML Element
 */

var removeAriaControls = function removeAriaControls(el) {
  // Remove all aria controls from current element
  removeAttributes(el, ['aria-hidden', 'aria-expanded', 'aria-haspopup', 'aria-controls']);
  [].slice.call(el.querySelectorAll('*')).forEach(function (elem) {
    // Remove all aria controls from each child
    removeAttributes(elem, ['aria-hidden', 'aria-expanded', 'aria-haspopup', 'aria-controls', 'id']);
  });
};
/**
 * Toggle attribute boolean state.
 *
 * @example
 * toggleAttribute(elem, 'aria-hidden')
 *
 * @param {Element} el DOM HTML Element
 * @param {String} attr attribute name
 */

var toggleAttribute = function toggleAttribute(el, attr) {
  checkExpectedParams({
    element: [el],
    string: [attr]
  });
  var value = el.getAttribute(attr) === 'true' ? 'false' : 'true';
  el.setAttribute(attr, value);
};
/**
 * Manage a11y aria attributes by state.
 * State value can be: `true`, `false`, `'opened'`, `'closed'`
 *
 * @example
 * setAriaControls(elemToggle, elemTarget, true)
 * setAriaControls(elemToggle, elemTarget, false)
 * setAriaControls(elemToggle, elemTarget, 'opened')
 * setAriaControls(elemToggle, elemTarget, 'closed')
 * setAriaControls([elemToggle1, elemToggle2], elemTarget, true)
 *
 * @param {(Element|Array)} toggles DOM Node or Nodes array -
 * Nodes or Node which will manipulate target element
 * @param {(Element|String)} target Dom Node or string - element which will be associated with toggles
 * @param {(String|boolean)} state set element state can be string or bool
 */

var setAriaControls = function setAriaControls(toggles, target, state) {
  var ariaState = state === 'opened' || state === true ? 1 : 0;
  [].concat(toggles).forEach(function (toggle) {
    toggle.setAttribute('aria-expanded', (!!ariaState).toString());
  });
  target.setAttribute('aria-hidden', (!ariaState).toString());
};
/**
 * Toggle a11y aria controls, dropdown pattern
 *
 * @example
 * manageAriaControls(elemToggle, elemTarget)
 * manageAriaControls([elemToggle1, elemToggle2], elemTarget)
 *
 * @param {(Element|Array)} toggles DOM Node or Nodes array -
 * Nodes or Node which will manipulate target element
 * @param {Element} target Dom Node or string - element which will be associated with toggles
 */

var manageAriaControls = function manageAriaControls(toggles, target) {
  var targetAriaState = target.getAttribute('aria-hidden');
  [].concat(toggles).forEach(function (toggle) {
    setAriaControls(toggle, target, targetAriaState === 'true');
  });
};
/*
* TODO: add documentation
* */

var getFocusableElements = function getFocusableElements(el) {
  var onlyTabbable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  checkExpectedParams({
    element: [el],
    boolean: [onlyTabbable]
  });
  var focusableElementsString;

  if (onlyTabbable) {
    focusableElementsString = '[tabindex="0"]';
  } else {
    focusableElementsString = 'a[href],' + ' area[href],' + ' input:not([disabled]),' + ' select:not([disabled]),' + ' textarea:not([disabled]),' + ' button:not([disabled]),' + ' iframe,' + ' object,' + ' embed,' + ' [tabindex="0"],' + ' [contenteditable]';
  }

  return Array.prototype.slice.call(el.querySelectorAll(focusableElementsString));
};
/**
 * TODO: add documentation
 *
 * @param element
 * @param onlyTabbable
 */

var getFocusableChildren = function getFocusableChildren(element) {
  var onlyTabbable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return getFocusableElements(element, onlyTabbable).filter(function (item) {
    return item.parentNode === element;
  });
};
/*
* TODO: add documentation
* */

var isFocusable = function isFocusable(node) {
  var tags = ['a', 'button', 'select', 'input', 'textarea'];
  return tags.filter(function (tag) {
    return node.tagName.toLowerCase() === tag;
  }).length > 0;
};
/*
* TODO: add documentation
* */

var setFirstElementFocus = function setFirstElementFocus(elements) {
  var element = elements[0];
  element.focus();
};
/*
* TODO: add documentation
* */

var setLastElementFocus = function setLastElementFocus(elements) {
  var element = elements[elements.length - 1];
  element.focus();
};
/*
* TODO: add documentation
* */

var initFocusTrap = function initFocusTrap(element, event) {
  var onlyTabbable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var focusableElements = onlyTabbable ? getFocusableElements(element, true) : getFocusableElements(element);
  var firstFocusableElement = focusableElements[0];
  var lastFocusableElement = focusableElements[focusableElements.length - 1]; // Listen for the Tab key

  if (event.keyCode === 9) {
    // If Shift + Tab
    if (event.shiftKey) {
      if (document.activeElement === firstFocusableElement) {
        event.preventDefault(); // jump to the last focusable element

        lastFocusableElement.focus();
      }
    } else {
      if (document.activeElement === lastFocusableElement) {
        event.preventDefault(); // jump to the first focusable element

        firstFocusableElement.focus();
      }
    }
  }
};
/*
* TODO: add documentation
* */

var generateHash = function generateHash(str) {
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var char = str.charCodeAt(i);
    hash = hash * 31 + char;
    hash |= 0;
  }

  return hash;
};
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Function} fn      A function to be executed after delay milliseconds. The `this` context and all arguments are
 *                             passed through, as-is, to `callback` when the debounced-function is executed.
 * @param  {Number}   delay   A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @return {Function} A new, debounced function.
 */

var debounce = function debounce(fn, delay) {
  var timer = null;
  return function () {
    var context = _this;
    var args = _arguments;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };
};
/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param {Function} fn         A function to be executed after delay milliseconds. The `this` context and all arguments are
 *                              passed through, as-is, to `callback` when the throttled-function is executed.
 * @param {Number}   threshold  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {Object}   scope      Optional, you can pass context for callback function.
 *
 * @return {Function} A new, throttled, function.
 */

var throttle = function throttle(fn) {
  var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
  var scope = arguments.length > 2 ? arguments[2] : undefined;
  var last;
  var deferTimer;
  return function () {
    var context = scope || _this;
    var now = +new Date();

    for (var _len = arguments.length, list = new Array(_len), _key = 0; _key < _len; _key++) {
      list[_key] = arguments[_key];
    }

    var args = list;

    if (last && now < last + threshold) {
      // hold on to it
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fn.apply(context, args);
      }, threshold);
    } else {
      last = now;
      fn.apply(context, args);
    }
  };
};
/*
* TODO: add documentation
* */

var hasElement = function hasElement(list, element) {
  if (element !== null) {
    for (var i = 0; i < list.length; i++) {
      if (list[i] === element) {
        return list[i] === element;
      }
    }
  }
};
/**
 * Return array with given range
 *
 * @example
 * range(1, 20, true)
 *
 * @param {Number} left, start of the array
 * @param {String} right, end fo the array
 * @param {Boolean} inclusive, whether returned array should be inclusive or not
 * @returns {Array} generated array
 */

var range = function range(left, right) {
  var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var arr = [];
  var asc = left < right;
  var ascEnd = asc ? right + 1 : right - 1;
  var end = !inclusive ? right : ascEnd;

  for (var i = left; asc ? i < end : i > end; asc ? i += 1 : i -= 1) {
    arr.push(i);
  }

  return arr;
};
/*
* TODO: add documentation
* */

var extendDefaults = function extendDefaults() {
  var isObject = function isObject(obj) {
    return obj && _typeof(obj) === 'object';
  };

  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }

  return objects.reduce(function (prev, obj) {
    Object.keys(obj).forEach(function (key) {
      var previousValue = prev[key];
      var objectValue = obj[key];

      if (Array.isArray(previousValue) && Array.isArray(objectValue)) {
        prev[key] = previousValue.concat.apply(previousValue, _toConsumableArray(objectValue));
      } else if (isObject(previousValue) && isObject(objectValue)) {
        prev[key] = extendDefaults(previousValue, objectValue);
      } else {
        prev[key] = objectValue;
      }
    });
    return prev;
  }, {});
};
/**
 * Inserting Node element after given element.
 *
 * @param {Node} newNode, new Node element to be inserted after refNode.
 * @param {Node} refNode, reference Node element for inserting.
 */

var insertAfter = function insertAfter(newNode, refNode) {
  checkExpectedParams({
    node: [newNode, refNode]
  });
  refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
};
/*
* TODO: add documentation
* */

var manageTabindex = function manageTabindex(el, value) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  checkExpectedParams({
    element: [el],
    number: [depth]
  });

  if (!depth) {
    return setTabindex(el, value);
  }

  _toConsumableArray(el.children).forEach(function (child) {
    if (isFocusable(child)) {
      child.setAttribute('tabindex', value);
    }

    if (depth > 1) {
      manageTabindex(child, value, depth - 1);
    }
  });
};
/*
* TODO: add documentation
* */

var setChildrenTabindex = function setChildrenTabindex(element, value) {
  _toConsumableArray(element.children).forEach(function (child) {
    return isFocusable(child) ? child.setAttribute('tabindex', value) : false;
  });
}; // Production steps of ECMA-262, Edition 6, 22.1.2.1
// Référence : https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from

if (!Array.from) {
  Array.from = function () {
    var toStr = Object.prototype.toString;

    var isCallable = function isCallable(fn) {
      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    };

    var toInteger = function toInteger(value) {
      var number = Number(value);

      if (isNaN(number)) {
        return 0;
      }

      if (number === 0 || !isFinite(number)) {
        return number;
      }

      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    };

    var maxSafeInteger = Math.pow(2, 53) - 1;

    var toLength = function toLength(value) {
      var len = toInteger(value);
      return Math.min(Math.max(len, 0), maxSafeInteger);
    }; // La propriété length de la méthode vaut 1.


    return function from(arrayLike
    /*, mapFn, thisArg */
    ) {
      // 1. Soit C, la valeur this
      var C = this; // 2. Soit items le ToObject(arrayLike).

      var items = Object(arrayLike); // 3. ReturnIfAbrupt(items).

      if (arrayLike == null) {
        throw new TypeError('Array.from doit utiliser un objet semblable à un tableau - null ou undefined ne peuvent pas être utilisés');
      } // 4. Si mapfn est undefined, le mapping sera false.


      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
      var T;

      if (typeof mapFn !== 'undefined') {
        // 5. sinon
        // 5. a. si IsCallable(mapfn) est false, on lève une TypeError.
        if (!isCallable(mapFn)) {
          throw new TypeError('Array.from: lorsqu il est utilisé le deuxième argument doit être une fonction');
        } // 5. b. si thisArg a été fourni, T sera thisArg ; sinon T sera undefined.


        if (arguments.length > 2) {
          T = arguments[2];
        }
      } // 10. Soit lenValue pour Get(items, "length").
      // 11. Soit len pour ToLength(lenValue).


      var len = toLength(items.length); // 13. Si IsConstructor(C) vaut true, alors
      // 13. a. Soit A le résultat de l'appel à la méthode interne [[Construct]] avec une liste en argument qui contient l'élément len.
      // 14. a. Sinon, soit A le résultat de ArrayCreate(len).

      var A = isCallable(C) ? Object(new C(len)) : new Array(len); // 16. Soit k égal à 0.

      var k = 0; // 17. On répète tant que k < len…

      var kValue;

      while (k < len) {
        kValue = items[k];

        if (mapFn) {
          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }

        k += 1;
      } // 18. Soit putStatus égal à Put(A, "length", len, true).


      A.length = len; // 20. On renvoie A.

      return A;
    };
  }();
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(72)('wks');

var uid = __webpack_require__(37);

var Symbol = __webpack_require__(5).Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(21);

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);

var IE8_DOM_DEFINE = __webpack_require__(100);

var toPrimitive = __webpack_require__(31);

var dP = Object.defineProperty;
exports.f = __webpack_require__(12) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 13 */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.1'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var hide = __webpack_require__(18);

var has = __webpack_require__(17);

var SRC = __webpack_require__(37)('src');

var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(13).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(29);

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var fails = __webpack_require__(3);

var defined = __webpack_require__(29);

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(11);

var createDesc = __webpack_require__(36);

module.exports = __webpack_require__(12) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(51);

var defined = __webpack_require__(29);

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(52);

var createDesc = __webpack_require__(36);

var toIObject = __webpack_require__(19);

var toPrimitive = __webpack_require__(31);

var has = __webpack_require__(17);

var IE8_DOM_DEFINE = __webpack_require__(100);

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(12) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(1);

var core = __webpack_require__(13);

var fails = __webpack_require__(3);

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(26);

var IObject = __webpack_require__(51);

var toObject = __webpack_require__(15);

var toLength = __webpack_require__(10);

var asc = __webpack_require__(359);

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);

      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var color = __webpack_require__(132);

var helpers = __webpack_require__(2);

function interpolate(start, view, model, ease) {
  var keys = Object.keys(model);
  var i, ilen, key, actual, origin, target, type, c0, c1;

  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    target = model[key]; // if a value is added to the model after pivot() has been called, the view
    // doesn't contain it, so let's initialize the view to the target value.

    if (!view.hasOwnProperty(key)) {
      view[key] = target;
    }

    actual = view[key];

    if (actual === target || key[0] === '_') {
      continue;
    }

    if (!start.hasOwnProperty(key)) {
      start[key] = actual;
    }

    origin = start[key];
    type = typeof target;

    if (type === typeof origin) {
      if (type === 'string') {
        c0 = color(origin);

        if (c0.valid) {
          c1 = color(target);

          if (c1.valid) {
            view[key] = c1.mix(c0, ease).rgbString();
            continue;
          }
        }
      } else if (type === 'number' && isFinite(origin) && isFinite(target)) {
        view[key] = origin + (target - origin) * ease;
        continue;
      }
    }

    view[key] = target;
  }
}

var Element = function (configuration) {
  helpers.extend(this, configuration);
  this.initialize.apply(this, arguments);
};

helpers.extend(Element.prototype, {
  initialize: function () {
    this.hidden = false;
  },
  pivot: function () {
    var me = this;

    if (!me._view) {
      me._view = helpers.clone(me._model);
    }

    me._start = {};
    return me;
  },
  transition: function (ease) {
    var me = this;
    var model = me._model;
    var start = me._start;
    var view = me._view; // No animation -> No Transition

    if (!model || ease === 1) {
      me._view = model;
      me._start = null;
      return me;
    }

    if (!view) {
      view = me._view = {};
    }

    if (!start) {
      start = me._start = {};
    }

    interpolate(start, view, model, ease);
    return me;
  },
  tooltipPosition: function () {
    return {
      x: this._model.x,
      y: this._model.y
    };
  },
  hasValue: function () {
    return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
  }
});
Element.extend = helpers.inherits;
module.exports = Element;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(27);

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 28 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__(12)) {
  var LIBRARY = __webpack_require__(38);

  var global = __webpack_require__(5);

  var fails = __webpack_require__(3);

  var $export = __webpack_require__(1);

  var $typed = __webpack_require__(68);

  var $buffer = __webpack_require__(97);

  var ctx = __webpack_require__(26);

  var anInstance = __webpack_require__(48);

  var propertyDesc = __webpack_require__(36);

  var hide = __webpack_require__(18);

  var redefineAll = __webpack_require__(49);

  var toInteger = __webpack_require__(21);

  var toLength = __webpack_require__(10);

  var toIndex = __webpack_require__(126);

  var toAbsoluteIndex = __webpack_require__(40);

  var toPrimitive = __webpack_require__(31);

  var has = __webpack_require__(17);

  var classof = __webpack_require__(53);

  var isObject = __webpack_require__(6);

  var toObject = __webpack_require__(15);

  var isArrayIter = __webpack_require__(89);

  var create = __webpack_require__(41);

  var getPrototypeOf = __webpack_require__(43);

  var gOPN = __webpack_require__(42).f;

  var getIterFn = __webpack_require__(91);

  var uid = __webpack_require__(37);

  var wks = __webpack_require__(9);

  var createArrayMethod = __webpack_require__(24);

  var createArrayIncludes = __webpack_require__(58);

  var speciesConstructor = __webpack_require__(54);

  var ArrayIterators = __webpack_require__(93);

  var Iterators = __webpack_require__(45);

  var $iterDetect = __webpack_require__(61);

  var setSpecies = __webpack_require__(47);

  var arrayFill = __webpack_require__(92);

  var arrayCopyWithin = __webpack_require__(117);

  var $DP = __webpack_require__(11);

  var $GOPD = __webpack_require__(22);

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, {
      get: function () {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) result[index] = arguments[index++];

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(6); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(37)('meta');

var isObject = __webpack_require__(6);

var has = __webpack_require__(17);

var setDesc = __webpack_require__(11).f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function (it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

var layouts = __webpack_require__(55);

module.exports = {
  // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
  // use the new chart options to grab the correct scale
  constructors: {},
  // Use a registration function so that we can move to an ES6 map when we no longer need to support
  // old browsers
  // Scale config defaults
  defaults: {},
  registerScaleType: function (type, scaleConstructor, scaleDefaults) {
    this.constructors[type] = scaleConstructor;
    this.defaults[type] = helpers.clone(scaleDefaults);
  },
  getScaleConstructor: function (type) {
    return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
  },
  getScaleDefaults: function (type) {
    // Return the scale defaults merged with the global settings so that we always use the latest ones
    return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
  },
  updateScaleDefaults: function (type, additions) {
    var me = this;

    if (me.defaults.hasOwnProperty(type)) {
      me.defaults[type] = helpers.extend(me.defaults[type], additions);
    }
  },
  addScalesToLayout: function (chart) {
    // Adds each scale to the chart.boxes array to be sized accordingly
    helpers.each(chart.scales, function (scale) {
      // Set ILayoutItem parameters for backwards compatibility
      scale.fullWidth = scale.options.fullWidth;
      scale.position = scale.options.position;
      scale.weight = scale.options.weight;
      layouts.addBox(chart, scale);
    });
  }
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};
module.exports.Arc = __webpack_require__(465);
module.exports.Line = __webpack_require__(466);
module.exports.Point = __webpack_require__(467);
module.exports.Rectangle = __webpack_require__(468);

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(102);

var enumBugKeys = __webpack_require__(75);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(21);

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(4);

var dPs = __webpack_require__(103);

var enumBugKeys = __webpack_require__(75);

var IE_PROTO = __webpack_require__(74)('IE_PROTO');

var Empty = function () {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(71)('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(77).appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(102);

var hiddenKeys = __webpack_require__(75).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(17);

var toObject = __webpack_require__(15);

var IE_PROTO = __webpack_require__(74)('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(11).f;

var has = __webpack_require__(17);

var TAG = __webpack_require__(9)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(9)('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(18)(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);

var dP = __webpack_require__(11);

var DESCRIPTORS = __webpack_require__(12);

var SPECIES = __webpack_require__(9)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () {
      return this;
    }
  });
};

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(14);

module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);

  return target;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6);

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(28); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 52 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(28);

var TAG = __webpack_require__(9)('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(4);

var aFunction = __webpack_require__(27);

var SPECIES = __webpack_require__(9)('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);

function filterByPosition(array, position) {
  return helpers.where(array, function (v) {
    return v.position === position;
  });
}

function sortByWeight(array, reverse) {
  array.forEach(function (v, i) {
    v._tmpIndex_ = i;
    return v;
  });
  array.sort(function (a, b) {
    var v0 = reverse ? b : a;
    var v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
  });
  array.forEach(function (v) {
    delete v._tmpIndex_;
  });
}
/**
 * @interface ILayoutItem
 * @prop {String} position - The position of the item in the chart layout. Possible values are
 * 'left', 'top', 'right', 'bottom', and 'chartArea'
 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
 * @prop {Function} getPadding -  Returns an object with padding on the edges
 * @prop {Number} width - Width of item. Must be valid after update()
 * @prop {Number} height - Height of item. Must be valid after update()
 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
 */
// The layout service is very self explanatory.  It's responsible for the layout within a chart.
// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
// It is this service's responsibility of carrying out that layout.


module.exports = {
  defaults: {},

  /**
   * Register a box to a chart.
   * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
   * @param {Chart} chart - the chart to use
   * @param {ILayoutItem} item - the item to add to be layed out
   */
  addBox: function (chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    } // initialize item with default values


    item.fullWidth = item.fullWidth || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;
    chart.boxes.push(item);
  },

  /**
   * Remove a layoutItem from a chart
   * @param {Chart} chart - the chart to remove the box from
   * @param {Object} layoutItem - the item to remove from the layout
   */
  removeBox: function (chart, layoutItem) {
    var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },

  /**
   * Sets (or updates) options on the given `item`.
   * @param {Chart} chart - the chart in which the item lives (or will be added to)
   * @param {Object} item - the item to configure with the given options
   * @param {Object} options - the new item options.
   */
  configure: function (chart, item, options) {
    var props = ['fullWidth', 'position', 'weight'];
    var ilen = props.length;
    var i = 0;
    var prop;

    for (; i < ilen; ++i) {
      prop = props[i];

      if (options.hasOwnProperty(prop)) {
        item[prop] = options[prop];
      }
    }
  },

  /**
   * Fits boxes of the given chart into the given size by having each box measure itself
   * then running a fitting algorithm
   * @param {Chart} chart - the chart
   * @param {Number} width - the width to fit into
   * @param {Number} height - the height to fit into
   */
  update: function (chart, width, height) {
    if (!chart) {
      return;
    }

    var layoutOptions = chart.options.layout || {};
    var padding = helpers.options.toPadding(layoutOptions.padding);
    var leftPadding = padding.left;
    var rightPadding = padding.right;
    var topPadding = padding.top;
    var bottomPadding = padding.bottom;
    var leftBoxes = filterByPosition(chart.boxes, 'left');
    var rightBoxes = filterByPosition(chart.boxes, 'right');
    var topBoxes = filterByPosition(chart.boxes, 'top');
    var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
    var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

    sortByWeight(leftBoxes, true);
    sortByWeight(rightBoxes, false);
    sortByWeight(topBoxes, true);
    sortByWeight(bottomBoxes, false); // Essentially we now have any number of boxes on each of the 4 sides.
    // Our canvas looks like the following.
    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
    // B1 is the bottom axis
    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
    // an error will be thrown.
    //
    // |----------------------------------------------------|
    // |                  T1 (Full Width)                   |
    // |----------------------------------------------------|
    // |    |    |                 T2                  |    |
    // |    |----|-------------------------------------|----|
    // |    |    | C1 |                           | C2 |    |
    // |    |    |----|                           |----|    |
    // |    |    |                                     |    |
    // | L1 | L2 |           ChartArea (C0)            | R1 |
    // |    |    |                                     |    |
    // |    |    |----|                           |----|    |
    // |    |    | C3 |                           | C4 |    |
    // |    |----|-------------------------------------|----|
    // |    |    |                 B1                  |    |
    // |----------------------------------------------------|
    // |                  B2 (Full Width)                   |
    // |----------------------------------------------------|
    //
    // What we do to find the best sizing, we do the following
    // 1. Determine the minimum size of the chart area.
    // 2. Split the remaining width equally between each vertical axis
    // 3. Split the remaining height equally between each horizontal axis
    // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
    // 5. Adjust the sizes of each axis based on it's minimum reported size.
    // 6. Refit each axis
    // 7. Position each axis in the final location
    // 8. Tell the chart the final location of the chart area
    // 9. Tell any axes that overlay the chart area the positions of the chart area
    // Step 1

    var chartWidth = width - leftPadding - rightPadding;
    var chartHeight = height - topPadding - bottomPadding;
    var chartAreaWidth = chartWidth / 2; // min 50%

    var chartAreaHeight = chartHeight / 2; // min 50%
    // Step 2

    var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length); // Step 3

    var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length); // Step 4

    var maxChartAreaWidth = chartWidth;
    var maxChartAreaHeight = chartHeight;
    var minBoxSizes = [];

    function getMinimumBoxSize(box) {
      var minSize;
      var isHorizontal = box.isHorizontal();

      if (isHorizontal) {
        minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
        maxChartAreaHeight -= minSize.height;
      } else {
        minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
        maxChartAreaWidth -= minSize.width;
      }

      minBoxSizes.push({
        horizontal: isHorizontal,
        minSize: minSize,
        box: box
      });
    }

    helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

    var maxHorizontalLeftPadding = 0;
    var maxHorizontalRightPadding = 0;
    var maxVerticalTopPadding = 0;
    var maxVerticalBottomPadding = 0;
    helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
      if (horizontalBox.getPadding) {
        var boxPadding = horizontalBox.getPadding();
        maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
        maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
      }
    });
    helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
      if (verticalBox.getPadding) {
        var boxPadding = verticalBox.getPadding();
        maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
        maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
      }
    }); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
    // be if the axes are drawn at their minimum sizes.
    // Steps 5 & 6

    var totalLeftBoxesWidth = leftPadding;
    var totalRightBoxesWidth = rightPadding;
    var totalTopBoxesHeight = topPadding;
    var totalBottomBoxesHeight = bottomPadding; // Function to fit a box

    function fitBox(box) {
      var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
        return minBox.box === box;
      });

      if (minBoxSize) {
        if (box.isHorizontal()) {
          var scaleMargin = {
            left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
            right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
            top: 0,
            bottom: 0
          }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
          // on the margin. Sometimes they need to increase in size slightly

          box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
        } else {
          box.update(minBoxSize.minSize.width, maxChartAreaHeight);
        }
      }
    } // Update, and calculate the left and right margins for the horizontal boxes


    helpers.each(leftBoxes.concat(rightBoxes), fitBox);
    helpers.each(leftBoxes, function (box) {
      totalLeftBoxesWidth += box.width;
    });
    helpers.each(rightBoxes, function (box) {
      totalRightBoxesWidth += box.width;
    }); // Set the Left and Right margins for the horizontal boxes

    helpers.each(topBoxes.concat(bottomBoxes), fitBox); // Figure out how much margin is on the top and bottom of the vertical boxes

    helpers.each(topBoxes, function (box) {
      totalTopBoxesHeight += box.height;
    });
    helpers.each(bottomBoxes, function (box) {
      totalBottomBoxesHeight += box.height;
    });

    function finalFitVerticalBox(box) {
      var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
        return minSize.box === box;
      });
      var scaleMargin = {
        left: 0,
        right: 0,
        top: totalTopBoxesHeight,
        bottom: totalBottomBoxesHeight
      };

      if (minBoxSize) {
        box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
      }
    } // Let the left layout know the final margin


    helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

    totalLeftBoxesWidth = leftPadding;
    totalRightBoxesWidth = rightPadding;
    totalTopBoxesHeight = topPadding;
    totalBottomBoxesHeight = bottomPadding;
    helpers.each(leftBoxes, function (box) {
      totalLeftBoxesWidth += box.width;
    });
    helpers.each(rightBoxes, function (box) {
      totalRightBoxesWidth += box.width;
    });
    helpers.each(topBoxes, function (box) {
      totalTopBoxesHeight += box.height;
    });
    helpers.each(bottomBoxes, function (box) {
      totalBottomBoxesHeight += box.height;
    }); // We may be adding some padding to account for rotated x axis labels

    var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
    totalLeftBoxesWidth += leftPaddingAddition;
    totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
    var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
    totalTopBoxesHeight += topPaddingAddition;
    totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
    // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
    // without calling `fit` again

    var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
    var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

    if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
      helpers.each(leftBoxes, function (box) {
        box.height = newMaxChartAreaHeight;
      });
      helpers.each(rightBoxes, function (box) {
        box.height = newMaxChartAreaHeight;
      });
      helpers.each(topBoxes, function (box) {
        if (!box.fullWidth) {
          box.width = newMaxChartAreaWidth;
        }
      });
      helpers.each(bottomBoxes, function (box) {
        if (!box.fullWidth) {
          box.width = newMaxChartAreaWidth;
        }
      });
      maxChartAreaHeight = newMaxChartAreaHeight;
      maxChartAreaWidth = newMaxChartAreaWidth;
    } // Step 7 - Position the boxes


    var left = leftPadding + leftPaddingAddition;
    var top = topPadding + topPaddingAddition;

    function placeBox(box) {
      if (box.isHorizontal()) {
        box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
        box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
        box.top = top;
        box.bottom = top + box.height; // Move to next point

        top = box.bottom;
      } else {
        box.left = left;
        box.right = left + box.width;
        box.top = totalTopBoxesHeight;
        box.bottom = totalTopBoxesHeight + maxChartAreaHeight; // Move to next point

        left = box.right;
      }
    }

    helpers.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

    left += maxChartAreaWidth;
    top += maxChartAreaHeight;
    helpers.each(rightBoxes, placeBox);
    helpers.each(bottomBoxes, placeBox); // Step 8

    chart.chartArea = {
      left: totalLeftBoxesWidth,
      top: totalTopBoxesHeight,
      right: totalLeftBoxesWidth + maxChartAreaWidth,
      bottom: totalTopBoxesHeight + maxChartAreaHeight
    }; // Step 9

    helpers.each(chartAreaBoxes, function (box) {
      box.left = chart.chartArea.left;
      box.top = chart.chartArea.top;
      box.right = chart.chartArea.right;
      box.bottom = chart.chartArea.bottom;
      box.update(maxChartAreaWidth, maxChartAreaHeight);
    });
  }
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

var Ticks = __webpack_require__(57);

defaults._set('scale', {
  display: true,
  position: 'left',
  offset: false,
  // grid line settings
  gridLines: {
    display: true,
    color: 'rgba(0, 0, 0, 0.1)',
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickMarkLength: 10,
    zeroLineWidth: 1,
    zeroLineColor: 'rgba(0,0,0,0.25)',
    zeroLineBorderDash: [],
    zeroLineBorderDashOffset: 0.0,
    offsetGridLines: false,
    borderDash: [],
    borderDashOffset: 0.0
  },
  // scale label
  scaleLabel: {
    // display property
    display: false,
    // actual label
    labelString: '',
    // line height
    lineHeight: 1.2,
    // top/bottom padding
    padding: {
      top: 4,
      bottom: 4
    }
  },
  // label settings
  ticks: {
    beginAtZero: false,
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    padding: 0,
    reverse: false,
    display: true,
    autoSkip: true,
    autoSkipPadding: 0,
    labelOffset: 0,
    // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
    callback: Ticks.formatters.values,
    minor: {},
    major: {}
  }
});

function labelsFromTicks(ticks) {
  var labels = [];
  var i, ilen;

  for (i = 0, ilen = ticks.length; i < ilen; ++i) {
    labels.push(ticks[i].label);
  }

  return labels;
}

function getLineValue(scale, index, offsetGridLines) {
  var lineValue = scale.getPixelForTick(index);

  if (offsetGridLines) {
    if (index === 0) {
      lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
    }
  }

  return lineValue;
}

function computeTextSize(context, tick, font) {
  return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;
}

function parseFontOptions(options) {
  var valueOrDefault = helpers.valueOrDefault;
  var globalDefaults = defaults.global;
  var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
  var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
  var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
  return {
    size: size,
    style: style,
    family: family,
    font: helpers.fontString(size, style, family)
  };
}

function parseLineHeight(options) {
  return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
}

module.exports = Element.extend({
  /**
   * Get the padding needed for the scale
   * @method getPadding
   * @private
   * @returns {Padding} the necessary padding
   */
  getPadding: function () {
    var me = this;
    return {
      left: me.paddingLeft || 0,
      top: me.paddingTop || 0,
      right: me.paddingRight || 0,
      bottom: me.paddingBottom || 0
    };
  },

  /**
   * Returns the scale tick objects ({label, major})
   * @since 2.7
   */
  getTicks: function () {
    return this._ticks;
  },
  // These methods are ordered by lifecyle. Utilities then follow.
  // Any function defined here is inherited by all scale types.
  // Any function can be extended by the scale type
  mergeTicksOptions: function () {
    var ticks = this.options.ticks;

    if (ticks.minor === false) {
      ticks.minor = {
        display: false
      };
    }

    if (ticks.major === false) {
      ticks.major = {
        display: false
      };
    }

    for (var key in ticks) {
      if (key !== 'major' && key !== 'minor') {
        if (typeof ticks.minor[key] === 'undefined') {
          ticks.minor[key] = ticks[key];
        }

        if (typeof ticks.major[key] === 'undefined') {
          ticks.major[key] = ticks[key];
        }
      }
    }
  },
  beforeUpdate: function () {
    helpers.callback(this.options.beforeUpdate, [this]);
  },
  update: function (maxWidth, maxHeight, margins) {
    var me = this;
    var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

    me.beforeUpdate(); // Absorb the master measurements

    me.maxWidth = maxWidth;
    me.maxHeight = maxHeight;
    me.margins = helpers.extend({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    me.longestTextCache = me.longestTextCache || {}; // Dimensions

    me.beforeSetDimensions();
    me.setDimensions();
    me.afterSetDimensions(); // Data min/max

    me.beforeDataLimits();
    me.determineDataLimits();
    me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
    // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
    // and must not be accessed directly from outside this class. `this.ticks` being
    // around for long time and not marked as private, we can't change its structure
    // without unexpected breaking changes. If you need to access the scale ticks,
    // use scale.getTicks() instead.

    me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
    // we still support no return (`this.ticks` internally set by calling this method).

    ticks = me.buildTicks() || [];
    me.afterBuildTicks();
    me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
    // COMPAT, we still support no return (`this.ticks` internally changed by calling
    // this method and supposed to contain only string values).

    labels = me.convertTicksToLabels(ticks) || me.ticks;
    me.afterTickToLabelConversion();
    me.ticks = labels; // BACKWARD COMPATIBILITY
    // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
    // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      label = labels[i];
      tick = ticks[i];

      if (!tick) {
        ticks.push(tick = {
          label: label,
          major: false
        });
      } else {
        tick.label = label;
      }
    }

    me._ticks = ticks; // Tick Rotation

    me.beforeCalculateTickRotation();
    me.calculateTickRotation();
    me.afterCalculateTickRotation(); // Fit

    me.beforeFit();
    me.fit();
    me.afterFit(); //

    me.afterUpdate();
    return me.minSize;
  },
  afterUpdate: function () {
    helpers.callback(this.options.afterUpdate, [this]);
  },
  //
  beforeSetDimensions: function () {
    helpers.callback(this.options.beforeSetDimensions, [this]);
  },
  setDimensions: function () {
    var me = this; // Set the unconstrained dimension before label rotation

    if (me.isHorizontal()) {
      // Reset position before calculating rotation
      me.width = me.maxWidth;
      me.left = 0;
      me.right = me.width;
    } else {
      me.height = me.maxHeight; // Reset position before calculating rotation

      me.top = 0;
      me.bottom = me.height;
    } // Reset padding


    me.paddingLeft = 0;
    me.paddingTop = 0;
    me.paddingRight = 0;
    me.paddingBottom = 0;
  },
  afterSetDimensions: function () {
    helpers.callback(this.options.afterSetDimensions, [this]);
  },
  // Data limits
  beforeDataLimits: function () {
    helpers.callback(this.options.beforeDataLimits, [this]);
  },
  determineDataLimits: helpers.noop,
  afterDataLimits: function () {
    helpers.callback(this.options.afterDataLimits, [this]);
  },
  //
  beforeBuildTicks: function () {
    helpers.callback(this.options.beforeBuildTicks, [this]);
  },
  buildTicks: helpers.noop,
  afterBuildTicks: function () {
    helpers.callback(this.options.afterBuildTicks, [this]);
  },
  beforeTickToLabelConversion: function () {
    helpers.callback(this.options.beforeTickToLabelConversion, [this]);
  },
  convertTicksToLabels: function () {
    var me = this; // Convert ticks to strings

    var tickOpts = me.options.ticks;
    me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
  },
  afterTickToLabelConversion: function () {
    helpers.callback(this.options.afterTickToLabelConversion, [this]);
  },
  //
  beforeCalculateTickRotation: function () {
    helpers.callback(this.options.beforeCalculateTickRotation, [this]);
  },
  calculateTickRotation: function () {
    var me = this;
    var context = me.ctx;
    var tickOpts = me.options.ticks;
    var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
    // between x offsets between 0 and 1.

    var tickFont = parseFontOptions(tickOpts);
    context.font = tickFont.font;
    var labelRotation = tickOpts.minRotation || 0;

    if (labels.length && me.options.display && me.isHorizontal()) {
      var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
      var labelWidth = originalLabelWidth;
      var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

      var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

      while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
        var angleRadians = helpers.toRadians(labelRotation);
        cosRotation = Math.cos(angleRadians);
        sinRotation = Math.sin(angleRadians);

        if (sinRotation * originalLabelWidth > me.maxHeight) {
          // go back one step
          labelRotation--;
          break;
        }

        labelRotation++;
        labelWidth = cosRotation * originalLabelWidth;
      }
    }

    me.labelRotation = labelRotation;
  },
  afterCalculateTickRotation: function () {
    helpers.callback(this.options.afterCalculateTickRotation, [this]);
  },
  //
  beforeFit: function () {
    helpers.callback(this.options.beforeFit, [this]);
  },
  fit: function () {
    var me = this; // Reset

    var minSize = me.minSize = {
      width: 0,
      height: 0
    };
    var labels = labelsFromTicks(me._ticks);
    var opts = me.options;
    var tickOpts = opts.ticks;
    var scaleLabelOpts = opts.scaleLabel;
    var gridLineOpts = opts.gridLines;
    var display = opts.display;
    var isHorizontal = me.isHorizontal();
    var tickFont = parseFontOptions(tickOpts);
    var tickMarkLength = opts.gridLines.tickMarkLength; // Width

    if (isHorizontal) {
      // subtract the margins to line up with the chartArea if we are a full width scale
      minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
    } else {
      minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
    } // height


    if (isHorizontal) {
      minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
    } else {
      minSize.height = me.maxHeight; // fill all the height
    } // Are we showing a title for the scale?


    if (scaleLabelOpts.display && display) {
      var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
      var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
      var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

      if (isHorizontal) {
        minSize.height += deltaHeight;
      } else {
        minSize.width += deltaHeight;
      }
    } // Don't bother fitting the ticks if we are not showing them


    if (tickOpts.display && display) {
      var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
      var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
      var lineSpace = tickFont.size * 0.5;
      var tickPadding = me.options.ticks.padding;

      if (isHorizontal) {
        // A horizontal axis is more constrained by the height.
        me.longestLabelWidth = largestTextWidth;
        var angleRadians = helpers.toRadians(me.labelRotation);
        var cosRotation = Math.cos(angleRadians);
        var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

        var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding

        minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
        me.ctx.font = tickFont.font;
        var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
        var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font); // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
        // which means that the right padding is dominated by the font height

        if (me.labelRotation !== 0) {
          me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges

          me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
        } else {
          me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges

          me.paddingRight = lastLabelWidth / 2 + 3;
        }
      } else {
        // A vertical axis is more constrained by the width. Labels are the
        // dominant factor here, so get that length first and account for padding
        if (tickOpts.mirror) {
          largestTextWidth = 0;
        } else {
          // use lineSpace for consistency with horizontal axis
          // tickPadding is not implemented for horizontal
          largestTextWidth += tickPadding + lineSpace;
        }

        minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
        me.paddingTop = tickFont.size / 2;
        me.paddingBottom = tickFont.size / 2;
      }
    }

    me.handleMargins();
    me.width = minSize.width;
    me.height = minSize.height;
  },

  /**
   * Handle margins and padding interactions
   * @private
   */
  handleMargins: function () {
    var me = this;

    if (me.margins) {
      me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
      me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
      me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
      me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
    }
  },
  afterFit: function () {
    helpers.callback(this.options.afterFit, [this]);
  },
  // Shared Methods
  isHorizontal: function () {
    return this.options.position === 'top' || this.options.position === 'bottom';
  },
  isFullWidth: function () {
    return this.options.fullWidth;
  },
  // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
  getRightValue: function (rawValue) {
    // Null and undefined values first
    if (helpers.isNullOrUndef(rawValue)) {
      return NaN;
    } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


    if (typeof rawValue === 'number' && !isFinite(rawValue)) {
      return NaN;
    } // If it is in fact an object, dive in one more level


    if (rawValue) {
      if (this.isHorizontal()) {
        if (rawValue.x !== undefined) {
          return this.getRightValue(rawValue.x);
        }
      } else if (rawValue.y !== undefined) {
        return this.getRightValue(rawValue.y);
      }
    } // Value is good, return it


    return rawValue;
  },

  /**
   * Used to get the value to display in the tooltip for the data at the given index
   * @param index
   * @param datasetIndex
   */
  getLabelForIndex: helpers.noop,

  /**
   * Returns the location of the given data point. Value can either be an index or a numerical value
   * The coordinate (0, 0) is at the upper-left corner of the canvas
   * @param value
   * @param index
   * @param datasetIndex
   */
  getPixelForValue: helpers.noop,

  /**
   * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
   * The coordinate (0, 0) is at the upper-left corner of the canvas
   * @param pixel
   */
  getValueForPixel: helpers.noop,

  /**
   * Returns the location of the tick at the given index
   * The coordinate (0, 0) is at the upper-left corner of the canvas
   */
  getPixelForTick: function (index) {
    var me = this;
    var offset = me.options.offset;

    if (me.isHorizontal()) {
      var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
      var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
      var pixel = tickWidth * index + me.paddingLeft;

      if (offset) {
        pixel += tickWidth / 2;
      }

      var finalVal = me.left + Math.round(pixel);
      finalVal += me.isFullWidth() ? me.margins.left : 0;
      return finalVal;
    }

    var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
    return me.top + index * (innerHeight / (me._ticks.length - 1));
  },

  /**
   * Utility for getting the pixel location of a percentage of scale
   * The coordinate (0, 0) is at the upper-left corner of the canvas
   */
  getPixelForDecimal: function (decimal) {
    var me = this;

    if (me.isHorizontal()) {
      var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
      var valueOffset = innerWidth * decimal + me.paddingLeft;
      var finalVal = me.left + Math.round(valueOffset);
      finalVal += me.isFullWidth() ? me.margins.left : 0;
      return finalVal;
    }

    return me.top + decimal * me.height;
  },

  /**
   * Returns the pixel for the minimum chart value
   * The coordinate (0, 0) is at the upper-left corner of the canvas
   */
  getBasePixel: function () {
    return this.getPixelForValue(this.getBaseValue());
  },
  getBaseValue: function () {
    var me = this;
    var min = me.min;
    var max = me.max;
    return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  },

  /**
   * Returns a subset of ticks to be plotted to avoid overlapping labels.
   * @private
   */
  _autoSkip: function (ticks) {
    var skipRatio;
    var me = this;
    var isHorizontal = me.isHorizontal();
    var optionTicks = me.options.ticks.minor;
    var tickCount = ticks.length;
    var labelRotationRadians = helpers.toRadians(me.labelRotation);
    var cosRotation = Math.cos(labelRotationRadians);
    var longestRotatedLabel = me.longestLabelWidth * cosRotation;
    var result = [];
    var i, tick, shouldSkip; // figure out the maximum number of gridlines to show

    var maxTicks;

    if (optionTicks.maxTicksLimit) {
      maxTicks = optionTicks.maxTicksLimit;
    }

    if (isHorizontal) {
      skipRatio = false;

      if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {
        skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));
      } // if they defined a max number of optionTicks,
      // increase skipRatio until that number is met


      if (maxTicks && tickCount > maxTicks) {
        skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
      }
    }

    for (i = 0; i < tickCount; i++) {
      tick = ticks[i]; // Since we always show the last tick,we need may need to hide the last shown one before

      shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;

      if (shouldSkip && i !== tickCount - 1) {
        // leave tick in place but make sure it's not displayed (#4635)
        delete tick.label;
      }

      result.push(tick);
    }

    return result;
  },
  // Actually draw the scale on the canvas
  // @param {rectangle} chartArea : the area of the chart to draw full grid lines on
  draw: function (chartArea) {
    var me = this;
    var options = me.options;

    if (!options.display) {
      return;
    }

    var context = me.ctx;
    var globalDefaults = defaults.global;
    var optionTicks = options.ticks.minor;
    var optionMajorTicks = options.ticks.major || optionTicks;
    var gridLines = options.gridLines;
    var scaleLabel = options.scaleLabel;
    var isRotated = me.labelRotation !== 0;
    var isHorizontal = me.isHorizontal();
    var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
    var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
    var tickFont = parseFontOptions(optionTicks);
    var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
    var majorTickFont = parseFontOptions(optionMajorTicks);
    var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
    var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
    var scaleLabelFont = parseFontOptions(scaleLabel);
    var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
    var labelRotationRadians = helpers.toRadians(me.labelRotation);
    var itemsToDraw = [];
    var axisWidth = me.options.gridLines.lineWidth;
    var xTickStart = options.position === 'right' ? me.left : me.right - axisWidth - tl;
    var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
    var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;
    var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;
    helpers.each(ticks, function (tick, index) {
      // autoskipper skipped this tick (#4635)
      if (helpers.isNullOrUndef(tick.label)) {
        return;
      }

      var label = tick.label;
      var lineWidth, lineColor, borderDash, borderDashOffset;

      if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
        // Draw the first index specially
        lineWidth = gridLines.zeroLineWidth;
        lineColor = gridLines.zeroLineColor;
        borderDash = gridLines.zeroLineBorderDash;
        borderDashOffset = gridLines.zeroLineBorderDashOffset;
      } else {
        lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
        lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
        borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
        borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
      } // Common properties


      var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
      var textAlign = 'middle';
      var textBaseline = 'middle';
      var tickPadding = optionTicks.padding;

      if (isHorizontal) {
        var labelYOffset = tl + tickPadding;

        if (options.position === 'bottom') {
          // bottom
          textBaseline = !isRotated ? 'top' : 'middle';
          textAlign = !isRotated ? 'center' : 'right';
          labelY = me.top + labelYOffset;
        } else {
          // top
          textBaseline = !isRotated ? 'bottom' : 'middle';
          textAlign = !isRotated ? 'center' : 'left';
          labelY = me.bottom - labelYOffset;
        }

        var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);

        if (xLineValue < me.left) {
          lineColor = 'rgba(0,0,0,0)';
        }

        xLineValue += helpers.aliasPixel(lineWidth);
        labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

        tx1 = tx2 = x1 = x2 = xLineValue;
        ty1 = yTickStart;
        ty2 = yTickEnd;
        y1 = chartArea.top;
        y2 = chartArea.bottom + axisWidth;
      } else {
        var isLeft = options.position === 'left';
        var labelXOffset;

        if (optionTicks.mirror) {
          textAlign = isLeft ? 'left' : 'right';
          labelXOffset = tickPadding;
        } else {
          textAlign = isLeft ? 'right' : 'left';
          labelXOffset = tl + tickPadding;
        }

        labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
        var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);

        if (yLineValue < me.top) {
          lineColor = 'rgba(0,0,0,0)';
        }

        yLineValue += helpers.aliasPixel(lineWidth);
        labelY = me.getPixelForTick(index) + optionTicks.labelOffset;
        tx1 = xTickStart;
        tx2 = xTickEnd;
        x1 = chartArea.left;
        x2 = chartArea.right + axisWidth;
        ty1 = ty2 = y1 = y2 = yLineValue;
      }

      itemsToDraw.push({
        tx1: tx1,
        ty1: ty1,
        tx2: tx2,
        ty2: ty2,
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        labelX: labelX,
        labelY: labelY,
        glWidth: lineWidth,
        glColor: lineColor,
        glBorderDash: borderDash,
        glBorderDashOffset: borderDashOffset,
        rotation: -1 * labelRotationRadians,
        label: label,
        major: tick.major,
        textBaseline: textBaseline,
        textAlign: textAlign
      });
    }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

    helpers.each(itemsToDraw, function (itemToDraw) {
      if (gridLines.display) {
        context.save();
        context.lineWidth = itemToDraw.glWidth;
        context.strokeStyle = itemToDraw.glColor;

        if (context.setLineDash) {
          context.setLineDash(itemToDraw.glBorderDash);
          context.lineDashOffset = itemToDraw.glBorderDashOffset;
        }

        context.beginPath();

        if (gridLines.drawTicks) {
          context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
          context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
        }

        if (gridLines.drawOnChartArea) {
          context.moveTo(itemToDraw.x1, itemToDraw.y1);
          context.lineTo(itemToDraw.x2, itemToDraw.y2);
        }

        context.stroke();
        context.restore();
      }

      if (optionTicks.display) {
        // Make sure we draw text in the correct color and font
        context.save();
        context.translate(itemToDraw.labelX, itemToDraw.labelY);
        context.rotate(itemToDraw.rotation);
        context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
        context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
        context.textBaseline = itemToDraw.textBaseline;
        context.textAlign = itemToDraw.textAlign;
        var label = itemToDraw.label;

        if (helpers.isArray(label)) {
          var lineCount = label.length;
          var lineHeight = tickFont.size * 1.5;
          var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;

          for (var i = 0; i < lineCount; ++i) {
            // We just make sure the multiline element is a string here..
            context.fillText('' + label[i], 0, y); // apply same lineSpacing as calculated @ L#320

            y += lineHeight;
          }
        } else {
          context.fillText(label, 0, 0);
        }

        context.restore();
      }
    });

    if (scaleLabel.display) {
      // Draw the scale label
      var scaleLabelX;
      var scaleLabelY;
      var rotation = 0;
      var halfLineHeight = parseLineHeight(scaleLabel) / 2;

      if (isHorizontal) {
        scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

        scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
      } else {
        var isLeft = options.position === 'left';
        scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
        scaleLabelY = me.top + (me.bottom - me.top) / 2;
        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
      }

      context.save();
      context.translate(scaleLabelX, scaleLabelY);
      context.rotate(rotation);
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillStyle = scaleLabelFontColor; // render in correct colour

      context.font = scaleLabelFont.font;
      context.fillText(scaleLabel.labelString, 0, 0);
      context.restore();
    }

    if (gridLines.drawBorder) {
      // Draw the line at the edge of the axis
      context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
      context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
      var x1 = me.left;
      var x2 = me.right + axisWidth;
      var y1 = me.top;
      var y2 = me.bottom + axisWidth;
      var aliasPixel = helpers.aliasPixel(context.lineWidth);

      if (isHorizontal) {
        y1 = y2 = options.position === 'top' ? me.bottom : me.top;
        y1 += aliasPixel;
        y2 += aliasPixel;
      } else {
        x1 = x2 = options.position === 'left' ? me.right : me.left;
        x1 += aliasPixel;
        x2 += aliasPixel;
      }

      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      context.stroke();
    }
  }
});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);
/**
 * Namespace to hold static tick generation functions
 * @namespace Chart.Ticks
 */


module.exports = {
  /**
   * Namespace to hold formatters for different types of ticks
   * @namespace Chart.Ticks.formatters
   */
  formatters: {
    /**
     * Formatter for value labels
     * @method Chart.Ticks.formatters.values
     * @param value the value to display
     * @return {String|Array} the label to display
     */
    values: function (value) {
      return helpers.isArray(value) ? value : '' + value;
    },

    /**
     * Formatter for linear numeric ticks
     * @method Chart.Ticks.formatters.linear
     * @param tickValue {Number} the value to be formatted
     * @param index {Number} the position of the tickValue parameter in the ticks array
     * @param ticks {Array<Number>} the list of ticks being converted
     * @return {String} string representation of the tickValue parameter
     */
    linear: function (tickValue, index, ticks) {
      // If we have lots of ticks, don't use the ones
      var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

      if (Math.abs(delta) > 1) {
        if (tickValue !== Math.floor(tickValue)) {
          // not an integer
          delta = tickValue - Math.floor(tickValue);
        }
      }

      var logDelta = helpers.log10(Math.abs(delta));
      var tickString = '';

      if (tickValue !== 0) {
        var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

        if (maxTick < 1e-4) {
          // all ticks are small numbers; use scientific notation
          var logTick = helpers.log10(Math.abs(tickValue));
          tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
        } else {
          var numDecimal = -1 * Math.floor(logDelta);
          numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

          tickString = tickValue.toFixed(numDecimal);
        }
      } else {
        tickString = '0'; // never show decimal places for 0
      }

      return tickString;
    },
    logarithmic: function (tickValue, index, ticks) {
      var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));

      if (tickValue === 0) {
        return '0';
      } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
        return tickValue.toExponential();
      }

      return '';
    }
  }
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(19);

var toLength = __webpack_require__(10);

var toAbsoluteIndex = __webpack_require__(40);

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 59 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var defined = __webpack_require__(29);

var fails = __webpack_require__(3);

var spaces = __webpack_require__(79);

var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(9)('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(4);

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(53);

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(119);

var redefine = __webpack_require__(14);

var hide = __webpack_require__(18);

var fails = __webpack_require__(3);

var defined = __webpack_require__(29);

var wks = __webpack_require__(9);

var regexpExec = __webpack_require__(94);

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(26);

var call = __webpack_require__(115);

var isArrayIter = __webpack_require__(89);

var anObject = __webpack_require__(4);

var toLength = __webpack_require__(10);

var getIterFn = __webpack_require__(91);

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);

var $export = __webpack_require__(1);

var redefine = __webpack_require__(14);

var redefineAll = __webpack_require__(49);

var meta = __webpack_require__(32);

var forOf = __webpack_require__(65);

var anInstance = __webpack_require__(48);

var isObject = __webpack_require__(6);

var fails = __webpack_require__(3);

var $iterDetect = __webpack_require__(61);

var setToStringTag = __webpack_require__(44);

var inheritIfRequired = __webpack_require__(80);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var hide = __webpack_require__(18);

var uid = __webpack_require__(37);

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @namespace Chart.helpers
 */

var helpers = {
  /**
   * An empty function that can be used, for example, for optional callback.
   */
  noop: function () {},

  /**
   * Returns a unique id, sequentially generated from a global variable.
   * @returns {Number}
   * @function
   */
  uid: function () {
    var id = 0;
    return function () {
      return id++;
    };
  }(),

  /**
   * Returns true if `value` is neither null nor undefined, else returns false.
   * @param {*} value - The value to test.
   * @returns {Boolean}
   * @since 2.7.0
   */
  isNullOrUndef: function (value) {
    return value === null || typeof value === 'undefined';
  },

  /**
   * Returns true if `value` is an array, else returns false.
   * @param {*} value - The value to test.
   * @returns {Boolean}
   * @function
   */
  isArray: Array.isArray ? Array.isArray : function (value) {
    return Object.prototype.toString.call(value) === '[object Array]';
  },

  /**
   * Returns true if `value` is an object (excluding null), else returns false.
   * @param {*} value - The value to test.
   * @returns {Boolean}
   * @since 2.7.0
   */
  isObject: function (value) {
    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
  },

  /**
   * Returns `value` if defined, else returns `defaultValue`.
   * @param {*} value - The value to return if defined.
   * @param {*} defaultValue - The value to return if `value` is undefined.
   * @returns {*}
   */
  valueOrDefault: function (value, defaultValue) {
    return typeof value === 'undefined' ? defaultValue : value;
  },

  /**
   * Returns value at the given `index` in array if defined, else returns `defaultValue`.
   * @param {Array} value - The array to lookup for value at `index`.
   * @param {Number} index - The index in `value` to lookup for value.
   * @param {*} defaultValue - The value to return if `value[index]` is undefined.
   * @returns {*}
   */
  valueAtIndexOrDefault: function (value, index, defaultValue) {
    return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
  },

  /**
   * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
   * value returned by `fn`. If `fn` is not a function, this method returns undefined.
   * @param {Function} fn - The function to call.
   * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
   * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
   * @returns {*}
   */
  callback: function (fn, args, thisArg) {
    if (fn && typeof fn.call === 'function') {
      return fn.apply(thisArg, args);
    }
  },

  /**
   * Note(SB) for performance sake, this method should only be used when loopable type
   * is unknown or in none intensive code (not called often and small loopable). Else
   * it's preferable to use a regular for() loop and save extra function calls.
   * @param {Object|Array} loopable - The object or array to be iterated.
   * @param {Function} fn - The function to call for each item.
   * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
   * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
   */
  each: function (loopable, fn, thisArg, reverse) {
    var i, len, keys;

    if (helpers.isArray(loopable)) {
      len = loopable.length;

      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[i], i);
        }
      }
    } else if (helpers.isObject(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;

      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[keys[i]], keys[i]);
      }
    }
  },

  /**
   * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
   * @see http://stackoverflow.com/a/14853974
   * @param {Array} a0 - The array to compare
   * @param {Array} a1 - The array to compare
   * @returns {Boolean}
   */
  arrayEquals: function (a0, a1) {
    var i, ilen, v0, v1;

    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }

    for (i = 0, ilen = a0.length; i < ilen; ++i) {
      v0 = a0[i];
      v1 = a1[i];

      if (v0 instanceof Array && v1 instanceof Array) {
        if (!helpers.arrayEquals(v0, v1)) {
          return false;
        }
      } else if (v0 !== v1) {
        // NOTE: two different object instances will never be equal: {x:20} != {x:20}
        return false;
      }
    }

    return true;
  },

  /**
   * Returns a deep copy of `source` without keeping references on objects and arrays.
   * @param {*} source - The value to clone.
   * @returns {*}
   */
  clone: function (source) {
    if (helpers.isArray(source)) {
      return source.map(helpers.clone);
    }

    if (helpers.isObject(source)) {
      var target = {};
      var keys = Object.keys(source);
      var klen = keys.length;
      var k = 0;

      for (; k < klen; ++k) {
        target[keys[k]] = helpers.clone(source[keys[k]]);
      }

      return target;
    }

    return source;
  },

  /**
   * The default merger when Chart.helpers.merge is called without merger option.
   * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
   * @private
   */
  _merger: function (key, target, source, options) {
    var tval = target[key];
    var sval = source[key];

    if (helpers.isObject(tval) && helpers.isObject(sval)) {
      helpers.merge(tval, sval, options);
    } else {
      target[key] = helpers.clone(sval);
    }
  },

  /**
   * Merges source[key] in target[key] only if target[key] is undefined.
   * @private
   */
  _mergerIf: function (key, target, source) {
    var tval = target[key];
    var sval = source[key];

    if (helpers.isObject(tval) && helpers.isObject(sval)) {
      helpers.mergeIf(tval, sval);
    } else if (!target.hasOwnProperty(key)) {
      target[key] = helpers.clone(sval);
    }
  },

  /**
   * Recursively deep copies `source` properties into `target` with the given `options`.
   * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
   * @param {Object} target - The target object in which all sources are merged into.
   * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
   * @param {Object} [options] - Merging options:
   * @param {Function} [options.merger] - The merge method (key, target, source, options)
   * @returns {Object} The `target` object.
   */
  merge: function (target, source, options) {
    var sources = helpers.isArray(source) ? source : [source];
    var ilen = sources.length;
    var merge, i, keys, klen, k;

    if (!helpers.isObject(target)) {
      return target;
    }

    options = options || {};
    merge = options.merger || helpers._merger;

    for (i = 0; i < ilen; ++i) {
      source = sources[i];

      if (!helpers.isObject(source)) {
        continue;
      }

      keys = Object.keys(source);

      for (k = 0, klen = keys.length; k < klen; ++k) {
        merge(keys[k], target, source, options);
      }
    }

    return target;
  },

  /**
   * Recursively deep copies `source` properties into `target` *only* if not defined in target.
   * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
   * @param {Object} target - The target object in which all sources are merged into.
   * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
   * @returns {Object} The `target` object.
   */
  mergeIf: function (target, source) {
    return helpers.merge(target, source, {
      merger: helpers._mergerIf
    });
  },

  /**
   * Applies the contents of two or more objects together into the first object.
   * @param {Object} target - The target object in which all objects are merged into.
   * @param {Object} arg1 - Object containing additional properties to merge in target.
   * @param {Object} argN - Additional objects containing properties to merge in target.
   * @returns {Object} The `target` object.
   */
  extend: function (target) {
    var setFn = function (value, key) {
      target[key] = value;
    };

    for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
      helpers.each(arguments[i], setFn);
    }

    return target;
  },

  /**
   * Basic javascript inheritance based on the model created in Backbone.js
   */
  inherits: function (extensions) {
    var me = this;
    var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
      return me.apply(this, arguments);
    };

    var Surrogate = function () {
      this.constructor = ChartElement;
    };

    Surrogate.prototype = me.prototype;
    ChartElement.prototype = new Surrogate();
    ChartElement.extend = helpers.inherits;

    if (extensions) {
      helpers.extend(ChartElement.prototype, extensions);
    }

    ChartElement.__super__ = me.prototype;
    return ChartElement;
  }
};
module.exports = helpers; // DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.callback instead.
 * @function Chart.helpers.callCallback
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */

helpers.callCallback = helpers.callback;
/**
 * Provided for backward compatibility, use Array.prototype.indexOf instead.
 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
 * @function Chart.helpers.indexOf
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.indexOf = function (array, item, fromIndex) {
  return Array.prototype.indexOf.call(array, item, fromIndex);
};
/**
 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
 * @function Chart.helpers.getValueOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */


helpers.getValueOrDefault = helpers.valueOrDefault;
/**
 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
 * @function Chart.helpers.getValueAtIndexOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6);

var document = __webpack_require__(5).document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(13);

var global = __webpack_require__(5);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(38) ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(9);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(72)('keys');

var uid = __webpack_require__(37);

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 75 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(28);

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(5).document;

module.exports = document && document.documentElement;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(6);

var anObject = __webpack_require__(4);

var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(26)(Function.call, __webpack_require__(22).f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6);

var setPrototypeOf = __webpack_require__(78).set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(21);

var defined = __webpack_require__(29);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;

  return res;
};

/***/ }),
/* 82 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 83 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(21);

var defined = __webpack_require__(29); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(38);

var $export = __webpack_require__(1);

var redefine = __webpack_require__(14);

var hide = __webpack_require__(18);

var Iterators = __webpack_require__(45);

var $iterCreate = __webpack_require__(114);

var setToStringTag = __webpack_require__(44);

var getPrototypeOf = __webpack_require__(43);

var ITERATOR = __webpack_require__(9)('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(87);

var defined = __webpack_require__(29);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(6);

var cof = __webpack_require__(28);

var MATCH = __webpack_require__(9)('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(9)('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(45);

var ITERATOR = __webpack_require__(9)('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(11);

var createDesc = __webpack_require__(36);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(53);

var ITERATOR = __webpack_require__(9)('iterator');

var Iterators = __webpack_require__(45);

module.exports = __webpack_require__(13).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(15);

var toAbsoluteIndex = __webpack_require__(40);

var toLength = __webpack_require__(10);

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(46);

var step = __webpack_require__(118);

var Iterators = __webpack_require__(45);

var toIObject = __webpack_require__(19); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(85)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(62);

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(84)(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(26);

var invoke = __webpack_require__(108);

var html = __webpack_require__(77);

var cel = __webpack_require__(71);

var global = __webpack_require__(5);

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(28)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);

var DESCRIPTORS = __webpack_require__(12);

var LIBRARY = __webpack_require__(38);

var $typed = __webpack_require__(68);

var hide = __webpack_require__(18);

var redefineAll = __webpack_require__(49);

var fails = __webpack_require__(3);

var anInstance = __webpack_require__(48);

var toInteger = __webpack_require__(21);

var toLength = __webpack_require__(10);

var toIndex = __webpack_require__(126);

var gOPN = __webpack_require__(42).f;

var dP = __webpack_require__(11).f;

var arrayFill = __webpack_require__(92);

var setToStringTag = __webpack_require__(44);

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function () {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SlideToggler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var SlideToggler =
/*#__PURE__*/
function () {
  function SlideToggler(selector) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SlideToggler);

    this.selector = selector;
    this.height = null;
    this.brokenImages = null;
    this.brokenImagesHeight = 0;
    this.duration = null;
    this.togglerState = null;
    this.options = {
      display: window.getComputedStyle(this.selector).display,
      duration: null,
      isWrapContent: false,
      toggleClassName: '-is-open',
      class: {
        wrapPrefix: '__slide-wrap'
      }
    };

    if (!(this.selector instanceof HTMLElement)) {
      return;
    }

    if (options instanceof Object) {
      this.options = __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](this.options, options);
    }

    this.init();
  }

  _createClass(SlideToggler, [{
    key: "init",
    value: function init() {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["b" /* callIfTrue */](this.options.isWrapContent, this.wrapContent.bind(this));
      this.updateValues(); // Get initial values

      this.togglerState = !!this.getHeight(); // if (this.togglerState) {
      //     helpers.addClass(this.selector, this.options.toggleClassName);
      // }

      window.addEventListener('resize', __WEBPACK_IMPORTED_MODULE_0__helpers__["d" /* debounce */](this.updateValues.bind(this), 250)); // Update current values after window was resized
    }
  }, {
    key: "updateValues",
    value: function updateValues() {
      this.height = this.getHeight();
      this.duration = this.options.duration || Math.floor(this.height / 3) + 300;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      var clone = this.selector.cloneNode(true);
      clone.style.cssText = 'visibility: hidden; display: block; margin: -999px 0';
      var height = this.selector.parentNode.appendChild(clone).clientHeight;
      this.selector.parentNode.removeChild(clone);
      return height;
    }
  }, {
    key: "getDirection",
    value: function getDirection() {
      var currHeight = this.selector.clientHeight * (window.getComputedStyle(this.selector).display !== 'none'); // Return height but if is hidden return 0

      if (currHeight > this.height / 2) {
        return [this.height, 0];
      }

      return [0, this.height];
    }
  }, {
    key: "wrapContent",
    value: function wrapContent() {
      var wrapClass = this.selector.classList[0].split('__')[0]; // Get first class in list and remove modifier if exists

      this.selector.innerHTML = "<div".concat(wrapClass ? " class=\"".concat(wrapClass + this.options.class.wrapPrefix, "\"") : '', ">").concat(this.selector.innerHTML, "</div>");
    }
  }, {
    key: "open",
    value: function open() {
      if (this.getDirection()[0] === 0) {
        this.toggle();
      } else {
        console.log('Already opened!');
      }
    }
  }, {
    key: "close",
    value: function close() {
      if (this.getDirection()[0] !== 0) {
        this.toggle();
      } else {
        console.log('Already closed!');
      }
    }
  }, {
    key: "toggle",
    value: function toggle() {
      var _this = this;

      var _this$getDirection = this.getDirection(),
          _this$getDirection2 = _slicedToArray(_this$getDirection, 2),
          start = _this$getDirection2[0],
          end = _this$getDirection2[1];

      var disp = end - start;
      var display = this.options.display && this.options.display !== 'none' ? this.options.display : 'block';
      var init = performance.now(); // this.selector.classList[end === 0 ? 'remove' : 'add'](this.options.toggleClassName); // add optional class
      // helpers[end === 0 ? 'removeClass' : 'addClass'](this.selector, this.options.toggleClassName);

      this.togglerState = end === 0;
      this.selector.style.cssText = "overflow: hidden; display: ".concat(display, ";");

      var repeat = function repeat(time) {
        var timePassed = time - init;
        var step = start + disp * timePassed / _this.duration;

        if (timePassed > _this.duration) {
          timePassed = _this.duration;
        } // Animate height


        _this.selector.style.height = "".concat(step, "px");

        if (timePassed < _this.duration) {
          requestAnimationFrame(repeat);
        } else {
          _this.selector.style.cssText = "display: ".concat(end === 0 ? 'none' : display);
        }
      };

      return repeat(init);
    }
  }, {
    key: "state",
    get: function get() {
      return this.togglerState;
    }
  }]);

  return SlideToggler;
}();



/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(12) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(71)('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var core = __webpack_require__(13);

var LIBRARY = __webpack_require__(38);

var wksExt = __webpack_require__(73);

var defineProperty = __webpack_require__(11).f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(17);

var toIObject = __webpack_require__(19);

var arrayIndexOf = __webpack_require__(58)(false);

var IE_PROTO = __webpack_require__(74)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(11);

var anObject = __webpack_require__(4);

var getKeys = __webpack_require__(39);

module.exports = __webpack_require__(12) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) dP.f(O, P = keys[i++], Properties[P]);

  return O;
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(19);

var gOPN = __webpack_require__(42).f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var getKeys = __webpack_require__(39);

var gOPS = __webpack_require__(59);

var pIE = __webpack_require__(52);

var toObject = __webpack_require__(15);

var IObject = __webpack_require__(51);

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  }

  return T;
} : $assign;

/***/ }),
/* 106 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(27);

var isObject = __webpack_require__(6);

var invoke = __webpack_require__(108);

var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function ()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),
/* 108 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(5).parseInt;

var $trim = __webpack_require__(60).trim;

var ws = __webpack_require__(79);

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(5).parseFloat;

var $trim = __webpack_require__(60).trim;

module.exports = 1 / $parseFloat(__webpack_require__(79) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(28);

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(6);

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 113 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(41);

var descriptor = __webpack_require__(36);

var setToStringTag = __webpack_require__(44);

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(18)(IteratorPrototype, __webpack_require__(9)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(4);

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(27);

var toObject = __webpack_require__(15);

var IObject = __webpack_require__(51);

var toLength = __webpack_require__(10);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }

  return memo;
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(15);

var toAbsoluteIndex = __webpack_require__(40);

var toLength = __webpack_require__(10);

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(94);

__webpack_require__(1)({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(12) && /./g.flags != 'g') __webpack_require__(11).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(62)
});

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(38);

var global = __webpack_require__(5);

var ctx = __webpack_require__(26);

var classof = __webpack_require__(53);

var $export = __webpack_require__(1);

var isObject = __webpack_require__(6);

var aFunction = __webpack_require__(27);

var anInstance = __webpack_require__(48);

var forOf = __webpack_require__(65);

var speciesConstructor = __webpack_require__(54);

var task = __webpack_require__(96).set;

var microtask = __webpack_require__(380)();

var newPromiseCapabilityModule = __webpack_require__(122);

var perform = __webpack_require__(381);

var userAgent = __webpack_require__(66);

var promiseResolve = __webpack_require__(123);

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function () {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(9)('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(49)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(44)($Promise, PROMISE);

__webpack_require__(47)(PROMISE);

Wrapper = __webpack_require__(13)[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(61)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(27);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);

var isObject = __webpack_require__(6);

var newPromiseCapability = __webpack_require__(122);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(11).f;

var create = __webpack_require__(41);

var redefineAll = __webpack_require__(49);

var ctx = __webpack_require__(26);

var anInstance = __webpack_require__(48);

var forOf = __webpack_require__(65);

var $iterDefine = __webpack_require__(85);

var step = __webpack_require__(118);

var setSpecies = __webpack_require__(47);

var DESCRIPTORS = __webpack_require__(12);

var fastKey = __webpack_require__(32).fastKey;

var validate = __webpack_require__(50);

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) entry = entry.p; // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(49);

var getWeak = __webpack_require__(32).getWeak;

var anObject = __webpack_require__(4);

var isObject = __webpack_require__(6);

var anInstance = __webpack_require__(48);

var forOf = __webpack_require__(65);

var createArrayMethod = __webpack_require__(24);

var $has = __webpack_require__(17);

var validate = __webpack_require__(50);

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.a = [];
};

var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(21);

var toLength = __webpack_require__(10);

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(42);

var gOPS = __webpack_require__(59);

var anObject = __webpack_require__(4);

var Reflect = __webpack_require__(5).Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(10);

var repeat = __webpack_require__(81);

var defined = __webpack_require__(29);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(39);

var toIObject = __webpack_require__(19);

var isEnum = __webpack_require__(52).f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    }

    return result;
  };
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */
(function (global, factory) {
   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ES6Promise = factory();
})(this, function () {
  'use strict';

  function objectOrFunction(x) {
    var type = typeof x;
    return x !== null && (type === 'object' || type === 'function');
  }

  function isFunction(x) {
    return typeof x === 'function';
  }

  var _isArray = void 0;

  if (Array.isArray) {
    _isArray = Array.isArray;
  } else {
    _isArray = function (x) {
      return Object.prototype.toString.call(x) === '[object Array]';
    };
  }

  var isArray = _isArray;
  var len = 0;
  var vertxNext = void 0;
  var customSchedulerFn = void 0;

  var asap = function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;

    if (len === 2) {
      // If len is 2, that means that we need to schedule an async flush.
      // If additional callbacks are queued before the queue is flushed, they
      // will be processed by this flush that we are scheduling.
      if (customSchedulerFn) {
        customSchedulerFn(flush);
      } else {
        scheduleFlush();
      }
    }
  };

  function setScheduler(scheduleFn) {
    customSchedulerFn = scheduleFn;
  }

  function setAsap(asapFn) {
    asap = asapFn;
  }

  var browserWindow = typeof window !== 'undefined' ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10

  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node

  function useNextTick() {
    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
    // see https://github.com/cujojs/when/issues/410 for details
    return function () {
      return process.nextTick(flush);
    };
  } // vertx


  function useVertxTimer() {
    if (typeof vertxNext !== 'undefined') {
      return function () {
        vertxNext(flush);
      };
    }

    return useSetTimeout();
  }

  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {
      characterData: true
    });
    return function () {
      node.data = iterations = ++iterations % 2;
    };
  } // web worker


  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function () {
      return channel.port2.postMessage(0);
    };
  }

  function useSetTimeout() {
    // Store setTimeout reference so es6-promise will be unaffected by
    // other code modifying setTimeout (like sinon.useFakeTimers())
    var globalSetTimeout = setTimeout;
    return function () {
      return globalSetTimeout(flush, 1);
    };
  }

  var queue = new Array(1000);

  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }

    len = 0;
  }

  function attemptVertx() {
    try {
      var vertx = Function('return this')().require('vertx');

      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }

  var scheduleFlush = void 0; // Decide what async method to use to triggering processing of queued callbacks:

  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && "function" === 'function') {
    scheduleFlush = attemptVertx();
  } else {
    scheduleFlush = useSetTimeout();
  }

  function then(onFulfillment, onRejection) {
    var parent = this;
    var child = new this.constructor(noop);

    if (child[PROMISE_ID] === undefined) {
      makePromise(child);
    }

    var _state = parent._state;

    if (_state) {
      var callback = arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    } else {
      subscribe(parent, child, onFulfillment, onRejection);
    }

    return child;
  }
  /**
    `Promise.resolve` returns a promise that will become resolved with the
    passed `value`. It is shorthand for the following:
  
    ```javascript
    let promise = new Promise(function(resolve, reject){
      resolve(1);
    });
  
    promise.then(function(value){
      // value === 1
    });
    ```
  
    Instead of writing the above, your code now simply becomes the following:
  
    ```javascript
    let promise = Promise.resolve(1);
  
    promise.then(function(value){
      // value === 1
    });
    ```
  
    @method resolve
    @static
    @param {Any} value value that the returned promise will be resolved with
    Useful for tooling.
    @return {Promise} a promise that will become fulfilled with the given
    `value`
  */


  function resolve$1(object) {
    /*jshint validthis:true */
    var Constructor = this;

    if (object && typeof object === 'object' && object.constructor === Constructor) {
      return object;
    }

    var promise = new Constructor(noop);
    resolve(promise, object);
    return promise;
  }

  var PROMISE_ID = Math.random().toString(36).substring(2);

  function noop() {}

  var PENDING = void 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var TRY_CATCH_ERROR = {
    error: null
  };

  function selfFulfillment() {
    return new TypeError("You cannot resolve a promise with itself");
  }

  function cannotReturnOwn() {
    return new TypeError('A promises callback cannot return that same promise.');
  }

  function getThen(promise) {
    try {
      return promise.then;
    } catch (error) {
      TRY_CATCH_ERROR.error = error;
      return TRY_CATCH_ERROR;
    }
  }

  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
    try {
      then$$1.call(value, fulfillmentHandler, rejectionHandler);
    } catch (e) {
      return e;
    }
  }

  function handleForeignThenable(promise, thenable, then$$1) {
    asap(function (promise) {
      var sealed = false;
      var error = tryThen(then$$1, thenable, function (value) {
        if (sealed) {
          return;
        }

        sealed = true;

        if (thenable !== value) {
          resolve(promise, value);
        } else {
          fulfill(promise, value);
        }
      }, function (reason) {
        if (sealed) {
          return;
        }

        sealed = true;
        reject(promise, reason);
      }, 'Settle: ' + (promise._label || ' unknown promise'));

      if (!sealed && error) {
        sealed = true;
        reject(promise, error);
      }
    }, promise);
  }

  function handleOwnThenable(promise, thenable) {
    if (thenable._state === FULFILLED) {
      fulfill(promise, thenable._result);
    } else if (thenable._state === REJECTED) {
      reject(promise, thenable._result);
    } else {
      subscribe(thenable, undefined, function (value) {
        return resolve(promise, value);
      }, function (reason) {
        return reject(promise, reason);
      });
    }
  }

  function handleMaybeThenable(promise, maybeThenable, then$$1) {
    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
      handleOwnThenable(promise, maybeThenable);
    } else {
      if (then$$1 === TRY_CATCH_ERROR) {
        reject(promise, TRY_CATCH_ERROR.error);
        TRY_CATCH_ERROR.error = null;
      } else if (then$$1 === undefined) {
        fulfill(promise, maybeThenable);
      } else if (isFunction(then$$1)) {
        handleForeignThenable(promise, maybeThenable, then$$1);
      } else {
        fulfill(promise, maybeThenable);
      }
    }
  }

  function resolve(promise, value) {
    if (promise === value) {
      reject(promise, selfFulfillment());
    } else if (objectOrFunction(value)) {
      handleMaybeThenable(promise, value, getThen(value));
    } else {
      fulfill(promise, value);
    }
  }

  function publishRejection(promise) {
    if (promise._onerror) {
      promise._onerror(promise._result);
    }

    publish(promise);
  }

  function fulfill(promise, value) {
    if (promise._state !== PENDING) {
      return;
    }

    promise._result = value;
    promise._state = FULFILLED;

    if (promise._subscribers.length !== 0) {
      asap(publish, promise);
    }
  }

  function reject(promise, reason) {
    if (promise._state !== PENDING) {
      return;
    }

    promise._state = REJECTED;
    promise._result = reason;
    asap(publishRejection, promise);
  }

  function subscribe(parent, child, onFulfillment, onRejection) {
    var _subscribers = parent._subscribers;
    var length = _subscribers.length;
    parent._onerror = null;
    _subscribers[length] = child;
    _subscribers[length + FULFILLED] = onFulfillment;
    _subscribers[length + REJECTED] = onRejection;

    if (length === 0 && parent._state) {
      asap(publish, parent);
    }
  }

  function publish(promise) {
    var subscribers = promise._subscribers;
    var settled = promise._state;

    if (subscribers.length === 0) {
      return;
    }

    var child = void 0,
        callback = void 0,
        detail = promise._result;

    for (var i = 0; i < subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];

      if (child) {
        invokeCallback(settled, child, callback, detail);
      } else {
        callback(detail);
      }
    }

    promise._subscribers.length = 0;
  }

  function tryCatch(callback, detail) {
    try {
      return callback(detail);
    } catch (e) {
      TRY_CATCH_ERROR.error = e;
      return TRY_CATCH_ERROR;
    }
  }

  function invokeCallback(settled, promise, callback, detail) {
    var hasCallback = isFunction(callback),
        value = void 0,
        error = void 0,
        succeeded = void 0,
        failed = void 0;

    if (hasCallback) {
      value = tryCatch(callback, detail);

      if (value === TRY_CATCH_ERROR) {
        failed = true;
        error = value.error;
        value.error = null;
      } else {
        succeeded = true;
      }

      if (promise === value) {
        reject(promise, cannotReturnOwn());
        return;
      }
    } else {
      value = detail;
      succeeded = true;
    }

    if (promise._state !== PENDING) {// noop
    } else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
  }

  function initializePromise(promise, resolver) {
    try {
      resolver(function resolvePromise(value) {
        resolve(promise, value);
      }, function rejectPromise(reason) {
        reject(promise, reason);
      });
    } catch (e) {
      reject(promise, e);
    }
  }

  var id = 0;

  function nextId() {
    return id++;
  }

  function makePromise(promise) {
    promise[PROMISE_ID] = id++;
    promise._state = undefined;
    promise._result = undefined;
    promise._subscribers = [];
  }

  function validationError() {
    return new Error('Array Methods must be provided an Array');
  }

  var Enumerator = function () {
    function Enumerator(Constructor, input) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(noop);

      if (!this.promise[PROMISE_ID]) {
        makePromise(this.promise);
      }

      if (isArray(input)) {
        this.length = input.length;
        this._remaining = input.length;
        this._result = new Array(this.length);

        if (this.length === 0) {
          fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;

          this._enumerate(input);

          if (this._remaining === 0) {
            fulfill(this.promise, this._result);
          }
        }
      } else {
        reject(this.promise, validationError());
      }
    }

    Enumerator.prototype._enumerate = function _enumerate(input) {
      for (var i = 0; this._state === PENDING && i < input.length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
      var c = this._instanceConstructor;
      var resolve$$1 = c.resolve;

      if (resolve$$1 === resolve$1) {
        var _then = getThen(entry);

        if (_then === then && entry._state !== PENDING) {
          this._settledAt(entry._state, i, entry._result);
        } else if (typeof _then !== 'function') {
          this._remaining--;
          this._result[i] = entry;
        } else if (c === Promise$1) {
          var promise = new c(noop);
          handleMaybeThenable(promise, entry, _then);

          this._willSettleAt(promise, i);
        } else {
          this._willSettleAt(new c(function (resolve$$1) {
            return resolve$$1(entry);
          }), i);
        }
      } else {
        this._willSettleAt(resolve$$1(entry), i);
      }
    };

    Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
      var promise = this.promise;

      if (promise._state === PENDING) {
        this._remaining--;

        if (state === REJECTED) {
          reject(promise, value);
        } else {
          this._result[i] = value;
        }
      }

      if (this._remaining === 0) {
        fulfill(promise, this._result);
      }
    };

    Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
      var enumerator = this;
      subscribe(promise, undefined, function (value) {
        return enumerator._settledAt(FULFILLED, i, value);
      }, function (reason) {
        return enumerator._settledAt(REJECTED, i, reason);
      });
    };

    return Enumerator;
  }();
  /**
    `Promise.all` accepts an array of promises, and returns a new promise which
    is fulfilled with an array of fulfillment values for the passed promises, or
    rejected with the reason of the first passed promise to be rejected. It casts all
    elements of the passed iterable to promises as it runs this algorithm.
  
    Example:
  
    ```javascript
    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);
    let promises = [ promise1, promise2, promise3 ];
  
    Promise.all(promises).then(function(array){
      // The array here would be [ 1, 2, 3 ];
    });
    ```
  
    If any of the `promises` given to `all` are rejected, the first promise
    that is rejected will be given as an argument to the returned promises's
    rejection handler. For example:
  
    Example:
  
    ```javascript
    let promise1 = resolve(1);
    let promise2 = reject(new Error("2"));
    let promise3 = reject(new Error("3"));
    let promises = [ promise1, promise2, promise3 ];
  
    Promise.all(promises).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(error) {
      // error.message === "2"
    });
    ```
  
    @method all
    @static
    @param {Array} entries array of promises
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when all `promises` have been
    fulfilled, or rejected if any of them become rejected.
    @static
  */


  function all(entries) {
    return new Enumerator(this, entries).promise;
  }
  /**
    `Promise.race` returns a new promise which is settled in the same way as the
    first passed promise to settle.
  
    Example:
  
    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });
  
    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 2');
      }, 100);
    });
  
    Promise.race([promise1, promise2]).then(function(result){
      // result === 'promise 2' because it was resolved before promise1
      // was resolved.
    });
    ```
  
    `Promise.race` is deterministic in that only the state of the first
    settled promise matters. For example, even if other promises given to the
    `promises` array argument are resolved, but the first settled promise has
    become rejected before the other promises became fulfilled, the returned
    promise will become rejected:
  
    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });
  
    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        reject(new Error('promise 2'));
      }, 100);
    });
  
    Promise.race([promise1, promise2]).then(function(result){
      // Code here never runs
    }, function(reason){
      // reason.message === 'promise 2' because promise 2 became rejected before
      // promise 1 became fulfilled
    });
    ```
  
    An example real-world use case is implementing timeouts:
  
    ```javascript
    Promise.race([ajax('foo.json'), timeout(5000)])
    ```
  
    @method race
    @static
    @param {Array} promises array of promises to observe
    Useful for tooling.
    @return {Promise} a promise which settles in the same way as the first passed
    promise to settle.
  */


  function race(entries) {
    /*jshint validthis:true */
    var Constructor = this;

    if (!isArray(entries)) {
      return new Constructor(function (_, reject) {
        return reject(new TypeError('You must pass an array to race.'));
      });
    } else {
      return new Constructor(function (resolve, reject) {
        var length = entries.length;

        for (var i = 0; i < length; i++) {
          Constructor.resolve(entries[i]).then(resolve, reject);
        }
      });
    }
  }
  /**
    `Promise.reject` returns a promise rejected with the passed `reason`.
    It is shorthand for the following:
  
    ```javascript
    let promise = new Promise(function(resolve, reject){
      reject(new Error('WHOOPS'));
    });
  
    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```
  
    Instead of writing the above, your code now simply becomes the following:
  
    ```javascript
    let promise = Promise.reject(new Error('WHOOPS'));
  
    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```
  
    @method reject
    @static
    @param {Any} reason value that the returned promise will be rejected with.
    Useful for tooling.
    @return {Promise} a promise rejected with the given `reason`.
  */


  function reject$1(reason) {
    /*jshint validthis:true */
    var Constructor = this;
    var promise = new Constructor(noop);
    reject(promise, reason);
    return promise;
  }

  function needsResolver() {
    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
  }

  function needsNew() {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  /**
    Promise objects represent the eventual result of an asynchronous operation. The
    primary way of interacting with a promise is through its `then` method, which
    registers callbacks to receive either a promise's eventual value or the reason
    why the promise cannot be fulfilled.
  
    Terminology
    -----------
  
    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
    - `thenable` is an object or function that defines a `then` method.
    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
    - `exception` is a value that is thrown using the throw statement.
    - `reason` is a value that indicates why a promise was rejected.
    - `settled` the final resting state of a promise, fulfilled or rejected.
  
    A promise can be in one of three states: pending, fulfilled, or rejected.
  
    Promises that are fulfilled have a fulfillment value and are in the fulfilled
    state.  Promises that are rejected have a rejection reason and are in the
    rejected state.  A fulfillment value is never a thenable.
  
    Promises can also be said to *resolve* a value.  If this value is also a
    promise, then the original promise's settled state will match the value's
    settled state.  So a promise that *resolves* a promise that rejects will
    itself reject, and a promise that *resolves* a promise that fulfills will
    itself fulfill.
  
  
    Basic Usage:
    ------------
  
    ```js
    let promise = new Promise(function(resolve, reject) {
      // on success
      resolve(value);
  
      // on failure
      reject(reason);
    });
  
    promise.then(function(value) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```
  
    Advanced Usage:
    ---------------
  
    Promises shine when abstracting away asynchronous interactions such as
    `XMLHttpRequest`s.
  
    ```js
    function getJSON(url) {
      return new Promise(function(resolve, reject){
        let xhr = new XMLHttpRequest();
  
        xhr.open('GET', url);
        xhr.onreadystatechange = handler;
        xhr.responseType = 'json';
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.send();
  
        function handler() {
          if (this.readyState === this.DONE) {
            if (this.status === 200) {
              resolve(this.response);
            } else {
              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
            }
          }
        };
      });
    }
  
    getJSON('/posts.json').then(function(json) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```
  
    Unlike callbacks, promises are great composable primitives.
  
    ```js
    Promise.all([
      getJSON('/posts'),
      getJSON('/comments')
    ]).then(function(values){
      values[0] // => postsJSON
      values[1] // => commentsJSON
  
      return values;
    });
    ```
  
    @class Promise
    @param {Function} resolver
    Useful for tooling.
    @constructor
  */


  var Promise$1 = function () {
    function Promise(resolver) {
      this[PROMISE_ID] = nextId();
      this._result = this._state = undefined;
      this._subscribers = [];

      if (noop !== resolver) {
        typeof resolver !== 'function' && needsResolver();
        this instanceof Promise ? initializePromise(this, resolver) : needsNew();
      }
    }
    /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
     ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
     Chaining
    --------
     The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
     ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
     findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
     ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
     Assimilation
    ------------
     Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
     ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
     If the assimliated promise rejects, then the downstream promise will also reject.
     ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
     Simple Example
    --------------
     Synchronous Example
     ```javascript
    let result;
     try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
     Errback Example
     ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
     Promise Example;
     ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
     Advanced Example
    --------------
     Synchronous Example
     ```javascript
    let author, books;
     try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
     Errback Example
     ```js
     function foundBooks(books) {
     }
     function failure(reason) {
     }
     findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
     Promise Example;
     ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
     @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
    */

    /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
    ```js
    function findAuthor(){
    throw new Error('couldn't find that author');
    }
    // synchronous
    try {
    findAuthor();
    } catch(reason) {
    // something went wrong
    }
    // async with promises
    findAuthor().catch(function(reason){
    // something went wrong
    });
    ```
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
    */


    Promise.prototype.catch = function _catch(onRejection) {
      return this.then(null, onRejection);
    };
    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves
    
      Synchronous example:
    
      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }
    
      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```
    
      Asynchronous example:
    
      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```
    
      @method finally
      @param {Function} callback
      @return {Promise}
    */


    Promise.prototype.finally = function _finally(callback) {
      var promise = this;
      var constructor = promise.constructor;

      if (isFunction(callback)) {
        return promise.then(function (value) {
          return constructor.resolve(callback()).then(function () {
            return value;
          });
        }, function (reason) {
          return constructor.resolve(callback()).then(function () {
            throw reason;
          });
        });
      }

      return promise.then(callback, callback);
    };

    return Promise;
  }();

  Promise$1.prototype.then = then;
  Promise$1.all = all;
  Promise$1.race = race;
  Promise$1.resolve = resolve$1;
  Promise$1.reject = reject$1;
  Promise$1._setScheduler = setScheduler;
  Promise$1._setAsap = setAsap;
  Promise$1._asap = asap;
  /*global self*/

  function polyfill() {
    var local = void 0;

    if (typeof global !== 'undefined') {
      local = global;
    } else if (typeof self !== 'undefined') {
      local = self;
    } else {
      try {
        local = Function('return this')();
      } catch (e) {
        throw new Error('polyfill failed because global object is unavailable in this environment');
      }
    }

    var P = local.Promise;

    if (P) {
      var promiseToString = null;

      try {
        promiseToString = Object.prototype.toString.call(P.resolve());
      } catch (e) {// silently ignored
      }

      if (promiseToString === '[object Promise]' && !P.cast) {
        return;
      }
    }

    local.Promise = Promise$1;
  } // Strange compat..


  Promise$1.polyfill = polyfill;
  Promise$1.Promise = Promise$1;
  return Promise$1;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(432), __webpack_require__(70)))

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Dropdown; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__slideToggler__ = __webpack_require__(99);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



/*
* TODO: finish open state
* TODO: REFACTOR
* TODO: possibility to add overlay
* */

/**
 * Class represents Dropdown component
 */

var Dropdown =
/*#__PURE__*/
function () {
  /**
   * Create dropdown instance.
   * @param {(String|Node)} selector - element to initialize plugin
   * @param {Object} options - Dropdown options
   */
  function Dropdown() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.js-dropdown';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Dropdown);

    this.selector = selector;
    this.toggler = null;
    this.dropdown = null;
    this.slideToggler = null;
    this.closeBtn = null;
    this.focusTrapHandler = null; // Plugin options

    this.options = {
      wrapperClass: 'js-dropdown',
      dropdownClass: 'js-dropdown__block',
      btnClass: 'js-dropdown__toggle',
      closeBtnClass: 'js-dropdown__close',
      closeBtnHtml: '<span class="ghost">Fermer</span>',
      closeHelperClass: 'has-close-btn',
      closeBtn: false,
      opened: [],
      outsideToggle: false,
      outsideToggleId: 'js-dropdown-outside-toggle',
      closeOnOutsideClick: true,
      openTypeSlide: false,
      isWrapContent: false,
      focusTrap: false,
      overflow: false,
      onInit: function onInit() {},
      beforeOpen: function beforeOpen() {},
      afterOpen: function afterOpen() {},
      beforeClose: function beforeClose() {},
      afterClose: function afterClose() {}
    };

    if (options instanceof Object) {
      this.options = __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](this.options, options);
    }

    this.checkBeforeInit();
  }

  _createClass(Dropdown, [{
    key: "checkBeforeInit",
    value: function checkBeforeInit() {
      if (typeof this.selector !== 'string') {
        return this.selector === null ? false : this.init();
      }

      if (typeof this.selector === 'string') {
        var els = document.querySelectorAll(this.selector);

        if (els === null) {
          return;
        }

        for (var i = 0; i < els.length; i++) {
          var el = new Dropdown(els[i], this.options);
        }
      }
    }
  }, {
    key: "init",
    value: function init() {
      this.options.onInit();
      this.create();
      this.initEvents();
    }
  }, {
    key: "manageResponsiveState",
    value: function manageResponsiveState() {
      if (this.options.opened.length === 0) {
        return;
      }

      var isOpened = __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.selector, '-is-open');
      var isNeedToOpen = this.options.opened.indexOf(window.responsive) !== -1;

      if (!isOpened && isNeedToOpen) {
        this.open();
      } else if (isOpened && !isNeedToOpen) {
        this.close();
      }
    }
  }, {
    key: "create",
    value: function create() {
      var $selector = this.selector;
      var errSelector = '';
      $selector.classList.add(this.options.wrapperClass);

      if (this.options.outsideToggle) {
        this.toggler = document.getElementById(this.options.outsideToggleId);
        errSelector = "\"#".concat(this.options.outsideToggleId, "\"");
      } else {
        this.toggler = $selector.querySelector(".".concat(this.options.btnClass));
        errSelector = "\".".concat(this.options.btnClass, "\"");
      } // Handle if toggler button not found.


      if (!this.toggler) {
        throw new Error("Dropdown. Can't find toggle button with selector: ".concat(errSelector, " for \"").concat(this.selector.className, "\""));
      }

      this.dropdown = $selector.querySelector(".".concat(this.options.dropdownClass));

      if (this.options.opened.length === 0) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.dropdown, -1);
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.dropdown, 0);
      }

      this.slideToggler = this.options.openTypeSlide && new __WEBPACK_IMPORTED_MODULE_1__slideToggler__["a" /* default */](this.dropdown, {
        isWrapContent: this.options.isWrapContent
      });

      if (this.options.closeBtn) {
        this.closeBtn = $selector.querySelector(".".concat(this.options.closeBtnClass)); // Check if $close button is not exists

        if (this.closeBtn === null) {
          this.closeBtn = document.createElement('button');
          this.closeBtn.setAttribute('type', 'button');
          this.closeBtn.className = this.options.closeBtnClass;
          this.closeBtn.innerHTML = this.options.closeBtnHtml;
          $selector.insertBefore(this.closeBtn, $selector.children[0]);
        }

        __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */]([this.toggler, this.closeBtn], this.dropdown);
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */](this.toggler, this.dropdown);
      }
    }
  }, {
    key: "open",
    value: function open() {
      this.options.beforeOpen();

      if (this.options.openTypeSlide) {
        this.slideToggler.open();
      }

      if (this.options.outsideToggle) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](this.selector, '-is-open');
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](this.toggler.parentElement, '-is-open');
      }

      if (this.options.closeBtn === true && this.closeBtn !== null) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.toggler, this.closeBtn], this.dropdown, 'opened');
        this.closeBtn.setAttribute('tabindex', 0);
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.toggler, this.dropdown, 'opened');
      }

      if (this.options.overflow) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](document.body, '-overflow-hidden');
      }

      __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.dropdown, 0);

      if (this.options.focusTrap) {
        var focusableElements = __WEBPACK_IMPORTED_MODULE_0__helpers__["i" /* getFocusableElements */](this.selector, true); // When open set focus on first element

        __WEBPACK_IMPORTED_MODULE_0__helpers__["A" /* setFirstElementFocus */](focusableElements);
      }

      this.options.afterOpen();
    }
  }, {
    key: "close",
    value: function close() {
      this.options.beforeClose(); // When closed set focus on opener button

      if (this.options.focusTrap) {
        this.toggler.focus();
      }

      if (this.options.openTypeSlide) {
        this.slideToggler.close();
      }

      if (this.options.outsideToggle) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](this.selector, '-is-open');
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](this.toggler.parentElement, '-is-open');
      }

      if (this.options.overflow) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](document.body, '-overflow-hidden');
      }

      __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.dropdown, -1);

      if (this.options.closeBtn === true && this.closeBtn !== null) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.toggler, this.closeBtn], this.dropdown, 'closed');
        this.closeBtn.setAttribute('tabindex', -1);
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.toggler, this.dropdown, 'closed');
      }

      this.options.afterClose();
    }
  }, {
    key: "initEvents",
    value: function initEvents() {
      var _this = this;

      this.toggler.addEventListener('click', Dropdown.onTogglerClick.bind(this));

      if (this.options.closeBtn === true && this.closeBtn !== null) {
        this.closeBtn.addEventListener('click', this.close.bind(this));
      }

      window.addEventListener('responsive', this.manageResponsiveState.bind(this));

      if (this.options.focusTrap) {
        this.focusTrapHandler = this.initFocusTrap.bind(this);
        window.addEventListener('responsive', this.manageFocusTrap.bind(this), false);
      } // Close dropdown if click outside


      if (this.options.closeOnOutsideClick) {
        document.addEventListener('click', function (event) {
          var isClickInside = _this.selector.contains(event.target) || event.target === _this.toggler || _this.toggler.contains(event.target); // !this.options.outsideToggle &&


          var isOpened = __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](_this.selector, '-is-open');

          if (!isClickInside && isOpened) {
            _this.close();
          }
        });
      }
    }
  }, {
    key: "manageFocusTrap",
    value: function manageFocusTrap() {
      var _this2 = this;

      if (typeof this.options.focusTrap !== 'boolean') {
        if (!Array.isArray(this.options.focusTrap)) {
          throw new Error('focusTrap parameter should be Boolean or Array');
        }

        this.selector.removeEventListener('keydown', this.focusTrapHandler, true);
        this.options.focusTrap.forEach(function (resolution) {
          if (window.responsive === resolution) {
            _this2.selector.addEventListener('keydown', _this2.focusTrapHandler, true);
          }
        });
      } else {
        this.selector.addEventListener('keydown', this.focusTrapHandler, true);
      }
    }
  }, {
    key: "initFocusTrap",
    value: function initFocusTrap(event) {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["p" /* initFocusTrap */](this.selector, event, true);

      if (event.keyCode === 27) {
        this.close();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["u" /* removeAriaControls */](this.toggler.parentElement);
      this.toggler.removeEventListener('click', Dropdown.onTogglerClick.bind(this));

      if (this.options.closeBtn === true && this.closeBtn !== null) {
        this.closeBtn.removeEventListener('click', this.close.bind(this));
      }
    }
  }], [{
    key: "onTogglerClick",
    value: function onTogglerClick() {
      var flag;

      if (this.options.outsideToggle) {
        flag = __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.selector, '-is-open');
      } else {
        flag = __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.toggler.parentElement, '-is-open');
      }

      if (flag === true) {
        this.close();
      } else {
        this.open();
      }
    }
  }]);

  return Dropdown;
}();



/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var convert = __webpack_require__(461);

var string = __webpack_require__(463);

var Color = function (obj) {
  if (obj instanceof Color) {
    return obj;
  }

  if (!(this instanceof Color)) {
    return new Color(obj);
  }

  this.valid = false;
  this.values = {
    rgb: [0, 0, 0],
    hsl: [0, 0, 0],
    hsv: [0, 0, 0],
    hwb: [0, 0, 0],
    cmyk: [0, 0, 0, 0],
    alpha: 1
  }; // parse Color() argument

  var vals;

  if (typeof obj === 'string') {
    vals = string.getRgba(obj);

    if (vals) {
      this.setValues('rgb', vals);
    } else if (vals = string.getHsla(obj)) {
      this.setValues('hsl', vals);
    } else if (vals = string.getHwb(obj)) {
      this.setValues('hwb', vals);
    }
  } else if (typeof obj === 'object') {
    vals = obj;

    if (vals.r !== undefined || vals.red !== undefined) {
      this.setValues('rgb', vals);
    } else if (vals.l !== undefined || vals.lightness !== undefined) {
      this.setValues('hsl', vals);
    } else if (vals.v !== undefined || vals.value !== undefined) {
      this.setValues('hsv', vals);
    } else if (vals.w !== undefined || vals.whiteness !== undefined) {
      this.setValues('hwb', vals);
    } else if (vals.c !== undefined || vals.cyan !== undefined) {
      this.setValues('cmyk', vals);
    }
  }
};

Color.prototype = {
  isValid: function () {
    return this.valid;
  },
  rgb: function () {
    return this.setSpace('rgb', arguments);
  },
  hsl: function () {
    return this.setSpace('hsl', arguments);
  },
  hsv: function () {
    return this.setSpace('hsv', arguments);
  },
  hwb: function () {
    return this.setSpace('hwb', arguments);
  },
  cmyk: function () {
    return this.setSpace('cmyk', arguments);
  },
  rgbArray: function () {
    return this.values.rgb;
  },
  hslArray: function () {
    return this.values.hsl;
  },
  hsvArray: function () {
    return this.values.hsv;
  },
  hwbArray: function () {
    var values = this.values;

    if (values.alpha !== 1) {
      return values.hwb.concat([values.alpha]);
    }

    return values.hwb;
  },
  cmykArray: function () {
    return this.values.cmyk;
  },
  rgbaArray: function () {
    var values = this.values;
    return values.rgb.concat([values.alpha]);
  },
  hslaArray: function () {
    var values = this.values;
    return values.hsl.concat([values.alpha]);
  },
  alpha: function (val) {
    if (val === undefined) {
      return this.values.alpha;
    }

    this.setValues('alpha', val);
    return this;
  },
  red: function (val) {
    return this.setChannel('rgb', 0, val);
  },
  green: function (val) {
    return this.setChannel('rgb', 1, val);
  },
  blue: function (val) {
    return this.setChannel('rgb', 2, val);
  },
  hue: function (val) {
    if (val) {
      val %= 360;
      val = val < 0 ? 360 + val : val;
    }

    return this.setChannel('hsl', 0, val);
  },
  saturation: function (val) {
    return this.setChannel('hsl', 1, val);
  },
  lightness: function (val) {
    return this.setChannel('hsl', 2, val);
  },
  saturationv: function (val) {
    return this.setChannel('hsv', 1, val);
  },
  whiteness: function (val) {
    return this.setChannel('hwb', 1, val);
  },
  blackness: function (val) {
    return this.setChannel('hwb', 2, val);
  },
  value: function (val) {
    return this.setChannel('hsv', 2, val);
  },
  cyan: function (val) {
    return this.setChannel('cmyk', 0, val);
  },
  magenta: function (val) {
    return this.setChannel('cmyk', 1, val);
  },
  yellow: function (val) {
    return this.setChannel('cmyk', 2, val);
  },
  black: function (val) {
    return this.setChannel('cmyk', 3, val);
  },
  hexString: function () {
    return string.hexString(this.values.rgb);
  },
  rgbString: function () {
    return string.rgbString(this.values.rgb, this.values.alpha);
  },
  rgbaString: function () {
    return string.rgbaString(this.values.rgb, this.values.alpha);
  },
  percentString: function () {
    return string.percentString(this.values.rgb, this.values.alpha);
  },
  hslString: function () {
    return string.hslString(this.values.hsl, this.values.alpha);
  },
  hslaString: function () {
    return string.hslaString(this.values.hsl, this.values.alpha);
  },
  hwbString: function () {
    return string.hwbString(this.values.hwb, this.values.alpha);
  },
  keyword: function () {
    return string.keyword(this.values.rgb, this.values.alpha);
  },
  rgbNumber: function () {
    var rgb = this.values.rgb;
    return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
  },
  luminosity: function () {
    // http://www.w3.org/TR/WCAG20/#relativeluminancedef
    var rgb = this.values.rgb;
    var lum = [];

    for (var i = 0; i < rgb.length; i++) {
      var chan = rgb[i] / 255;
      lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
    }

    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  },
  contrast: function (color2) {
    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
    var lum1 = this.luminosity();
    var lum2 = color2.luminosity();

    if (lum1 > lum2) {
      return (lum1 + 0.05) / (lum2 + 0.05);
    }

    return (lum2 + 0.05) / (lum1 + 0.05);
  },
  level: function (color2) {
    var contrastRatio = this.contrast(color2);

    if (contrastRatio >= 7.1) {
      return 'AAA';
    }

    return contrastRatio >= 4.5 ? 'AA' : '';
  },
  dark: function () {
    // YIQ equation from http://24ways.org/2010/calculating-color-contrast
    var rgb = this.values.rgb;
    var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
    return yiq < 128;
  },
  light: function () {
    return !this.dark();
  },
  negate: function () {
    var rgb = [];

    for (var i = 0; i < 3; i++) {
      rgb[i] = 255 - this.values.rgb[i];
    }

    this.setValues('rgb', rgb);
    return this;
  },
  lighten: function (ratio) {
    var hsl = this.values.hsl;
    hsl[2] += hsl[2] * ratio;
    this.setValues('hsl', hsl);
    return this;
  },
  darken: function (ratio) {
    var hsl = this.values.hsl;
    hsl[2] -= hsl[2] * ratio;
    this.setValues('hsl', hsl);
    return this;
  },
  saturate: function (ratio) {
    var hsl = this.values.hsl;
    hsl[1] += hsl[1] * ratio;
    this.setValues('hsl', hsl);
    return this;
  },
  desaturate: function (ratio) {
    var hsl = this.values.hsl;
    hsl[1] -= hsl[1] * ratio;
    this.setValues('hsl', hsl);
    return this;
  },
  whiten: function (ratio) {
    var hwb = this.values.hwb;
    hwb[1] += hwb[1] * ratio;
    this.setValues('hwb', hwb);
    return this;
  },
  blacken: function (ratio) {
    var hwb = this.values.hwb;
    hwb[2] += hwb[2] * ratio;
    this.setValues('hwb', hwb);
    return this;
  },
  greyscale: function () {
    var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    this.setValues('rgb', [val, val, val]);
    return this;
  },
  clearer: function (ratio) {
    var alpha = this.values.alpha;
    this.setValues('alpha', alpha - alpha * ratio);
    return this;
  },
  opaquer: function (ratio) {
    var alpha = this.values.alpha;
    this.setValues('alpha', alpha + alpha * ratio);
    return this;
  },
  rotate: function (degrees) {
    var hsl = this.values.hsl;
    var hue = (hsl[0] + degrees) % 360;
    hsl[0] = hue < 0 ? 360 + hue : hue;
    this.setValues('hsl', hsl);
    return this;
  },

  /**
   * Ported from sass implementation in C
   * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
   */
  mix: function (mixinColor, weight) {
    var color1 = this;
    var color2 = mixinColor;
    var p = weight === undefined ? 0.5 : weight;
    var w = 2 * p - 1;
    var a = color1.alpha() - color2.alpha();
    var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
    var w2 = 1 - w1;
    return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
  },
  toJSON: function () {
    return this.rgb();
  },
  clone: function () {
    // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
    // making the final build way to big to embed in Chart.js. So let's do it manually,
    // assuming that values to clone are 1 dimension arrays containing only numbers,
    // except 'alpha' which is a number.
    var result = new Color();
    var source = this.values;
    var target = result.values;
    var value, type;

    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        value = source[prop];
        type = {}.toString.call(value);

        if (type === '[object Array]') {
          target[prop] = value.slice(0);
        } else if (type === '[object Number]') {
          target[prop] = value;
        } else {
          console.error('unexpected color value:', value);
        }
      }
    }

    return result;
  }
};
Color.prototype.spaces = {
  rgb: ['red', 'green', 'blue'],
  hsl: ['hue', 'saturation', 'lightness'],
  hsv: ['hue', 'saturation', 'value'],
  hwb: ['hue', 'whiteness', 'blackness'],
  cmyk: ['cyan', 'magenta', 'yellow', 'black']
};
Color.prototype.maxes = {
  rgb: [255, 255, 255],
  hsl: [360, 100, 100],
  hsv: [360, 100, 100],
  hwb: [360, 100, 100],
  cmyk: [100, 100, 100, 100]
};

Color.prototype.getValues = function (space) {
  var values = this.values;
  var vals = {};

  for (var i = 0; i < space.length; i++) {
    vals[space.charAt(i)] = values[space][i];
  }

  if (values.alpha !== 1) {
    vals.a = values.alpha;
  } // {r: 255, g: 255, b: 255, a: 0.4}


  return vals;
};

Color.prototype.setValues = function (space, vals) {
  var values = this.values;
  var spaces = this.spaces;
  var maxes = this.maxes;
  var alpha = 1;
  var i;
  this.valid = true;

  if (space === 'alpha') {
    alpha = vals;
  } else if (vals.length) {
    // [10, 10, 10]
    values[space] = vals.slice(0, space.length);
    alpha = vals[space.length];
  } else if (vals[space.charAt(0)] !== undefined) {
    // {r: 10, g: 10, b: 10}
    for (i = 0; i < space.length; i++) {
      values[space][i] = vals[space.charAt(i)];
    }

    alpha = vals.a;
  } else if (vals[spaces[space][0]] !== undefined) {
    // {red: 10, green: 10, blue: 10}
    var chans = spaces[space];

    for (i = 0; i < space.length; i++) {
      values[space][i] = vals[chans[i]];
    }

    alpha = vals.alpha;
  }

  values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

  if (space === 'alpha') {
    return false;
  }

  var capped; // cap values of the space prior converting all values

  for (i = 0; i < space.length; i++) {
    capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
    values[space][i] = Math.round(capped);
  } // convert to all the other color spaces


  for (var sname in spaces) {
    if (sname !== space) {
      values[sname] = convert[space][sname](values[space]);
    }
  }

  return true;
};

Color.prototype.setSpace = function (space, args) {
  var vals = args[0];

  if (vals === undefined) {
    // color.rgb()
    return this.getValues(space);
  } // color.rgb(10, 10, 10)


  if (typeof vals === 'number') {
    vals = Array.prototype.slice.call(args);
  }

  this.setValues(space, vals);
  return this;
};

Color.prototype.setChannel = function (space, index, val) {
  var svalues = this.values[space];

  if (val === undefined) {
    // color.red()
    return svalues[index];
  } else if (val === svalues[index]) {
    // color.red(color.red())
    return this;
  } // color.red(100)


  svalues[index] = val;
  this.setValues(space, svalues);
  return this;
};

if (typeof window !== 'undefined') {
  window.Color = Color;
}

module.exports = Color;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Element = __webpack_require__(25);

var exports = module.exports = Element.extend({
  chart: null,
  // the animation associated chart instance
  currentStep: 0,
  // the current animation step
  numSteps: 60,
  // default number of steps
  easing: '',
  // the easing to use for this animation
  render: null,
  // render function used by the animation service
  onAnimationProgress: null,
  // user specified callback to fire on each step of the animation
  onAnimationComplete: null // user specified callback to fire when the animation finishes

}); // DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.Animation instead
 * @prop Chart.Animation#animationObject
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 */

Object.defineProperty(exports.prototype, 'animationObject', {
  get: function () {
    return this;
  }
});
/**
 * Provided for backward compatibility, use Chart.Animation#chart instead
 * @prop Chart.Animation#chartInstance
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 */

Object.defineProperty(exports.prototype, 'chartInstance', {
  get: function () {
    return this.chart;
  },
  set: function (value) {
    this.chart = value;
  }
});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */


var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

defaults._set('global', {
  animation: {
    duration: 1000,
    easing: 'easeOutQuart',
    onProgress: helpers.noop,
    onComplete: helpers.noop
  }
});

module.exports = {
  frameDuration: 17,
  animations: [],
  dropFrames: 0,
  request: null,

  /**
   * @param {Chart} chart - The chart to animate.
   * @param {Chart.Animation} animation - The animation that we will animate.
   * @param {Number} duration - The animation duration in ms.
   * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
   */
  addAnimation: function (chart, animation, duration, lazy) {
    var animations = this.animations;
    var i, ilen;
    animation.chart = chart;

    if (!lazy) {
      chart.animating = true;
    }

    for (i = 0, ilen = animations.length; i < ilen; ++i) {
      if (animations[i].chart === chart) {
        animations[i] = animation;
        return;
      }
    }

    animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

    if (animations.length === 1) {
      this.requestAnimationFrame();
    }
  },
  cancelAnimation: function (chart) {
    var index = helpers.findIndex(this.animations, function (animation) {
      return animation.chart === chart;
    });

    if (index !== -1) {
      this.animations.splice(index, 1);
      chart.animating = false;
    }
  },
  requestAnimationFrame: function () {
    var me = this;

    if (me.request === null) {
      // Skip animation frame requests until the active one is executed.
      // This can happen when processing mouse events, e.g. 'mousemove'
      // and 'mouseout' events will trigger multiple renders.
      me.request = helpers.requestAnimFrame.call(window, function () {
        me.request = null;
        me.startDigest();
      });
    }
  },

  /**
   * @private
   */
  startDigest: function () {
    var me = this;
    var startTime = Date.now();
    var framesToDrop = 0;

    if (me.dropFrames > 1) {
      framesToDrop = Math.floor(me.dropFrames);
      me.dropFrames = me.dropFrames % 1;
    }

    me.advance(1 + framesToDrop);
    var endTime = Date.now();
    me.dropFrames += (endTime - startTime) / me.frameDuration; // Do we have more stuff to animate?

    if (me.animations.length > 0) {
      me.requestAnimationFrame();
    }
  },

  /**
   * @private
   */
  advance: function (count) {
    var animations = this.animations;
    var animation, chart;
    var i = 0;

    while (i < animations.length) {
      animation = animations[i];
      chart = animation.chart;
      animation.currentStep = (animation.currentStep || 0) + count;
      animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
      helpers.callback(animation.render, [chart, animation], chart);
      helpers.callback(animation.onAnimationProgress, [animation], chart);

      if (animation.currentStep >= animation.numSteps) {
        helpers.callback(animation.onAnimationComplete, [animation], chart);
        chart.animating = false;
        animations.splice(i, 1);
      } else {
        ++i;
      }
    }
  }
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);
/**
 * Helper function to get relative position for an event
 * @param {Event|IEvent} event - The event to get the position for
 * @param {Chart} chart - The chart
 * @returns {Point} the event position
 */


function getRelativePosition(e, chart) {
  if (e.native) {
    return {
      x: e.x,
      y: e.y
    };
  }

  return helpers.getRelativePosition(e, chart);
}
/**
 * Helper function to traverse all of the visible elements in the chart
 * @param chart {chart} the chart
 * @param handler {Function} the callback to execute for each visible item
 */


function parseVisibleItems(chart, handler) {
  var datasets = chart.data.datasets;
  var meta, i, j, ilen, jlen;

  for (i = 0, ilen = datasets.length; i < ilen; ++i) {
    if (!chart.isDatasetVisible(i)) {
      continue;
    }

    meta = chart.getDatasetMeta(i);

    for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
      var element = meta.data[j];

      if (!element._view.skip) {
        handler(element);
      }
    }
  }
}
/**
 * Helper function to get the items that intersect the event position
 * @param items {ChartElement[]} elements to filter
 * @param position {Point} the point to be nearest to
 * @return {ChartElement[]} the nearest items
 */


function getIntersectItems(chart, position) {
  var elements = [];
  parseVisibleItems(chart, function (element) {
    if (element.inRange(position.x, position.y)) {
      elements.push(element);
    }
  });
  return elements;
}
/**
 * Helper function to get the items nearest to the event position considering all visible items in teh chart
 * @param chart {Chart} the chart to look at elements from
 * @param position {Point} the point to be nearest to
 * @param intersect {Boolean} if true, only consider items that intersect the position
 * @param distanceMetric {Function} function to provide the distance between points
 * @return {ChartElement[]} the nearest items
 */


function getNearestItems(chart, position, intersect, distanceMetric) {
  var minDistance = Number.POSITIVE_INFINITY;
  var nearestItems = [];
  parseVisibleItems(chart, function (element) {
    if (intersect && !element.inRange(position.x, position.y)) {
      return;
    }

    var center = element.getCenterPoint();
    var distance = distanceMetric(position, center);

    if (distance < minDistance) {
      nearestItems = [element];
      minDistance = distance;
    } else if (distance === minDistance) {
      // Can have multiple items at the same distance in which case we sort by size
      nearestItems.push(element);
    }
  });
  return nearestItems;
}
/**
 * Get a distance metric function for two points based on the
 * axis mode setting
 * @param {String} axis the axis mode. x|y|xy
 */


function getDistanceMetricForAxis(axis) {
  var useX = axis.indexOf('x') !== -1;
  var useY = axis.indexOf('y') !== -1;
  return function (pt1, pt2) {
    var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}

function indexMode(chart, e, options) {
  var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

  options.axis = options.axis || 'x';
  var distanceMetric = getDistanceMetricForAxis(options.axis);
  var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
  var elements = [];

  if (!items.length) {
    return [];
  }

  chart.data.datasets.forEach(function (dataset, datasetIndex) {
    if (chart.isDatasetVisible(datasetIndex)) {
      var meta = chart.getDatasetMeta(datasetIndex);
      var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

      if (element && !element._view.skip) {
        elements.push(element);
      }
    }
  });
  return elements;
}
/**
 * @interface IInteractionOptions
 */

/**
 * If true, only consider items that intersect the point
 * @name IInterfaceOptions#boolean
 * @type Boolean
 */

/**
 * Contains interaction related functions
 * @namespace Chart.Interaction
 */


module.exports = {
  // Helper function for different modes
  modes: {
    single: function (chart, e) {
      var position = getRelativePosition(e, chart);
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
          return elements;
        }
      });
      return elements.slice(0, 1);
    },

    /**
     * @function Chart.Interaction.modes.label
     * @deprecated since version 2.4.0
     * @todo remove at version 3
     * @private
     */
    label: indexMode,

    /**
     * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
     * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
     * @function Chart.Interaction.modes.index
     * @since v2.4.0
     * @param chart {chart} the chart we are returning items from
     * @param e {Event} the event we are find things at
     * @param options {IInteractionOptions} options to use during interaction
     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
     */
    index: indexMode,

    /**
     * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
     * If the options.intersect is false, we find the nearest item and return the items in that dataset
     * @function Chart.Interaction.modes.dataset
     * @param chart {chart} the chart we are returning items from
     * @param e {Event} the event we are find things at
     * @param options {IInteractionOptions} options to use during interaction
     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
     */
    dataset: function (chart, e, options) {
      var position = getRelativePosition(e, chart);
      options.axis = options.axis || 'xy';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

      if (items.length > 0) {
        items = chart.getDatasetMeta(items[0]._datasetIndex).data;
      }

      return items;
    },

    /**
     * @function Chart.Interaction.modes.x-axis
     * @deprecated since version 2.4.0. Use index mode and intersect == true
     * @todo remove at version 3
     * @private
     */
    'x-axis': function (chart, e) {
      return indexMode(chart, e, {
        intersect: false
      });
    },

    /**
     * Point mode returns all elements that hit test based on the event position
     * of the event
     * @function Chart.Interaction.modes.intersect
     * @param chart {chart} the chart we are returning items from
     * @param e {Event} the event we are find things at
     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
     */
    point: function (chart, e) {
      var position = getRelativePosition(e, chart);
      return getIntersectItems(chart, position);
    },

    /**
     * nearest mode returns the element closest to the point
     * @function Chart.Interaction.modes.intersect
     * @param chart {chart} the chart we are returning items from
     * @param e {Event} the event we are find things at
     * @param options {IInteractionOptions} options to use
     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
     */
    nearest: function (chart, e, options) {
      var position = getRelativePosition(e, chart);
      options.axis = options.axis || 'xy';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric); // We have multiple items at the same distance from the event. Now sort by smallest

      if (nearestItems.length > 1) {
        nearestItems.sort(function (a, b) {
          var sizeA = a.getArea();
          var sizeB = b.getArea();
          var ret = sizeA - sizeB;

          if (ret === 0) {
            // if equal sort by dataset index
            ret = a._datasetIndex - b._datasetIndex;
          }

          return ret;
        });
      } // Return only 1 item


      return nearestItems.slice(0, 1);
    },

    /**
     * x mode returns the elements that hit-test at the current x coordinate
     * @function Chart.Interaction.modes.x
     * @param chart {chart} the chart we are returning items from
     * @param e {Event} the event we are find things at
     * @param options {IInteractionOptions} options to use
     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
     */
    x: function (chart, e, options) {
      var position = getRelativePosition(e, chart);
      var items = [];
      var intersectsItem = false;
      parseVisibleItems(chart, function (element) {
        if (element.inXRange(position.x)) {
          items.push(element);
        }

        if (element.inRange(position.x, position.y)) {
          intersectsItem = true;
        }
      }); // If we want to trigger on an intersect and we don't have any items
      // that intersect the position, return nothing

      if (options.intersect && !intersectsItem) {
        items = [];
      }

      return items;
    },

    /**
     * y mode returns the elements that hit-test at the current y coordinate
     * @function Chart.Interaction.modes.y
     * @param chart {chart} the chart we are returning items from
     * @param e {Event} the event we are find things at
     * @param options {IInteractionOptions} options to use
     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
     */
    y: function (chart, e, options) {
      var position = getRelativePosition(e, chart);
      var items = [];
      var intersectsItem = false;
      parseVisibleItems(chart, function (element) {
        if (element.inYRange(position.y)) {
          items.push(element);
        }

        if (element.inRange(position.x, position.y)) {
          intersectsItem = true;
        }
      }); // If we want to trigger on an intersect and we don't have any items
      // that intersect the position, return nothing

      if (options.intersect && !intersectsItem) {
        items = [];
      }

      return items;
    }
  }
};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);

var basic = __webpack_require__(469);

var dom = __webpack_require__(470); // @TODO Make possible to select another platform at build time.


var implementation = dom._enabled ? dom : basic;
/**
 * @namespace Chart.platform
 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
 * @since 2.4.0
 */

module.exports = helpers.extend({
  /**
   * @since 2.7.0
   */
  initialize: function () {},

  /**
   * Called at chart construction time, returns a context2d instance implementing
   * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
   * @param {*} item - The native item from which to acquire context (platform specific)
   * @param {Object} options - The chart options
   * @returns {CanvasRenderingContext2D} context2d instance
   */
  acquireContext: function () {},

  /**
   * Called at chart destruction time, releases any resources associated to the context
   * previously returned by the acquireContext() method.
   * @param {CanvasRenderingContext2D} context - The context2d instance
   * @returns {Boolean} true if the method succeeded, else false
   */
  releaseContext: function () {},

  /**
   * Registers the specified listener on the given chart.
   * @param {Chart} chart - Chart from which to listen for event
   * @param {String} type - The ({@link IEvent}) type to listen for
   * @param {Function} listener - Receives a notification (an object that implements
   * the {@link IEvent} interface) when an event of the specified type occurs.
   */
  addEventListener: function () {},

  /**
   * Removes the specified listener previously registered with addEventListener.
   * @param {Chart} chart -Chart from which to remove the listener
   * @param {String} type - The ({@link IEvent}) type to remove
   * @param {Function} listener - The listener function to remove from the event target.
   */
  removeEventListener: function () {}
}, implementation);
/**
 * @interface IPlatform
 * Allows abstracting platform dependencies away from the chart
 * @borrows Chart.platform.acquireContext as acquireContext
 * @borrows Chart.platform.releaseContext as releaseContext
 * @borrows Chart.platform.addEventListener as addEventListener
 * @borrows Chart.platform.removeEventListener as removeEventListener
 */

/**
 * @interface IEvent
 * @prop {String} type - The event type name, possible values are:
 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
 */

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

defaults._set('global', {
  plugins: {}
});
/**
 * The plugin service singleton
 * @namespace Chart.plugins
 * @since 2.1.0
 */


module.exports = {
  /**
   * Globally registered plugins.
   * @private
   */
  _plugins: [],

  /**
   * This identifier is used to invalidate the descriptors cache attached to each chart
   * when a global plugin is registered or unregistered. In this case, the cache ID is
   * incremented and descriptors are regenerated during following API calls.
   * @private
   */
  _cacheId: 0,

  /**
   * Registers the given plugin(s) if not already registered.
   * @param {Array|Object} plugins plugin instance(s).
   */
  register: function (plugins) {
    var p = this._plugins;
    [].concat(plugins).forEach(function (plugin) {
      if (p.indexOf(plugin) === -1) {
        p.push(plugin);
      }
    });
    this._cacheId++;
  },

  /**
   * Unregisters the given plugin(s) only if registered.
   * @param {Array|Object} plugins plugin instance(s).
   */
  unregister: function (plugins) {
    var p = this._plugins;
    [].concat(plugins).forEach(function (plugin) {
      var idx = p.indexOf(plugin);

      if (idx !== -1) {
        p.splice(idx, 1);
      }
    });
    this._cacheId++;
  },

  /**
   * Remove all registered plugins.
   * @since 2.1.5
   */
  clear: function () {
    this._plugins = [];
    this._cacheId++;
  },

  /**
   * Returns the number of registered plugins?
   * @returns {Number}
   * @since 2.1.5
   */
  count: function () {
    return this._plugins.length;
  },

  /**
   * Returns all registered plugin instances.
   * @returns {Array} array of plugin objects.
   * @since 2.1.5
   */
  getAll: function () {
    return this._plugins;
  },

  /**
   * Calls enabled plugins for `chart` on the specified hook and with the given args.
   * This method immediately returns as soon as a plugin explicitly returns false. The
   * returned value can be used, for instance, to interrupt the current action.
   * @param {Object} chart - The chart instance for which plugins should be called.
   * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
   * @param {Array} [args] - Extra arguments to apply to the hook call.
   * @returns {Boolean} false if any of the plugins return false, else returns true.
   */
  notify: function (chart, hook, args) {
    var descriptors = this.descriptors(chart);
    var ilen = descriptors.length;
    var i, descriptor, plugin, params, method;

    for (i = 0; i < ilen; ++i) {
      descriptor = descriptors[i];
      plugin = descriptor.plugin;
      method = plugin[hook];

      if (typeof method === 'function') {
        params = [chart].concat(args || []);
        params.push(descriptor.options);

        if (method.apply(plugin, params) === false) {
          return false;
        }
      }
    }

    return true;
  },

  /**
   * Returns descriptors of enabled plugins for the given chart.
   * @returns {Array} [{ plugin, options }]
   * @private
   */
  descriptors: function (chart) {
    var cache = chart.$plugins || (chart.$plugins = {});

    if (cache.id === this._cacheId) {
      return cache.descriptors;
    }

    var plugins = [];
    var descriptors = [];
    var config = chart && chart.config || {};
    var options = config.options && config.options.plugins || {};

    this._plugins.concat(config.plugins || []).forEach(function (plugin) {
      var idx = plugins.indexOf(plugin);

      if (idx !== -1) {
        return;
      }

      var id = plugin.id;
      var opts = options[id];

      if (opts === false) {
        return;
      }

      if (opts === true) {
        opts = helpers.clone(defaults.global.plugins[id]);
      }

      plugins.push(plugin);
      descriptors.push({
        plugin: plugin,
        options: opts || {}
      });
    });

    cache.descriptors = descriptors;
    cache.id = this._cacheId;
    return descriptors;
  },

  /**
   * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
   * but in some cases, this reference can be changed by the user when updating options.
   * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
   * @private
   */
  _invalidate: function (chart) {
    delete chart.$plugins;
  }
};
/**
 * Plugin extension hooks.
 * @interface IPlugin
 * @since 2.1.0
 */

/**
 * @method IPlugin#beforeInit
 * @desc Called before initializing `chart`.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#afterInit
 * @desc Called after `chart` has been initialized and before the first update.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeUpdate
 * @desc Called before updating `chart`. If any plugin returns `false`, the update
 * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart update.
 */

/**
 * @method IPlugin#afterUpdate
 * @desc Called after `chart` has been updated and before rendering. Note that this
 * hook will not be called if the chart update has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeDatasetsUpdate
 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
 * the datasets update is cancelled until another `update` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} false to cancel the datasets update.
 * @since version 2.1.5
*/

/**
 * @method IPlugin#afterDatasetsUpdate
 * @desc Called after the `chart` datasets have been updated. Note that this hook
 * will not be called if the datasets update has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @since version 2.1.5
 */

/**
 * @method IPlugin#beforeDatasetUpdate
 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
 * returns `false`, the datasets update is cancelled until another `update` is triggered.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart datasets drawing.
 */

/**
 * @method IPlugin#afterDatasetUpdate
 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
 * that this hook will not be called if the datasets update has been previously cancelled.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeLayout
 * @desc Called before laying out `chart`. If any plugin returns `false`,
 * the layout update is cancelled until another `update` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart layout.
 */

/**
 * @method IPlugin#afterLayout
 * @desc Called after the `chart` has been layed out. Note that this hook will not
 * be called if the layout update has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeRender
 * @desc Called before rendering `chart`. If any plugin returns `false`,
 * the rendering is cancelled until another `render` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart rendering.
 */

/**
 * @method IPlugin#afterRender
 * @desc Called after the `chart` has been fully rendered (and animation completed). Note
 * that this hook will not be called if the rendering has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeDraw
 * @desc Called before drawing `chart` at every animation frame specified by the given
 * easing value. If any plugin returns `false`, the frame drawing is cancelled until
 * another `render` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart drawing.
 */

/**
 * @method IPlugin#afterDraw
 * @desc Called after the `chart` has been drawn for the specific easing value. Note
 * that this hook will not be called if the drawing has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeDatasetsDraw
 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
 * the datasets drawing is cancelled until another `render` is triggered.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart datasets drawing.
 */

/**
 * @method IPlugin#afterDatasetsDraw
 * @desc Called after the `chart` datasets have been drawn. Note that this hook
 * will not be called if the datasets drawing has been previously cancelled.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeDatasetDraw
 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
 * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
 * is cancelled until another `render` is triggered.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart datasets drawing.
 */

/**
 * @method IPlugin#afterDatasetDraw
 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
 * (datasets are drawn in the reverse order). Note that this hook will not be called
 * if the datasets drawing has been previously cancelled.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Number} args.index - The dataset index.
 * @param {Object} args.meta - The dataset metadata.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeTooltipDraw
 * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
 * the tooltip drawing is cancelled until another `render` is triggered.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Object} args.tooltip - The tooltip.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 * @returns {Boolean} `false` to cancel the chart tooltip drawing.
 */

/**
 * @method IPlugin#afterTooltipDraw
 * @desc Called after drawing the `tooltip`. Note that this hook will not
 * be called if the tooltip drawing has been previously cancelled.
 * @param {Chart} chart - The chart instance.
 * @param {Object} args - The call arguments.
 * @param {Object} args.tooltip - The tooltip.
 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#beforeEvent
 * @desc Called before processing the specified `event`. If any plugin returns `false`,
 * the event will be discarded.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {IEvent} event - The event object.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#afterEvent
 * @desc Called after the `event` has been consumed. Note that this hook
 * will not be called if the `event` has been previously discarded.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {IEvent} event - The event object.
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#resize
 * @desc Called after the chart as been resized.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
 * @param {Object} options - The plugin options.
 */

/**
 * @method IPlugin#destroy
 * @desc Called after the chart as been destroyed.
 * @param {Chart.Controller} chart - The chart instance.
 * @param {Object} options - The plugin options.
 */

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

defaults._set('global', {
  tooltips: {
    enabled: true,
    custom: null,
    mode: 'nearest',
    position: 'average',
    intersect: true,
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleFontStyle: 'bold',
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleFontColor: '#fff',
    titleAlign: 'left',
    bodySpacing: 2,
    bodyFontColor: '#fff',
    bodyAlign: 'left',
    footerFontStyle: 'bold',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFontColor: '#fff',
    footerAlign: 'left',
    yPadding: 6,
    xPadding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    multiKeyBackground: '#fff',
    displayColors: true,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    callbacks: {
      // Args are: (tooltipItems, data)
      beforeTitle: helpers.noop,
      title: function (tooltipItems, data) {
        // Pick first xLabel for now
        var title = '';
        var labels = data.labels;
        var labelCount = labels ? labels.length : 0;

        if (tooltipItems.length > 0) {
          var item = tooltipItems[0];

          if (item.xLabel) {
            title = item.xLabel;
          } else if (labelCount > 0 && item.index < labelCount) {
            title = labels[item.index];
          }
        }

        return title;
      },
      afterTitle: helpers.noop,
      // Args are: (tooltipItems, data)
      beforeBody: helpers.noop,
      // Args are: (tooltipItem, data)
      beforeLabel: helpers.noop,
      label: function (tooltipItem, data) {
        var label = data.datasets[tooltipItem.datasetIndex].label || '';

        if (label) {
          label += ': ';
        }

        label += tooltipItem.yLabel;
        return label;
      },
      labelColor: function (tooltipItem, chart) {
        var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
        var activeElement = meta.data[tooltipItem.index];
        var view = activeElement._view;
        return {
          borderColor: view.borderColor,
          backgroundColor: view.backgroundColor
        };
      },
      labelTextColor: function () {
        return this._options.bodyFontColor;
      },
      afterLabel: helpers.noop,
      // Args are: (tooltipItems, data)
      afterBody: helpers.noop,
      // Args are: (tooltipItems, data)
      beforeFooter: helpers.noop,
      footer: helpers.noop,
      afterFooter: helpers.noop
    }
  }
});

var positioners = {
  /**
   * Average mode places the tooltip at the average position of the elements shown
   * @function Chart.Tooltip.positioners.average
   * @param elements {ChartElement[]} the elements being displayed in the tooltip
   * @returns {Point} tooltip position
   */
  average: function (elements) {
    if (!elements.length) {
      return false;
    }

    var i, len;
    var x = 0;
    var y = 0;
    var count = 0;

    for (i = 0, len = elements.length; i < len; ++i) {
      var el = elements[i];

      if (el && el.hasValue()) {
        var pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }

    return {
      x: Math.round(x / count),
      y: Math.round(y / count)
    };
  },

  /**
   * Gets the tooltip position nearest of the item nearest to the event position
   * @function Chart.Tooltip.positioners.nearest
   * @param elements {Chart.Element[]} the tooltip elements
   * @param eventPosition {Point} the position of the event in canvas coordinates
   * @returns {Point} the tooltip position
   */
  nearest: function (elements, eventPosition) {
    var x = eventPosition.x;
    var y = eventPosition.y;
    var minDistance = Number.POSITIVE_INFINITY;
    var i, len, nearestElement;

    for (i = 0, len = elements.length; i < len; ++i) {
      var el = elements[i];

      if (el && el.hasValue()) {
        var center = el.getCenterPoint();
        var d = helpers.distanceBetweenPoints(eventPosition, center);

        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }

    if (nearestElement) {
      var tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }

    return {
      x: x,
      y: y
    };
  }
};
/**
 * Helper method to merge the opacity into a color
 */

function mergeOpacity(colorString, opacity) {
  var color = helpers.color(colorString);
  return color.alpha(opacity * color.alpha()).rgbaString();
} // Helper to push or concat based on if the 2nd parameter is an array or not


function pushOrConcat(base, toPush) {
  if (toPush) {
    if (helpers.isArray(toPush)) {
      // base = base.concat(toPush);
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }

  return base;
}
/**
 * Returns array of strings split by newline
 * @param {String} value - The value to split by newline.
 * @returns {Array} value if newline present - Returned from String split() method
 * @function
 */


function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }

  return str;
} // Private helper to create a tooltip item model
// @param element : the chart element (point, arc, bar) to create the tooltip item for
// @return : new tooltip item


function createTooltipItem(element) {
  var xScale = element._xScale;
  var yScale = element._yScale || element._scale; // handle radar || polarArea charts

  var index = element._index;
  var datasetIndex = element._datasetIndex;
  return {
    xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
    yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
    index: index,
    datasetIndex: datasetIndex,
    x: element._model.x,
    y: element._model.y
  };
}
/**
 * Helper to get the reset model for the tooltip
 * @param tooltipOpts {Object} the tooltip options
 */


function getBaseModel(tooltipOpts) {
  var globalDefaults = defaults.global;
  var valueOrDefault = helpers.valueOrDefault;
  return {
    // Positioning
    xPadding: tooltipOpts.xPadding,
    yPadding: tooltipOpts.yPadding,
    xAlign: tooltipOpts.xAlign,
    yAlign: tooltipOpts.yAlign,
    // Body
    bodyFontColor: tooltipOpts.bodyFontColor,
    _bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
    _bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
    _bodyAlign: tooltipOpts.bodyAlign,
    bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
    bodySpacing: tooltipOpts.bodySpacing,
    // Title
    titleFontColor: tooltipOpts.titleFontColor,
    _titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
    _titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
    titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
    _titleAlign: tooltipOpts.titleAlign,
    titleSpacing: tooltipOpts.titleSpacing,
    titleMarginBottom: tooltipOpts.titleMarginBottom,
    // Footer
    footerFontColor: tooltipOpts.footerFontColor,
    _footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
    _footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
    footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
    _footerAlign: tooltipOpts.footerAlign,
    footerSpacing: tooltipOpts.footerSpacing,
    footerMarginTop: tooltipOpts.footerMarginTop,
    // Appearance
    caretSize: tooltipOpts.caretSize,
    cornerRadius: tooltipOpts.cornerRadius,
    backgroundColor: tooltipOpts.backgroundColor,
    opacity: 0,
    legendColorBackground: tooltipOpts.multiKeyBackground,
    displayColors: tooltipOpts.displayColors,
    borderColor: tooltipOpts.borderColor,
    borderWidth: tooltipOpts.borderWidth
  };
}
/**
 * Get the size of the tooltip
 */


function getTooltipSize(tooltip, model) {
  var ctx = tooltip._chart.ctx;
  var height = model.yPadding * 2; // Tooltip Padding

  var width = 0; // Count of all lines in the body

  var body = model.body;
  var combinedBodyLength = body.reduce(function (count, bodyItem) {
    return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
  }, 0);
  combinedBodyLength += model.beforeBody.length + model.afterBody.length;
  var titleLineCount = model.title.length;
  var footerLineCount = model.footer.length;
  var titleFontSize = model.titleFontSize;
  var bodyFontSize = model.bodyFontSize;
  var footerFontSize = model.footerFontSize;
  height += titleLineCount * titleFontSize; // Title Lines

  height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

  height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

  height += combinedBodyLength * bodyFontSize; // Body Lines

  height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

  height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

  height += footerLineCount * footerFontSize; // Footer Lines

  height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
  // Title width

  var widthPadding = 0;

  var maxLineWidth = function (line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };

  ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
  helpers.each(model.title, maxLineWidth); // Body width

  ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
  helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

  widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
  helpers.each(body, function (bodyItem) {
    helpers.each(bodyItem.before, maxLineWidth);
    helpers.each(bodyItem.lines, maxLineWidth);
    helpers.each(bodyItem.after, maxLineWidth);
  }); // Reset back to 0

  widthPadding = 0; // Footer width

  ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
  helpers.each(model.footer, maxLineWidth); // Add padding

  width += 2 * model.xPadding;
  return {
    width: width,
    height: height
  };
}
/**
 * Helper to get the alignment of a tooltip given the size
 */


function determineAlignment(tooltip, size) {
  var model = tooltip._model;
  var chart = tooltip._chart;
  var chartArea = tooltip._chart.chartArea;
  var xAlign = 'center';
  var yAlign = 'center';

  if (model.y < size.height) {
    yAlign = 'top';
  } else if (model.y > chart.height - size.height) {
    yAlign = 'bottom';
  }

  var lf, rf; // functions to determine left, right alignment

  var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

  var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

  var midX = (chartArea.left + chartArea.right) / 2;
  var midY = (chartArea.top + chartArea.bottom) / 2;

  if (yAlign === 'center') {
    lf = function (x) {
      return x <= midX;
    };

    rf = function (x) {
      return x > midX;
    };
  } else {
    lf = function (x) {
      return x <= size.width / 2;
    };

    rf = function (x) {
      return x >= chart.width - size.width / 2;
    };
  }

  olf = function (x) {
    return x + size.width + model.caretSize + model.caretPadding > chart.width;
  };

  orf = function (x) {
    return x - size.width - model.caretSize - model.caretPadding < 0;
  };

  yf = function (y) {
    return y <= midY ? 'top' : 'bottom';
  };

  if (lf(model.x)) {
    xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

    if (olf(model.x)) {
      xAlign = 'center';
      yAlign = yf(model.y);
    }
  } else if (rf(model.x)) {
    xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

    if (orf(model.x)) {
      xAlign = 'center';
      yAlign = yf(model.y);
    }
  }

  var opts = tooltip._options;
  return {
    xAlign: opts.xAlign ? opts.xAlign : xAlign,
    yAlign: opts.yAlign ? opts.yAlign : yAlign
  };
}
/**
 * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
 */


function getBackgroundPoint(vm, size, alignment, chart) {
  // Background Position
  var x = vm.x;
  var y = vm.y;
  var caretSize = vm.caretSize;
  var caretPadding = vm.caretPadding;
  var cornerRadius = vm.cornerRadius;
  var xAlign = alignment.xAlign;
  var yAlign = alignment.yAlign;
  var paddingAndSize = caretSize + caretPadding;
  var radiusAndPadding = cornerRadius + caretPadding;

  if (xAlign === 'right') {
    x -= size.width;
  } else if (xAlign === 'center') {
    x -= size.width / 2;

    if (x + size.width > chart.width) {
      x = chart.width - size.width;
    }

    if (x < 0) {
      x = 0;
    }
  }

  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= size.height + paddingAndSize;
  } else {
    y -= size.height / 2;
  }

  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= radiusAndPadding;
  } else if (xAlign === 'right') {
    x += radiusAndPadding;
  }

  return {
    x: x,
    y: y
  };
}
/**
 * Helper to build before and after body lines
 */


function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}

var exports = module.exports = Element.extend({
  initialize: function () {
    this._model = getBaseModel(this._options);
    this._lastActive = [];
  },
  // Get the title
  // Args are: (tooltipItem, data)
  getTitle: function () {
    var me = this;
    var opts = me._options;
    var callbacks = opts.callbacks;
    var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
    var title = callbacks.title.apply(me, arguments);
    var afterTitle = callbacks.afterTitle.apply(me, arguments);
    var lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  },
  // Args are: (tooltipItem, data)
  getBeforeBody: function () {
    return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
  },
  // Args are: (tooltipItem, data)
  getBody: function (tooltipItems, data) {
    var me = this;
    var callbacks = me._options.callbacks;
    var bodyItems = [];
    helpers.each(tooltipItems, function (tooltipItem) {
      var bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
      pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
      pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  },
  // Args are: (tooltipItem, data)
  getAfterBody: function () {
    return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
  },
  // Get the footer and beforeFooter and afterFooter lines
  // Args are: (tooltipItem, data)
  getFooter: function () {
    var me = this;
    var callbacks = me._options.callbacks;
    var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
    var footer = callbacks.footer.apply(me, arguments);
    var afterFooter = callbacks.afterFooter.apply(me, arguments);
    var lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  },
  update: function (changed) {
    var me = this;
    var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
    // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
    // which breaks any animations.

    var existingModel = me._model;
    var model = me._model = getBaseModel(opts);
    var active = me._active;
    var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

    var alignment = {
      xAlign: existingModel.xAlign,
      yAlign: existingModel.yAlign
    };
    var backgroundPoint = {
      x: existingModel.x,
      y: existingModel.y
    };
    var tooltipSize = {
      width: existingModel.width,
      height: existingModel.height
    };
    var tooltipPosition = {
      x: existingModel.caretX,
      y: existingModel.caretY
    };
    var i, len;

    if (active.length) {
      model.opacity = 1;
      var labelColors = [];
      var labelTextColors = [];
      tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
      var tooltipItems = [];

      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(active[i]));
      } // If the user provided a filter function, use it to modify the tooltip items


      if (opts.filter) {
        tooltipItems = tooltipItems.filter(function (a) {
          return opts.filter(a, data);
        });
      } // If the user provided a sorting function, use it to modify the tooltip items


      if (opts.itemSort) {
        tooltipItems = tooltipItems.sort(function (a, b) {
          return opts.itemSort(a, b, data);
        });
      } // Determine colors for boxes


      helpers.each(tooltipItems, function (tooltipItem) {
        labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
        labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
      }); // Build the Text Lines

      model.title = me.getTitle(tooltipItems, data);
      model.beforeBody = me.getBeforeBody(tooltipItems, data);
      model.body = me.getBody(tooltipItems, data);
      model.afterBody = me.getAfterBody(tooltipItems, data);
      model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

      model.x = Math.round(tooltipPosition.x);
      model.y = Math.round(tooltipPosition.y);
      model.caretPadding = opts.caretPadding;
      model.labelColors = labelColors;
      model.labelTextColors = labelTextColors; // data points

      model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

      tooltipSize = getTooltipSize(this, model);
      alignment = determineAlignment(this, tooltipSize); // Final Size and Position

      backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
    } else {
      model.opacity = 0;
    }

    model.xAlign = alignment.xAlign;
    model.yAlign = alignment.yAlign;
    model.x = backgroundPoint.x;
    model.y = backgroundPoint.y;
    model.width = tooltipSize.width;
    model.height = tooltipSize.height; // Point where the caret on the tooltip points to

    model.caretX = tooltipPosition.x;
    model.caretY = tooltipPosition.y;
    me._model = model;

    if (changed && opts.custom) {
      opts.custom.call(me, model);
    }

    return me;
  },
  drawCaret: function (tooltipPoint, size) {
    var ctx = this._chart.ctx;
    var vm = this._view;
    var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  },
  getCaretPosition: function (tooltipPoint, size, vm) {
    var x1, x2, x3, y1, y2, y3;
    var caretSize = vm.caretSize;
    var cornerRadius = vm.cornerRadius;
    var xAlign = vm.xAlign;
    var yAlign = vm.yAlign;
    var ptX = tooltipPoint.x;
    var ptY = tooltipPoint.y;
    var width = size.width;
    var height = size.height;

    if (yAlign === 'center') {
      y2 = ptY + height / 2;

      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        x3 = x1;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        x3 = x1;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
    } else {
      if (xAlign === 'left') {
        x2 = ptX + cornerRadius + caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else if (xAlign === 'right') {
        x2 = ptX + width - cornerRadius - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        x2 = vm.caretX;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      }

      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        y3 = y1;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        y3 = y1; // invert drawing order

        var tmp = x3;
        x3 = x1;
        x1 = tmp;
      }
    }

    return {
      x1: x1,
      x2: x2,
      x3: x3,
      y1: y1,
      y2: y2,
      y3: y3
    };
  },
  drawTitle: function (pt, vm, ctx, opacity) {
    var title = vm.title;

    if (title.length) {
      ctx.textAlign = vm._titleAlign;
      ctx.textBaseline = 'top';
      var titleFontSize = vm.titleFontSize;
      var titleSpacing = vm.titleSpacing;
      ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
      ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
      var i, len;

      for (i = 0, len = title.length; i < len; ++i) {
        ctx.fillText(title[i], pt.x, pt.y);
        pt.y += titleFontSize + titleSpacing; // Line Height and spacing

        if (i + 1 === title.length) {
          pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
        }
      }
    }
  },
  drawBody: function (pt, vm, ctx, opacity) {
    var bodyFontSize = vm.bodyFontSize;
    var bodySpacing = vm.bodySpacing;
    var body = vm.body;
    ctx.textAlign = vm._bodyAlign;
    ctx.textBaseline = 'top';
    ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily); // Before Body

    var xLinePadding = 0;

    var fillLineOfText = function (line) {
      ctx.fillText(line, pt.x + xLinePadding, pt.y);
      pt.y += bodyFontSize + bodySpacing;
    }; // Before body lines


    ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
    helpers.each(vm.beforeBody, fillLineOfText);
    var drawColorBoxes = vm.displayColors;
    xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0; // Draw body lines now

    helpers.each(body, function (bodyItem, i) {
      var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
      ctx.fillStyle = textColor;
      helpers.each(bodyItem.before, fillLineOfText);
      helpers.each(bodyItem.lines, function (line) {
        // Draw Legend-like boxes if needed
        if (drawColorBoxes) {
          // Fill a white rect so that colours merge nicely if the opacity is < 1
          ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
          ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize); // Border

          ctx.lineWidth = 1;
          ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
          ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize); // Inner square

          ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
          ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
          ctx.fillStyle = textColor;
        }

        fillLineOfText(line);
      });
      helpers.each(bodyItem.after, fillLineOfText);
    }); // Reset back to 0 for after body

    xLinePadding = 0; // After body lines

    helpers.each(vm.afterBody, fillLineOfText);
    pt.y -= bodySpacing; // Remove last body spacing
  },
  drawFooter: function (pt, vm, ctx, opacity) {
    var footer = vm.footer;

    if (footer.length) {
      pt.y += vm.footerMarginTop;
      ctx.textAlign = vm._footerAlign;
      ctx.textBaseline = 'top';
      ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
      ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
      helpers.each(footer, function (line) {
        ctx.fillText(line, pt.x, pt.y);
        pt.y += vm.footerFontSize + vm.footerSpacing;
      });
    }
  },
  drawBackground: function (pt, vm, ctx, tooltipSize, opacity) {
    ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
    ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
    ctx.lineWidth = vm.borderWidth;
    var xAlign = vm.xAlign;
    var yAlign = vm.yAlign;
    var x = pt.x;
    var y = pt.y;
    var width = tooltipSize.width;
    var height = tooltipSize.height;
    var radius = vm.cornerRadius;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);

    if (yAlign === 'top') {
      this.drawCaret(pt, tooltipSize);
    }

    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, tooltipSize);
    }

    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

    if (yAlign === 'bottom') {
      this.drawCaret(pt, tooltipSize);
    }

    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, tooltipSize);
    }

    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();

    if (vm.borderWidth > 0) {
      ctx.stroke();
    }
  },
  draw: function () {
    var ctx = this._chart.ctx;
    var vm = this._view;

    if (vm.opacity === 0) {
      return;
    }

    var tooltipSize = {
      width: vm.width,
      height: vm.height
    };
    var pt = {
      x: vm.x,
      y: vm.y
    }; // IE11/Edge does not like very small opacities, so snap to 0

    var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

    var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

    if (this._options.enabled && hasTooltipContent) {
      // Draw Background
      this.drawBackground(pt, vm, ctx, tooltipSize, opacity); // Draw Title, Body, and Footer

      pt.x += vm.xPadding;
      pt.y += vm.yPadding; // Titles

      this.drawTitle(pt, vm, ctx, opacity); // Body

      this.drawBody(pt, vm, ctx, opacity); // Footer

      this.drawFooter(pt, vm, ctx, opacity);
    }
  },

  /**
   * Handle an event
   * @private
   * @param {IEvent} event - The event to handle
   * @returns {Boolean} true if the tooltip changed
   */
  handleEvent: function (e) {
    var me = this;
    var options = me._options;
    var changed = false;
    me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

    if (e.type === 'mouseout') {
      me._active = [];
    } else {
      me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
    } // Remember Last Actives


    changed = !helpers.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

    if (changed) {
      me._lastActive = me._active;

      if (options.enabled || options.custom) {
        me._eventPosition = {
          x: e.x,
          y: e.y
        };
        me.update(true);
        me.pivot();
      }
    }

    return changed;
  }
});
/**
 * @namespace Chart.Tooltip.positioners
 */

exports.positioners = positioners;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var af = moment.defineLocale('af', {
    months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM: function (input) {
      return /^nm$/i.test(input);
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'vm' : 'VM';
      } else {
        return isLower ? 'nm' : 'NM';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Vandag om] LT',
      nextDay: '[Môre om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[Gister om] LT',
      lastWeek: '[Laas] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oor %s',
      past: '%s gelede',
      s: '\'n paar sekondes',
      ss: '%d sekondes',
      m: '\'n minuut',
      mm: '%d minute',
      h: '\'n uur',
      hh: '%d ure',
      d: '\'n dag',
      dd: '%d dae',
      M: '\'n maand',
      MM: '%d maande',
      y: '\'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
    },
    week: {
      dow: 1,
      // Maandag is die eerste dag van die week.
      doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.

    }
  });
  return af;
});

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '١',
    '2': '٢',
    '3': '٣',
    '4': '٤',
    '5': '٥',
    '6': '٦',
    '7': '٧',
    '8': '٨',
    '9': '٩',
    '0': '٠'
  },
      numberMap = {
    '١': '1',
    '٢': '2',
    '٣': '3',
    '٤': '4',
    '٥': '5',
    '٦': '6',
    '٧': '7',
    '٨': '8',
    '٩': '9',
    '٠': '0'
  },
      pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
    m: ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
    h: ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
    d: ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
    M: ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
    y: ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
  },
      pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'];

  var ar = moment.defineLocale('ar', {
    months: months,
    monthsShort: months,
    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ص|م/,
    isPM: function (input) {
      return 'م' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ص';
      } else {
        return 'م';
      }
    },
    calendar: {
      sameDay: '[اليوم عند الساعة] LT',
      nextDay: '[غدًا عند الساعة] LT',
      nextWeek: 'dddd [عند الساعة] LT',
      lastDay: '[أمس عند الساعة] LT',
      lastWeek: 'dddd [عند الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'بعد %s',
      past: 'منذ %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function (string) {
      return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
        return numberMap[match];
      }).replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '،');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return ar;
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var arDz = moment.defineLocale('ar-dz', {
    months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[اليوم على الساعة] LT',
      nextDay: '[غدا على الساعة] LT',
      nextWeek: 'dddd [على الساعة] LT',
      lastDay: '[أمس على الساعة] LT',
      lastWeek: 'dddd [على الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'في %s',
      past: 'منذ %s',
      s: 'ثوان',
      ss: '%d ثانية',
      m: 'دقيقة',
      mm: '%d دقائق',
      h: 'ساعة',
      hh: '%d ساعات',
      d: 'يوم',
      dd: '%d أيام',
      M: 'شهر',
      MM: '%d أشهر',
      y: 'سنة',
      yy: '%d سنوات'
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arDz;
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var arKw = moment.defineLocale('ar-kw', {
    months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[اليوم على الساعة] LT',
      nextDay: '[غدا على الساعة] LT',
      nextWeek: 'dddd [على الساعة] LT',
      lastDay: '[أمس على الساعة] LT',
      lastWeek: 'dddd [على الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'في %s',
      past: 'منذ %s',
      s: 'ثوان',
      ss: '%d ثانية',
      m: 'دقيقة',
      mm: '%d دقائق',
      h: 'ساعة',
      hh: '%d ساعات',
      d: 'يوم',
      dd: '%d أيام',
      M: 'شهر',
      MM: '%d أشهر',
      y: 'سنة',
      yy: '%d سنوات'
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arKw;
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    '0': '0'
  },
      pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
    m: ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
    h: ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
    d: ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
    M: ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
    y: ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
  },
      pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'];

  var arLy = moment.defineLocale('ar-ly', {
    months: months,
    monthsShort: months,
    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ص|م/,
    isPM: function (input) {
      return 'م' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ص';
      } else {
        return 'م';
      }
    },
    calendar: {
      sameDay: '[اليوم عند الساعة] LT',
      nextDay: '[غدًا عند الساعة] LT',
      nextWeek: 'dddd [عند الساعة] LT',
      lastDay: '[أمس عند الساعة] LT',
      lastWeek: 'dddd [عند الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'بعد %s',
      past: 'منذ %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function (string) {
      return string.replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '،');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arLy;
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var arMa = moment.defineLocale('ar-ma', {
    months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[اليوم على الساعة] LT',
      nextDay: '[غدا على الساعة] LT',
      nextWeek: 'dddd [على الساعة] LT',
      lastDay: '[أمس على الساعة] LT',
      lastWeek: 'dddd [على الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'في %s',
      past: 'منذ %s',
      s: 'ثوان',
      ss: '%d ثانية',
      m: 'دقيقة',
      mm: '%d دقائق',
      h: 'ساعة',
      hh: '%d ساعات',
      d: 'يوم',
      dd: '%d أيام',
      M: 'شهر',
      MM: '%d أشهر',
      y: 'سنة',
      yy: '%d سنوات'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arMa;
});

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '١',
    '2': '٢',
    '3': '٣',
    '4': '٤',
    '5': '٥',
    '6': '٦',
    '7': '٧',
    '8': '٨',
    '9': '٩',
    '0': '٠'
  },
      numberMap = {
    '١': '1',
    '٢': '2',
    '٣': '3',
    '٤': '4',
    '٥': '5',
    '٦': '6',
    '٧': '7',
    '٨': '8',
    '٩': '9',
    '٠': '0'
  };
  var arSa = moment.defineLocale('ar-sa', {
    months: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    monthsShort: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ص|م/,
    isPM: function (input) {
      return 'م' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ص';
      } else {
        return 'م';
      }
    },
    calendar: {
      sameDay: '[اليوم على الساعة] LT',
      nextDay: '[غدا على الساعة] LT',
      nextWeek: 'dddd [على الساعة] LT',
      lastDay: '[أمس على الساعة] LT',
      lastWeek: 'dddd [على الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'في %s',
      past: 'منذ %s',
      s: 'ثوان',
      ss: '%d ثانية',
      m: 'دقيقة',
      mm: '%d دقائق',
      h: 'ساعة',
      hh: '%d ساعات',
      d: 'يوم',
      dd: '%d أيام',
      M: 'شهر',
      MM: '%d أشهر',
      y: 'سنة',
      yy: '%d سنوات'
    },
    preparse: function (string) {
      return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
        return numberMap[match];
      }).replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '،');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return arSa;
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var arTn = moment.defineLocale('ar-tn', {
    months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[اليوم على الساعة] LT',
      nextDay: '[غدا على الساعة] LT',
      nextWeek: 'dddd [على الساعة] LT',
      lastDay: '[أمس على الساعة] LT',
      lastWeek: 'dddd [على الساعة] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'في %s',
      past: 'منذ %s',
      s: 'ثوان',
      ss: '%d ثانية',
      m: 'دقيقة',
      mm: '%d دقائق',
      h: 'ساعة',
      hh: '%d ساعات',
      d: 'يوم',
      dd: '%d أيام',
      M: 'شهر',
      MM: '%d أشهر',
      y: 'سنة',
      yy: '%d سنوات'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arTn;
});

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-üncü',
    4: '-üncü',
    100: '-üncü',
    6: '-ncı',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-ıncı',
    90: '-ıncı'
  };
  var az = moment.defineLocale('az', {
    months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays: 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
    weekdaysShort: 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
    weekdaysMin: 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugün saat] LT',
      nextDay: '[sabah saat] LT',
      nextWeek: '[gələn həftə] dddd [saat] LT',
      lastDay: '[dünən] LT',
      lastWeek: '[keçən həftə] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s əvvəl',
      s: 'birneçə saniyə',
      ss: '%d saniyə',
      m: 'bir dəqiqə',
      mm: '%d dəqiqə',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gün',
      dd: '%d gün',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir il',
      yy: '%d il'
    },
    meridiemParse: /gecə|səhər|gündüz|axşam/,
    isPM: function (input) {
      return /^(gündüz|axşam)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'gecə';
      } else if (hour < 12) {
        return 'səhər';
      } else if (hour < 17) {
        return 'gündüz';
      } else {
        return 'axşam';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
    ordinal: function (number) {
      if (number === 0) {
        // special case for zero
        return number + '-ıncı';
      }

      var a = number % 10,
          b = number % 100 - a,
          c = number >= 100 ? 100 : null;
      return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return az;
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
      'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
      'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
      'dd': 'дзень_дні_дзён',
      'MM': 'месяц_месяцы_месяцаў',
      'yy': 'год_гады_гадоў'
    };

    if (key === 'm') {
      return withoutSuffix ? 'хвіліна' : 'хвіліну';
    } else if (key === 'h') {
      return withoutSuffix ? 'гадзіна' : 'гадзіну';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  var be = moment.defineLocale('be', {
    months: {
      format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
      standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
    },
    monthsShort: 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
    weekdays: {
      format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
      standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
      isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/
    },
    weekdaysShort: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
    weekdaysMin: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY г.',
      LLL: 'D MMMM YYYY г., HH:mm',
      LLLL: 'dddd, D MMMM YYYY г., HH:mm'
    },
    calendar: {
      sameDay: '[Сёння ў] LT',
      nextDay: '[Заўтра ў] LT',
      lastDay: '[Учора ў] LT',
      nextWeek: function () {
        return '[У] dddd [ў] LT';
      },
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return '[У мінулую] dddd [ў] LT';

          case 1:
          case 2:
          case 4:
            return '[У мінулы] dddd [ў] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'праз %s',
      past: '%s таму',
      s: 'некалькі секунд',
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithPlural,
      hh: relativeTimeWithPlural,
      d: 'дзень',
      dd: relativeTimeWithPlural,
      M: 'месяц',
      MM: relativeTimeWithPlural,
      y: 'год',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /ночы|раніцы|дня|вечара/,
    isPM: function (input) {
      return /^(дня|вечара)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'ночы';
      } else if (hour < 12) {
        return 'раніцы';
      } else if (hour < 17) {
        return 'дня';
      } else {
        return 'вечара';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-і' : number + '-ы';

        case 'D':
          return number + '-га';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return be;
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var bg = moment.defineLocale('bg', {
    months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
    monthsShort: 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
    weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
    weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
    weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Днес в] LT',
      nextDay: '[Утре в] LT',
      nextWeek: 'dddd [в] LT',
      lastDay: '[Вчера в] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[В изминалата] dddd [в] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[В изминалия] dddd [в] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'след %s',
      past: 'преди %s',
      s: 'няколко секунди',
      ss: '%d секунди',
      m: 'минута',
      mm: '%d минути',
      h: 'час',
      hh: '%d часа',
      d: 'ден',
      dd: '%d дни',
      M: 'месец',
      MM: '%d месеца',
      y: 'година',
      yy: '%d години'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
    ordinal: function (number) {
      var lastDigit = number % 10,
          last2Digits = number % 100;

      if (number === 0) {
        return number + '-ев';
      } else if (last2Digits === 0) {
        return number + '-ен';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-ти';
      } else if (lastDigit === 1) {
        return number + '-ви';
      } else if (lastDigit === 2) {
        return number + '-ри';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-ми';
      } else {
        return number + '-ти';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return bg;
});

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var bm = moment.defineLocale('bm', {
    months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort: 'Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des'.split('_'),
    weekdays: 'Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort: 'Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'MMMM [tile] D [san] YYYY',
      LLL: 'MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
      LLLL: 'dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm'
    },
    calendar: {
      sameDay: '[Bi lɛrɛ] LT',
      nextDay: '[Sini lɛrɛ] LT',
      nextWeek: 'dddd [don lɛrɛ] LT',
      lastDay: '[Kunu lɛrɛ] LT',
      lastWeek: 'dddd [tɛmɛnen lɛrɛ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s kɔnɔ',
      past: 'a bɛ %s bɔ',
      s: 'sanga dama dama',
      ss: 'sekondi %d',
      m: 'miniti kelen',
      mm: 'miniti %d',
      h: 'lɛrɛ kelen',
      hh: 'lɛrɛ %d',
      d: 'tile kelen',
      dd: 'tile %d',
      M: 'kalo kelen',
      MM: 'kalo %d',
      y: 'san kelen',
      yy: 'san %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return bm;
});

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '১',
    '2': '২',
    '3': '৩',
    '4': '৪',
    '5': '৫',
    '6': '৬',
    '7': '৭',
    '8': '৮',
    '9': '৯',
    '0': '০'
  },
      numberMap = {
    '১': '1',
    '২': '2',
    '৩': '3',
    '৪': '4',
    '৫': '5',
    '৬': '6',
    '৭': '7',
    '৮': '8',
    '৯': '9',
    '০': '0'
  };
  var bn = moment.defineLocale('bn', {
    months: 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
    monthsShort: 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
    weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
    weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
    weekdaysMin: 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
    longDateFormat: {
      LT: 'A h:mm সময়',
      LTS: 'A h:mm:ss সময়',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm সময়',
      LLLL: 'dddd, D MMMM YYYY, A h:mm সময়'
    },
    calendar: {
      sameDay: '[আজ] LT',
      nextDay: '[আগামীকাল] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[গতকাল] LT',
      lastWeek: '[গত] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s পরে',
      past: '%s আগে',
      s: 'কয়েক সেকেন্ড',
      ss: '%d সেকেন্ড',
      m: 'এক মিনিট',
      mm: '%d মিনিট',
      h: 'এক ঘন্টা',
      hh: '%d ঘন্টা',
      d: 'এক দিন',
      dd: '%d দিন',
      M: 'এক মাস',
      MM: '%d মাস',
      y: 'এক বছর',
      yy: '%d বছর'
    },
    preparse: function (string) {
      return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'রাত' && hour >= 4 || meridiem === 'দুপুর' && hour < 5 || meridiem === 'বিকাল') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'রাত';
      } else if (hour < 10) {
        return 'সকাল';
      } else if (hour < 17) {
        return 'দুপুর';
      } else if (hour < 20) {
        return 'বিকাল';
      } else {
        return 'রাত';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bn;
});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '༡',
    '2': '༢',
    '3': '༣',
    '4': '༤',
    '5': '༥',
    '6': '༦',
    '7': '༧',
    '8': '༨',
    '9': '༩',
    '0': '༠'
  },
      numberMap = {
    '༡': '1',
    '༢': '2',
    '༣': '3',
    '༤': '4',
    '༥': '5',
    '༦': '6',
    '༧': '7',
    '༨': '8',
    '༩': '9',
    '༠': '0'
  };
  var bo = moment.defineLocale('bo', {
    months: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
    monthsShort: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
    weekdays: 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
    weekdaysShort: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
    weekdaysMin: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[དི་རིང] LT',
      nextDay: '[སང་ཉིན] LT',
      nextWeek: '[བདུན་ཕྲག་རྗེས་མ], LT',
      lastDay: '[ཁ་སང] LT',
      lastWeek: '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ལ་',
      past: '%s སྔན་ལ',
      s: 'ལམ་སང',
      ss: '%d སྐར་ཆ།',
      m: 'སྐར་མ་གཅིག',
      mm: '%d སྐར་མ',
      h: 'ཆུ་ཚོད་གཅིག',
      hh: '%d ཆུ་ཚོད',
      d: 'ཉིན་གཅིག',
      dd: '%d ཉིན་',
      M: 'ཟླ་བ་གཅིག',
      MM: '%d ཟླ་བ',
      y: 'ལོ་གཅིག',
      yy: '%d ལོ'
    },
    preparse: function (string) {
      return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'མཚན་མོ' && hour >= 4 || meridiem === 'ཉིན་གུང' && hour < 5 || meridiem === 'དགོང་དག') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'མཚན་མོ';
      } else if (hour < 10) {
        return 'ཞོགས་ཀས';
      } else if (hour < 17) {
        return 'ཉིན་གུང';
      } else if (hour < 20) {
        return 'དགོང་དག';
      } else {
        return 'མཚན་མོ';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bo;
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
      'mm': 'munutenn',
      'MM': 'miz',
      'dd': 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
  }

  function specialMutationForYears(number) {
    switch (lastNumber(number)) {
      case 1:
      case 3:
      case 4:
      case 5:
      case 9:
        return number + ' bloaz';

      default:
        return number + ' vloaz';
    }
  }

  function lastNumber(number) {
    if (number > 9) {
      return lastNumber(number % 10);
    }

    return number;
  }

  function mutation(text, number) {
    if (number === 2) {
      return softMutation(text);
    }

    return text;
  }

  function softMutation(text) {
    var mutationTable = {
      'm': 'v',
      'b': 'v',
      'd': 'z'
    };

    if (mutationTable[text.charAt(0)] === undefined) {
      return text;
    }

    return mutationTable[text.charAt(0)] + text.substring(1);
  }

  var br = moment.defineLocale('br', {
    months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h[e]mm A',
      LTS: 'h[e]mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [a viz] MMMM YYYY',
      LLL: 'D [a viz] MMMM YYYY h[e]mm A',
      LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A'
    },
    calendar: {
      sameDay: '[Hiziv da] LT',
      nextDay: '[Warc\'hoazh da] LT',
      nextWeek: 'dddd [da] LT',
      lastDay: '[Dec\'h da] LT',
      lastWeek: 'dddd [paset da] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'a-benn %s',
      past: '%s \'zo',
      s: 'un nebeud segondennoù',
      ss: '%d eilenn',
      m: 'ur vunutenn',
      mm: relativeTimeWithMutation,
      h: 'un eur',
      hh: '%d eur',
      d: 'un devezh',
      dd: relativeTimeWithMutation,
      M: 'ur miz',
      MM: relativeTimeWithMutation,
      y: 'ur bloaz',
      yy: specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
    ordinal: function (number) {
      var output = number === 1 ? 'añ' : 'vet';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return br;
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';

      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';

      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }

        return result;

      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }

        return result;

      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }

        return result;

      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }

        return result;
    }
  }

  var bs = moment.defineLocale('bs', {
    months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jučer u] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prošlu] dddd [u] LT';

          case 6:
            return '[prošle] [subote] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[prošli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return bs;
});

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ca = moment.defineLocale('ca', {
    months: {
      standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
      format: 'de gener_de febrer_de març_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a les] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextDay: function () {
        return '[demà a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastDay: function () {
        return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'd\'aquí %s',
      past: 'fa %s',
      s: 'uns segons',
      ss: '%d segons',
      m: 'un minut',
      mm: '%d minuts',
      h: 'una hora',
      hh: '%d hores',
      d: 'un dia',
      dd: '%d dies',
      M: 'un mes',
      MM: '%d mesos',
      y: 'un any',
      yy: '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
    ordinal: function (number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : 'è';

      if (period === 'w' || period === 'W') {
        output = 'a';
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ca;
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
      monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');

  function plural(n) {
    return n > 1 && n < 5 && ~~(n / 10) !== 1;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami';

      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'sekund');
        } else {
          return result + 'sekundami';
        }

        break;

      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';

      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minuty' : 'minut');
        } else {
          return result + 'minutami';
        }

        break;

      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodin');
        } else {
          return result + 'hodinami';
        }

        break;

      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'den' : 'dnem';

      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dny' : 'dní');
        } else {
          return result + 'dny';
        }

        break;

      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'měsíc' : 'měsícem';

      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'měsíce' : 'měsíců');
        } else {
          return result + 'měsíci';
        }

        break;

      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokem';

      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'let');
        } else {
          return result + 'lety';
        }

        break;
    }
  }

  var cs = moment.defineLocale('cs', {
    months: months,
    monthsShort: monthsShort,
    monthsParse: function (months, monthsShort) {
      var i,
          _monthsParse = [];

      for (i = 0; i < 12; i++) {
        // use custom parser to solve problem with July (červenec)
        _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
      }

      return _monthsParse;
    }(months, monthsShort),
    shortMonthsParse: function (monthsShort) {
      var i,
          _shortMonthsParse = [];

      for (i = 0; i < 12; i++) {
        _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
      }

      return _shortMonthsParse;
    }(monthsShort),
    longMonthsParse: function (months) {
      var i,
          _longMonthsParse = [];

      for (i = 0; i < 12; i++) {
        _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
      }

      return _longMonthsParse;
    }(months),
    weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
    weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
    weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm',
      l: 'D. M. YYYY'
    },
    calendar: {
      sameDay: '[dnes v] LT',
      nextDay: '[zítra v] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v neděli v] LT';

          case 1:
          case 2:
            return '[v] dddd [v] LT';

          case 3:
            return '[ve středu v] LT';

          case 4:
            return '[ve čtvrtek v] LT';

          case 5:
            return '[v pátek v] LT';

          case 6:
            return '[v sobotu v] LT';
        }
      },
      lastDay: '[včera v] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[minulou neděli v] LT';

          case 1:
          case 2:
            return '[minulé] dddd [v] LT';

          case 3:
            return '[minulou středu v] LT';

          case 4:
          case 5:
            return '[minulý] dddd [v] LT';

          case 6:
            return '[minulou sobotu v] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'před %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return cs;
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var cv = moment.defineLocale('cv', {
    months: 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
    monthsShort: 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
    weekdays: 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
    weekdaysShort: 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
    weekdaysMin: 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
      LLL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
      LLLL: 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
    },
    calendar: {
      sameDay: '[Паян] LT [сехетре]',
      nextDay: '[Ыран] LT [сехетре]',
      lastDay: '[Ӗнер] LT [сехетре]',
      nextWeek: '[Ҫитес] dddd LT [сехетре]',
      lastWeek: '[Иртнӗ] dddd LT [сехетре]',
      sameElse: 'L'
    },
    relativeTime: {
      future: function (output) {
        var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
        return output + affix;
      },
      past: '%s каялла',
      s: 'пӗр-ик ҫеккунт',
      ss: '%d ҫеккунт',
      m: 'пӗр минут',
      mm: '%d минут',
      h: 'пӗр сехет',
      hh: '%d сехет',
      d: 'пӗр кун',
      dd: '%d кун',
      M: 'пӗр уйӑх',
      MM: '%d уйӑх',
      y: 'пӗр ҫул',
      yy: '%d ҫул'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
    ordinal: '%d-мӗш',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return cv;
});

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    // time formats are the same as en-gb
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Heddiw am] LT',
      nextDay: '[Yfory am] LT',
      nextWeek: 'dddd [am] LT',
      lastDay: '[Ddoe am] LT',
      lastWeek: 'dddd [diwethaf am] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'mewn %s',
      past: '%s yn ôl',
      s: 'ychydig eiliadau',
      ss: '%d eiliad',
      m: 'munud',
      mm: '%d munud',
      h: 'awr',
      hh: '%d awr',
      d: 'diwrnod',
      dd: '%d diwrnod',
      M: 'mis',
      MM: '%d mis',
      y: 'blwyddyn',
      yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
      var b = number,
          output = '',
          lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
      'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
      ];

      if (b > 20) {
        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
          output = 'fed'; // not 30ain, 70ain or 90ain
        } else {
          output = 'ain';
        }
      } else if (b > 0) {
        output = lookup[b];
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return cy;
});

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var da = moment.defineLocale('da', {
    months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
    weekdaysShort: 'søn_man_tir_ons_tor_fre_lør'.split('_'),
    weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'på dddd [kl.] LT',
      lastDay: '[i går kl.] LT',
      lastWeek: '[i] dddd[s kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'få sekunder',
      ss: '%d sekunder',
      m: 'et minut',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dage',
      M: 'en måned',
      MM: '%d måneder',
      y: 'et år',
      yy: '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return da;
});

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eine Minute', 'einer Minute'],
      'h': ['eine Stunde', 'einer Stunde'],
      'd': ['ein Tag', 'einem Tag'],
      'dd': [number + ' Tage', number + ' Tagen'],
      'M': ['ein Monat', 'einem Monat'],
      'MM': [number + ' Monate', number + ' Monaten'],
      'y': ['ein Jahr', 'einem Jahr'],
      'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var de = moment.defineLocale('de', {
    months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return de;
});

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eine Minute', 'einer Minute'],
      'h': ['eine Stunde', 'einer Stunde'],
      'd': ['ein Tag', 'einem Tag'],
      'dd': [number + ' Tage', number + ' Tagen'],
      'M': ['ein Monat', 'einem Monat'],
      'MM': [number + ' Monate', number + ' Monaten'],
      'y': ['ein Jahr', 'einem Jahr'],
      'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var deAt = moment.defineLocale('de-at', {
    months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return deAt;
});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eine Minute', 'einer Minute'],
      'h': ['eine Stunde', 'einer Stunde'],
      'd': ['ein Tag', 'einem Tag'],
      'dd': [number + ' Tage', number + ' Tagen'],
      'M': ['ein Monat', 'einem Monat'],
      'MM': [number + ' Monate', number + ' Monaten'],
      'y': ['ein Jahr', 'einem Jahr'],
      'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var deCh = moment.defineLocale('de-ch', {
    months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return deCh;
});

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var months = ['ޖެނުއަރީ', 'ފެބްރުއަރީ', 'މާރިޗު', 'އޭޕްރީލު', 'މޭ', 'ޖޫން', 'ޖުލައި', 'އޯގަސްޓު', 'ސެޕްޓެމްބަރު', 'އޮކްޓޯބަރު', 'ނޮވެމްބަރު', 'ޑިސެމްބަރު'],
      weekdays = ['އާދިއްތަ', 'ހޯމަ', 'އަންގާރަ', 'ބުދަ', 'ބުރާސްފަތި', 'ހުކުރު', 'ހޮނިހިރު'];
  var dv = moment.defineLocale('dv', {
    months: months,
    monthsShort: months,
    weekdays: weekdays,
    weekdaysShort: weekdays,
    weekdaysMin: 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/M/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /މކ|މފ/,
    isPM: function (input) {
      return 'މފ' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'މކ';
      } else {
        return 'މފ';
      }
    },
    calendar: {
      sameDay: '[މިއަދު] LT',
      nextDay: '[މާދަމާ] LT',
      nextWeek: 'dddd LT',
      lastDay: '[އިއްޔެ] LT',
      lastWeek: '[ފާއިތުވި] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ތެރޭގައި %s',
      past: 'ކުރިން %s',
      s: 'ސިކުންތުކޮޅެއް',
      ss: 'd% ސިކުންތު',
      m: 'މިނިޓެއް',
      mm: 'މިނިޓު %d',
      h: 'ގަޑިއިރެއް',
      hh: 'ގަޑިއިރު %d',
      d: 'ދުވަހެއް',
      dd: 'ދުވަސް %d',
      M: 'މަހެއް',
      MM: 'މަސް %d',
      y: 'އަހަރެއް',
      yy: 'އަހަރު %d'
    },
    preparse: function (string) {
      return string.replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '،');
    },
    week: {
      dow: 7,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return dv;
});

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  var el = moment.defineLocale('el', {
    monthsNominativeEl: 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
    monthsGenitiveEl: 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
    months: function (momentToFormat, format) {
      if (!momentToFormat) {
        return this._monthsNominativeEl;
      } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) {
        // if there is a day number before 'MMMM'
        return this._monthsGenitiveEl[momentToFormat.month()];
      } else {
        return this._monthsNominativeEl[momentToFormat.month()];
      }
    },
    monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
    weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
    weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
    weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'μμ' : 'ΜΜ';
      } else {
        return isLower ? 'πμ' : 'ΠΜ';
      }
    },
    isPM: function (input) {
      return (input + '').toLowerCase()[0] === 'μ';
    },
    meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl: {
      sameDay: '[Σήμερα {}] LT',
      nextDay: '[Αύριο {}] LT',
      nextWeek: 'dddd [{}] LT',
      lastDay: '[Χθες {}] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 6:
            return '[το προηγούμενο] dddd [{}] LT';

          default:
            return '[την προηγούμενη] dddd [{}] LT';
        }
      },
      sameElse: 'L'
    },
    calendar: function (key, mom) {
      var output = this._calendarEl[key],
          hours = mom && mom.hours();

      if (isFunction(output)) {
        output = output.apply(mom);
      }

      return output.replace('{}', hours % 12 === 1 ? 'στη' : 'στις');
    },
    relativeTime: {
      future: 'σε %s',
      past: '%s πριν',
      s: 'λίγα δευτερόλεπτα',
      ss: '%d δευτερόλεπτα',
      m: 'ένα λεπτό',
      mm: '%d λεπτά',
      h: 'μία ώρα',
      hh: '%d ώρες',
      d: 'μία μέρα',
      dd: '%d μέρες',
      M: 'ένας μήνας',
      MM: '%d μήνες',
      y: 'ένας χρόνος',
      yy: '%d χρόνια'
    },
    dayOfMonthOrdinalParse: /\d{1,2}η/,
    ordinal: '%dη',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4st is the first week of the year.

    }
  });
  return el;
});

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var enAu = moment.defineLocale('en-au', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enAu;
});

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var enCa = moment.defineLocale('en-ca', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'YYYY-MM-DD',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enCa;
});

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var enGb = moment.defineLocale('en-gb', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enGb;
});

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var enIe = moment.defineLocale('en-ie', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enIe;
});

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var enIl = moment.defineLocale('en-il', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enIl;
});

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var enNz = moment.defineLocale('en-nz', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enNz;
});

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var eo = moment.defineLocale('eo', {
    months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
    weekdays: 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
    weekdaysShort: 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
    weekdaysMin: 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D[-a de] MMMM, YYYY',
      LLL: 'D[-a de] MMMM, YYYY HH:mm',
      LLLL: 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
      return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'p.t.m.' : 'P.T.M.';
      } else {
        return isLower ? 'a.t.m.' : 'A.T.M.';
      }
    },
    calendar: {
      sameDay: '[Hodiaŭ je] LT',
      nextDay: '[Morgaŭ je] LT',
      nextWeek: 'dddd [je] LT',
      lastDay: '[Hieraŭ je] LT',
      lastWeek: '[pasinta] dddd [je] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'post %s',
      past: 'antaŭ %s',
      s: 'sekundoj',
      ss: '%d sekundoj',
      m: 'minuto',
      mm: '%d minutoj',
      h: 'horo',
      hh: '%d horoj',
      d: 'tago',
      //ne 'diurno', ĉar estas uzita por proksimumo
      dd: '%d tagoj',
      M: 'monato',
      MM: '%d monatoj',
      y: 'jaro',
      yy: '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal: '%da',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return eo;
});

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
  var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
  var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var es = moment.defineLocale('es', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un día',
      dd: '%d días',
      M: 'un mes',
      MM: '%d meses',
      y: 'un año',
      yy: '%d años'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return es;
});

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
  var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
  var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esDo = moment.defineLocale('es-do', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un día',
      dd: '%d días',
      M: 'un mes',
      MM: '%d meses',
      y: 'un año',
      yy: '%d años'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return esDo;
});

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
  var esUs = moment.defineLocale('es-us', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsParseExact: true,
    weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM [de] D [de] YYYY',
      LLL: 'MMMM [de] D [de] YYYY h:mm A',
      LLLL: 'dddd, MMMM [de] D [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un día',
      dd: '%d días',
      M: 'un mes',
      MM: '%d meses',
      y: 'un año',
      yy: '%d años'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return esUs;
});

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      's': ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
      'ss': [number + 'sekundi', number + 'sekundit'],
      'm': ['ühe minuti', 'üks minut'],
      'mm': [number + ' minuti', number + ' minutit'],
      'h': ['ühe tunni', 'tund aega', 'üks tund'],
      'hh': [number + ' tunni', number + ' tundi'],
      'd': ['ühe päeva', 'üks päev'],
      'M': ['kuu aja', 'kuu aega', 'üks kuu'],
      'MM': [number + ' kuu', number + ' kuud'],
      'y': ['ühe aasta', 'aasta', 'üks aasta'],
      'yy': [number + ' aasta', number + ' aastat']
    };

    if (withoutSuffix) {
      return format[key][2] ? format[key][2] : format[key][1];
    }

    return isFuture ? format[key][0] : format[key][1];
  }

  var et = moment.defineLocale('et', {
    months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
    weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Täna,] LT',
      nextDay: '[Homme,] LT',
      nextWeek: '[Järgmine] dddd LT',
      lastDay: '[Eile,] LT',
      lastWeek: '[Eelmine] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s pärast',
      past: '%s tagasi',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: '%d päeva',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return et;
});

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var eu = moment.defineLocale('eu', {
    months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact: true,
    weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY[ko] MMMM[ren] D[a]',
      LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
      LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
      l: 'YYYY-M-D',
      ll: 'YYYY[ko] MMM D[a]',
      lll: 'YYYY[ko] MMM D[a] HH:mm',
      llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar: {
      sameDay: '[gaur] LT[etan]',
      nextDay: '[bihar] LT[etan]',
      nextWeek: 'dddd LT[etan]',
      lastDay: '[atzo] LT[etan]',
      lastWeek: '[aurreko] dddd LT[etan]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s barru',
      past: 'duela %s',
      s: 'segundo batzuk',
      ss: '%d segundo',
      m: 'minutu bat',
      mm: '%d minutu',
      h: 'ordu bat',
      hh: '%d ordu',
      d: 'egun bat',
      dd: '%d egun',
      M: 'hilabete bat',
      MM: '%d hilabete',
      y: 'urte bat',
      yy: '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return eu;
});

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '۱',
    '2': '۲',
    '3': '۳',
    '4': '۴',
    '5': '۵',
    '6': '۶',
    '7': '۷',
    '8': '۸',
    '9': '۹',
    '0': '۰'
  },
      numberMap = {
    '۱': '1',
    '۲': '2',
    '۳': '3',
    '۴': '4',
    '۵': '5',
    '۶': '6',
    '۷': '7',
    '۸': '8',
    '۹': '9',
    '۰': '0'
  };
  var fa = moment.defineLocale('fa', {
    months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
    monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
    weekdays: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
    weekdaysShort: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
    weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /قبل از ظهر|بعد از ظهر/,
    isPM: function (input) {
      return /بعد از ظهر/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'قبل از ظهر';
      } else {
        return 'بعد از ظهر';
      }
    },
    calendar: {
      sameDay: '[امروز ساعت] LT',
      nextDay: '[فردا ساعت] LT',
      nextWeek: 'dddd [ساعت] LT',
      lastDay: '[دیروز ساعت] LT',
      lastWeek: 'dddd [پیش] [ساعت] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'در %s',
      past: '%s پیش',
      s: 'چند ثانیه',
      ss: 'ثانیه d%',
      m: 'یک دقیقه',
      mm: '%d دقیقه',
      h: 'یک ساعت',
      hh: '%d ساعت',
      d: 'یک روز',
      dd: '%d روز',
      M: 'یک ماه',
      MM: '%d ماه',
      y: 'یک سال',
      yy: '%d سال'
    },
    preparse: function (string) {
      return string.replace(/[۰-۹]/g, function (match) {
        return numberMap[match];
      }).replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '،');
    },
    dayOfMonthOrdinalParse: /\d{1,2}م/,
    ordinal: '%dم',
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return fa;
});

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
      numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];

  function translate(number, withoutSuffix, key, isFuture) {
    var result = '';

    switch (key) {
      case 's':
        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';

      case 'ss':
        return isFuture ? 'sekunnin' : 'sekuntia';

      case 'm':
        return isFuture ? 'minuutin' : 'minuutti';

      case 'mm':
        result = isFuture ? 'minuutin' : 'minuuttia';
        break;

      case 'h':
        return isFuture ? 'tunnin' : 'tunti';

      case 'hh':
        result = isFuture ? 'tunnin' : 'tuntia';
        break;

      case 'd':
        return isFuture ? 'päivän' : 'päivä';

      case 'dd':
        result = isFuture ? 'päivän' : 'päivää';
        break;

      case 'M':
        return isFuture ? 'kuukauden' : 'kuukausi';

      case 'MM':
        result = isFuture ? 'kuukauden' : 'kuukautta';
        break;

      case 'y':
        return isFuture ? 'vuoden' : 'vuosi';

      case 'yy':
        result = isFuture ? 'vuoden' : 'vuotta';
        break;
    }

    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
  }

  function verbalNumber(number, isFuture) {
    return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
  }

  var fi = moment.defineLocale('fi', {
    months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
    weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM[ta] YYYY',
      LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
      LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
      l: 'D.M.YYYY',
      ll: 'Do MMM YYYY',
      lll: 'Do MMM YYYY, [klo] HH.mm',
      llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar: {
      sameDay: '[tänään] [klo] LT',
      nextDay: '[huomenna] [klo] LT',
      nextWeek: 'dddd [klo] LT',
      lastDay: '[eilen] [klo] LT',
      lastWeek: '[viime] dddd[na] [klo] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s päästä',
      past: '%s sitten',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fi;
});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var fo = moment.defineLocale('fo', {
    months: 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
    weekdaysShort: 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
    weekdaysMin: 'su_má_tý_mi_hó_fr_le'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Í dag kl.] LT',
      nextDay: '[Í morgin kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[Í gjár kl.] LT',
      lastWeek: '[síðstu] dddd [kl] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'um %s',
      past: '%s síðani',
      s: 'fá sekund',
      ss: '%d sekundir',
      m: 'ein minutt',
      mm: '%d minuttir',
      h: 'ein tími',
      hh: '%d tímar',
      d: 'ein dagur',
      dd: '%d dagar',
      M: 'ein mánaði',
      MM: '%d mánaðir',
      y: 'eitt ár',
      yy: '%d ár'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fo;
});

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var fr = moment.defineLocale('fr', {
    months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourd’hui à] LT',
      nextDay: '[Demain à] LT',
      nextWeek: 'dddd [à] LT',
      lastDay: '[Hier à] LT',
      lastWeek: 'dddd [dernier à] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal: function (number, period) {
      switch (period) {
        // TODO: Return 'e' when day of month > 1. Move this case inside
        // block for masculine words below.
        // See https://github.com/moment/moment/issues/3375
        case 'D':
          return number + (number === 1 ? 'er' : '');
        // Words with masculine grammatical gender: mois, trimestre, jour

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fr;
});

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var frCa = moment.defineLocale('fr-ca', {
    months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourd’hui à] LT',
      nextDay: '[Demain à] LT',
      nextWeek: 'dddd [à] LT',
      lastDay: '[Hier à] LT',
      lastWeek: 'dddd [dernier à] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function (number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    }
  });
  return frCa;
});

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var frCh = moment.defineLocale('fr-ch', {
    months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourd’hui à] LT',
      nextDay: '[Demain à] LT',
      nextWeek: 'dddd [à] LT',
      lastDay: '[Hier à] LT',
      lastWeek: 'dddd [dernier à] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function (number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return frCh;
});

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
  var fy = moment.defineLocale('fy', {
    months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsParseExact: true,
    weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[hjoed om] LT',
      nextDay: '[moarn om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[juster om] LT',
      lastWeek: '[ôfrûne] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oer %s',
      past: '%s lyn',
      s: 'in pear sekonden',
      ss: '%d sekonden',
      m: 'ien minút',
      mm: '%d minuten',
      h: 'ien oere',
      hh: '%d oeren',
      d: 'ien dei',
      dd: '%d dagen',
      M: 'ien moanne',
      MM: '%d moannen',
      y: 'ien jier',
      yy: '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fy;
});

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var months = ['Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'];
  var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];
  var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
  var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
  var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];
  var gd = moment.defineLocale('gd', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[An-diugh aig] LT',
      nextDay: '[A-màireach aig] LT',
      nextWeek: 'dddd [aig] LT',
      lastDay: '[An-dè aig] LT',
      lastWeek: 'dddd [seo chaidh] [aig] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ann an %s',
      past: 'bho chionn %s',
      s: 'beagan diogan',
      ss: '%d diogan',
      m: 'mionaid',
      mm: '%d mionaidean',
      h: 'uair',
      hh: '%d uairean',
      d: 'latha',
      dd: '%d latha',
      M: 'mìos',
      MM: '%d mìosan',
      y: 'bliadhna',
      yy: '%d bliadhna'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function (number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return gd;
});

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var gl = moment.defineLocale('gl', {
    months: 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort: 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mé_xo_ve_sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoxe ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
      },
      nextDay: function () {
        return '[mañá ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
      },
      lastDay: function () {
        return '[onte ' + (this.hours() !== 1 ? 'á' : 'a') + '] LT';
      },
      lastWeek: function () {
        return '[o] dddd [pasado ' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function (str) {
        if (str.indexOf('un') === 0) {
          return 'n' + str;
        }

        return 'en ' + str;
      },
      past: 'hai %s',
      s: 'uns segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'unha hora',
      hh: '%d horas',
      d: 'un día',
      dd: '%d días',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return gl;
});

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      's': ['thodde secondanim', 'thodde second'],
      'ss': [number + ' secondanim', number + ' second'],
      'm': ['eka mintan', 'ek minute'],
      'mm': [number + ' mintanim', number + ' mintam'],
      'h': ['eka horan', 'ek hor'],
      'hh': [number + ' horanim', number + ' horam'],
      'd': ['eka disan', 'ek dis'],
      'dd': [number + ' disanim', number + ' dis'],
      'M': ['eka mhoinean', 'ek mhoino'],
      'MM': [number + ' mhoineanim', number + ' mhoine'],
      'y': ['eka vorsan', 'ek voros'],
      'yy': [number + ' vorsanim', number + ' vorsam']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var gomLatn = moment.defineLocale('gom-latn', {
    months: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
    monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
    weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm [vazta]',
      LTS: 'A h:mm:ss [vazta]',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm [vazta]',
      LLLL: 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
      llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar: {
      sameDay: '[Aiz] LT',
      nextDay: '[Faleam] LT',
      nextWeek: '[Ieta to] dddd[,] LT',
      lastDay: '[Kal] LT',
      lastWeek: '[Fatlo] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s adim',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er)/,
    ordinal: function (number, period) {
      switch (period) {
        // the ordinal 'er' only applies to day of the month
        case 'D':
          return number + 'er';

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    meridiemParse: /rati|sokalli|donparam|sanje/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'rati') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'sokalli') {
        return hour;
      } else if (meridiem === 'donparam') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === 'sanje') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'rati';
      } else if (hour < 12) {
        return 'sokalli';
      } else if (hour < 16) {
        return 'donparam';
      } else if (hour < 20) {
        return 'sanje';
      } else {
        return 'rati';
      }
    }
  });
  return gomLatn;
});

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '૧',
    '2': '૨',
    '3': '૩',
    '4': '૪',
    '5': '૫',
    '6': '૬',
    '7': '૭',
    '8': '૮',
    '9': '૯',
    '0': '૦'
  },
      numberMap = {
    '૧': '1',
    '૨': '2',
    '૩': '3',
    '૪': '4',
    '૫': '5',
    '૬': '6',
    '૭': '7',
    '૮': '8',
    '૯': '9',
    '૦': '0'
  };
  var gu = moment.defineLocale('gu', {
    months: 'જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર'.split('_'),
    monthsShort: 'જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.'.split('_'),
    monthsParseExact: true,
    weekdays: 'રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર'.split('_'),
    weekdaysShort: 'રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ'.split('_'),
    weekdaysMin: 'ર_સો_મં_બુ_ગુ_શુ_શ'.split('_'),
    longDateFormat: {
      LT: 'A h:mm વાગ્યે',
      LTS: 'A h:mm:ss વાગ્યે',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm વાગ્યે',
      LLLL: 'dddd, D MMMM YYYY, A h:mm વાગ્યે'
    },
    calendar: {
      sameDay: '[આજ] LT',
      nextDay: '[કાલે] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[ગઇકાલે] LT',
      lastWeek: '[પાછલા] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s મા',
      past: '%s પેહલા',
      s: 'અમુક પળો',
      ss: '%d સેકંડ',
      m: 'એક મિનિટ',
      mm: '%d મિનિટ',
      h: 'એક કલાક',
      hh: '%d કલાક',
      d: 'એક દિવસ',
      dd: '%d દિવસ',
      M: 'એક મહિનો',
      MM: '%d મહિનો',
      y: 'એક વર્ષ',
      yy: '%d વર્ષ'
    },
    preparse: function (string) {
      return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'રાત') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'સવાર') {
        return hour;
      } else if (meridiem === 'બપોર') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'સાંજ') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'રાત';
      } else if (hour < 10) {
        return 'સવાર';
      } else if (hour < 17) {
        return 'બપોર';
      } else if (hour < 20) {
        return 'સાંજ';
      } else {
        return 'રાત';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return gu;
});

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var he = moment.defineLocale('he', {
    months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
    monthsShort: 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
    weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
    weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
    weekdaysMin: 'א_ב_ג_ד_ה_ו_ש'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [ב]MMMM YYYY',
      LLL: 'D [ב]MMMM YYYY HH:mm',
      LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
      l: 'D/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[היום ב־]LT',
      nextDay: '[מחר ב־]LT',
      nextWeek: 'dddd [בשעה] LT',
      lastDay: '[אתמול ב־]LT',
      lastWeek: '[ביום] dddd [האחרון בשעה] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'בעוד %s',
      past: 'לפני %s',
      s: 'מספר שניות',
      ss: '%d שניות',
      m: 'דקה',
      mm: '%d דקות',
      h: 'שעה',
      hh: function (number) {
        if (number === 2) {
          return 'שעתיים';
        }

        return number + ' שעות';
      },
      d: 'יום',
      dd: function (number) {
        if (number === 2) {
          return 'יומיים';
        }

        return number + ' ימים';
      },
      M: 'חודש',
      MM: function (number) {
        if (number === 2) {
          return 'חודשיים';
        }

        return number + ' חודשים';
      },
      y: 'שנה',
      yy: function (number) {
        if (number === 2) {
          return 'שנתיים';
        } else if (number % 10 === 0 && number !== 10) {
          return number + ' שנה';
        }

        return number + ' שנים';
      }
    },
    meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
    isPM: function (input) {
      return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 5) {
        return 'לפנות בוקר';
      } else if (hour < 10) {
        return 'בבוקר';
      } else if (hour < 12) {
        return isLower ? 'לפנה"צ' : 'לפני הצהריים';
      } else if (hour < 18) {
        return isLower ? 'אחה"צ' : 'אחרי הצהריים';
      } else {
        return 'בערב';
      }
    }
  });
  return he;
});

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '१',
    '2': '२',
    '3': '३',
    '4': '४',
    '5': '५',
    '6': '६',
    '7': '७',
    '8': '८',
    '9': '९',
    '0': '०'
  },
      numberMap = {
    '१': '1',
    '२': '2',
    '३': '3',
    '४': '4',
    '५': '5',
    '६': '6',
    '७': '7',
    '८': '8',
    '९': '9',
    '०': '0'
  };
  var hi = moment.defineLocale('hi', {
    months: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
    monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
    monthsParseExact: true,
    weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
    weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
    weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
    longDateFormat: {
      LT: 'A h:mm बजे',
      LTS: 'A h:mm:ss बजे',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm बजे',
      LLLL: 'dddd, D MMMM YYYY, A h:mm बजे'
    },
    calendar: {
      sameDay: '[आज] LT',
      nextDay: '[कल] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[कल] LT',
      lastWeek: '[पिछले] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s में',
      past: '%s पहले',
      s: 'कुछ ही क्षण',
      ss: '%d सेकंड',
      m: 'एक मिनट',
      mm: '%d मिनट',
      h: 'एक घंटा',
      hh: '%d घंटे',
      d: 'एक दिन',
      dd: '%d दिन',
      M: 'एक महीने',
      MM: '%d महीने',
      y: 'एक वर्ष',
      yy: '%d वर्ष'
    },
    preparse: function (string) {
      return string.replace(/[१२३४५६७८९०]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /रात|सुबह|दोपहर|शाम/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'रात') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'सुबह') {
        return hour;
      } else if (meridiem === 'दोपहर') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'शाम') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'रात';
      } else if (hour < 10) {
        return 'सुबह';
      } else if (hour < 17) {
        return 'दोपहर';
      } else if (hour < 20) {
        return 'शाम';
      } else {
        return 'रात';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return hi;
});

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';

      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';

      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }

        return result;

      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }

        return result;

      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }

        return result;

      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }

        return result;
    }
  }

  var hr = moment.defineLocale('hr', {
    months: {
      format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
      standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jučer u] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prošlu] dddd [u] LT';

          case 6:
            return '[prošle] [subote] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[prošli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return hr;
});

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');

  function translate(number, withoutSuffix, key, isFuture) {
    var num = number;

    switch (key) {
      case 's':
        return isFuture || withoutSuffix ? 'néhány másodperc' : 'néhány másodperce';

      case 'ss':
        return num + (isFuture || withoutSuffix) ? ' másodperc' : ' másodperce';

      case 'm':
        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');

      case 'mm':
        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');

      case 'h':
        return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');

      case 'hh':
        return num + (isFuture || withoutSuffix ? ' óra' : ' órája');

      case 'd':
        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');

      case 'dd':
        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');

      case 'M':
        return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');

      case 'MM':
        return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');

      case 'y':
        return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');

      case 'yy':
        return num + (isFuture || withoutSuffix ? ' év' : ' éve');
    }

    return '';
  }

  function week(isFuture) {
    return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
  }

  var hu = moment.defineLocale('hu', {
    months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
    monthsShort: 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
    weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
    weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
    weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY. MMMM D.',
      LLL: 'YYYY. MMMM D. H:mm',
      LLLL: 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
      return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower === true ? 'de' : 'DE';
      } else {
        return isLower === true ? 'du' : 'DU';
      }
    },
    calendar: {
      sameDay: '[ma] LT[-kor]',
      nextDay: '[holnap] LT[-kor]',
      nextWeek: function () {
        return week.call(this, true);
      },
      lastDay: '[tegnap] LT[-kor]',
      lastWeek: function () {
        return week.call(this, false);
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s múlva',
      past: '%s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return hu;
});

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var hyAm = moment.defineLocale('hy-am', {
    months: {
      format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
      standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
    },
    monthsShort: 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
    weekdays: 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
    weekdaysShort: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
    weekdaysMin: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY թ.',
      LLL: 'D MMMM YYYY թ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY թ., HH:mm'
    },
    calendar: {
      sameDay: '[այսօր] LT',
      nextDay: '[վաղը] LT',
      lastDay: '[երեկ] LT',
      nextWeek: function () {
        return 'dddd [օրը ժամը] LT';
      },
      lastWeek: function () {
        return '[անցած] dddd [օրը ժամը] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s հետո',
      past: '%s առաջ',
      s: 'մի քանի վայրկյան',
      ss: '%d վայրկյան',
      m: 'րոպե',
      mm: '%d րոպե',
      h: 'ժամ',
      hh: '%d ժամ',
      d: 'օր',
      dd: '%d օր',
      M: 'ամիս',
      MM: '%d ամիս',
      y: 'տարի',
      yy: '%d տարի'
    },
    meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
    isPM: function (input) {
      return /^(ցերեկվա|երեկոյան)$/.test(input);
    },
    meridiem: function (hour) {
      if (hour < 4) {
        return 'գիշերվա';
      } else if (hour < 12) {
        return 'առավոտվա';
      } else if (hour < 17) {
        return 'ցերեկվա';
      } else {
        return 'երեկոյան';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'DDD':
        case 'w':
        case 'W':
        case 'DDDo':
          if (number === 1) {
            return number + '-ին';
          }

          return number + '-րդ';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return hyAm;
});

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var id = moment.defineLocale('id', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'siang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sore' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'siang';
      } else if (hours < 19) {
        return 'sore';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Besok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kemarin pukul] LT',
      lastWeek: 'dddd [lalu pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lalu',
      s: 'beberapa detik',
      ss: '%d detik',
      m: 'semenit',
      mm: '%d menit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return id;
});

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function plural(n) {
    if (n % 100 === 11) {
      return true;
    } else if (n % 10 === 1) {
      return false;
    }

    return true;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';

      case 'ss':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'sekúndur' : 'sekúndum');
        }

        return result + 'sekúnda';

      case 'm':
        return withoutSuffix ? 'mínúta' : 'mínútu';

      case 'mm':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
        } else if (withoutSuffix) {
          return result + 'mínúta';
        }

        return result + 'mínútu';

      case 'hh':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
        }

        return result + 'klukkustund';

      case 'd':
        if (withoutSuffix) {
          return 'dagur';
        }

        return isFuture ? 'dag' : 'degi';

      case 'dd':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'dagar';
          }

          return result + (isFuture ? 'daga' : 'dögum');
        } else if (withoutSuffix) {
          return result + 'dagur';
        }

        return result + (isFuture ? 'dag' : 'degi');

      case 'M':
        if (withoutSuffix) {
          return 'mánuður';
        }

        return isFuture ? 'mánuð' : 'mánuði';

      case 'MM':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'mánuðir';
          }

          return result + (isFuture ? 'mánuði' : 'mánuðum');
        } else if (withoutSuffix) {
          return result + 'mánuður';
        }

        return result + (isFuture ? 'mánuð' : 'mánuði');

      case 'y':
        return withoutSuffix || isFuture ? 'ár' : 'ári';

      case 'yy':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
        }

        return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
    }
  }

  var is = moment.defineLocale('is', {
    months: 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
    weekdays: 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
    weekdaysShort: 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
    weekdaysMin: 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar: {
      sameDay: '[í dag kl.] LT',
      nextDay: '[á morgun kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[í gær kl.] LT',
      lastWeek: '[síðasta] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'eftir %s',
      past: 'fyrir %s síðan',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: 'klukkustund',
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return is;
});

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var it = moment.defineLocale('it', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Oggi alle] LT',
      nextDay: '[Domani alle] LT',
      nextWeek: 'dddd [alle] LT',
      lastDay: '[Ieri alle] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[la scorsa] dddd [alle] LT';

          default:
            return '[lo scorso] dddd [alle] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function (s) {
        return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
      },
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: 'un\'ora',
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return it;
});

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ja = moment.defineLocale('ja', {
    months: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
    weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
    weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY年M月D日',
      LLL: 'YYYY年M月D日 HH:mm',
      LLLL: 'YYYY年M月D日 dddd HH:mm',
      l: 'YYYY/MM/DD',
      ll: 'YYYY年M月D日',
      lll: 'YYYY年M月D日 HH:mm',
      llll: 'YYYY年M月D日(ddd) HH:mm'
    },
    meridiemParse: /午前|午後/i,
    isPM: function (input) {
      return input === '午後';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '午前';
      } else {
        return '午後';
      }
    },
    calendar: {
      sameDay: '[今日] LT',
      nextDay: '[明日] LT',
      nextWeek: function (now) {
        if (now.week() < this.week()) {
          return '[来週]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      lastDay: '[昨日] LT',
      lastWeek: function (now) {
        if (this.week() < now.week()) {
          return '[先週]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}日/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '日';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s後',
      past: '%s前',
      s: '数秒',
      ss: '%d秒',
      m: '1分',
      mm: '%d分',
      h: '1時間',
      hh: '%d時間',
      d: '1日',
      dd: '%d日',
      M: '1ヶ月',
      MM: '%dヶ月',
      y: '1年',
      yy: '%d年'
    }
  });
  return ja;
});

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var jv = moment.defineLocale('jv', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'enjing') {
        return hour;
      } else if (meridiem === 'siyang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'enjing';
      } else if (hours < 15) {
        return 'siyang';
      } else if (hours < 19) {
        return 'sonten';
      } else {
        return 'ndalu';
      }
    },
    calendar: {
      sameDay: '[Dinten puniko pukul] LT',
      nextDay: '[Mbenjang pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kala wingi pukul] LT',
      lastWeek: 'dddd [kepengker pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'wonten ing %s',
      past: '%s ingkang kepengker',
      s: 'sawetawis detik',
      ss: '%d detik',
      m: 'setunggal menit',
      mm: '%d menit',
      h: 'setunggal jam',
      hh: '%d jam',
      d: 'sedinten',
      dd: '%d dinten',
      M: 'sewulan',
      MM: '%d wulan',
      y: 'setaun',
      yy: '%d taun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return jv;
});

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ka = moment.defineLocale('ka', {
    months: {
      standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
      format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
    },
    monthsShort: 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
    weekdays: {
      standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
      format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
      isFormat: /(წინა|შემდეგ)/
    },
    weekdaysShort: 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
    weekdaysMin: 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[დღეს] LT[-ზე]',
      nextDay: '[ხვალ] LT[-ზე]',
      lastDay: '[გუშინ] LT[-ზე]',
      nextWeek: '[შემდეგ] dddd LT[-ზე]',
      lastWeek: '[წინა] dddd LT-ზე',
      sameElse: 'L'
    },
    relativeTime: {
      future: function (s) {
        return /(წამი|წუთი|საათი|წელი)/.test(s) ? s.replace(/ი$/, 'ში') : s + 'ში';
      },
      past: function (s) {
        if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
          return s.replace(/(ი|ე)$/, 'ის წინ');
        }

        if (/წელი/.test(s)) {
          return s.replace(/წელი$/, 'წლის წინ');
        }
      },
      s: 'რამდენიმე წამი',
      ss: '%d წამი',
      m: 'წუთი',
      mm: '%d წუთი',
      h: 'საათი',
      hh: '%d საათი',
      d: 'დღე',
      dd: '%d დღე',
      M: 'თვე',
      MM: '%d თვე',
      y: 'წელი',
      yy: '%d წელი'
    },
    dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
    ordinal: function (number) {
      if (number === 0) {
        return number;
      }

      if (number === 1) {
        return number + '-ლი';
      }

      if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
        return 'მე-' + number;
      }

      return number + '-ე';
    },
    week: {
      dow: 1,
      doy: 7
    }
  });
  return ka;
});

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var suffixes = {
    0: '-ші',
    1: '-ші',
    2: '-ші',
    3: '-ші',
    4: '-ші',
    5: '-ші',
    6: '-шы',
    7: '-ші',
    8: '-ші',
    9: '-шы',
    10: '-шы',
    20: '-шы',
    30: '-шы',
    40: '-шы',
    50: '-ші',
    60: '-шы',
    70: '-ші',
    80: '-ші',
    90: '-шы',
    100: '-ші'
  };
  var kk = moment.defineLocale('kk', {
    months: 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
    monthsShort: 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
    weekdays: 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
    weekdaysShort: 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
    weekdaysMin: 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Бүгін сағат] LT',
      nextDay: '[Ертең сағат] LT',
      nextWeek: 'dddd [сағат] LT',
      lastDay: '[Кеше сағат] LT',
      lastWeek: '[Өткен аптаның] dddd [сағат] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ішінде',
      past: '%s бұрын',
      s: 'бірнеше секунд',
      ss: '%d секунд',
      m: 'бір минут',
      mm: '%d минут',
      h: 'бір сағат',
      hh: '%d сағат',
      d: 'бір күн',
      dd: '%d күн',
      M: 'бір ай',
      MM: '%d ай',
      y: 'бір жыл',
      yy: '%d жыл'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
    ordinal: function (number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return kk;
});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '១',
    '2': '២',
    '3': '៣',
    '4': '៤',
    '5': '៥',
    '6': '៦',
    '7': '៧',
    '8': '៨',
    '9': '៩',
    '0': '០'
  },
      numberMap = {
    '១': '1',
    '២': '2',
    '៣': '3',
    '៤': '4',
    '៥': '5',
    '៦': '6',
    '៧': '7',
    '៨': '8',
    '៩': '9',
    '០': '0'
  };
  var km = moment.defineLocale('km', {
    months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
    monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
    weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
    weekdaysShort: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
    weekdaysMin: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /ព្រឹក|ល្ងាច/,
    isPM: function (input) {
      return input === 'ល្ងាច';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ព្រឹក';
      } else {
        return 'ល្ងាច';
      }
    },
    calendar: {
      sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
      nextDay: '[ស្អែក ម៉ោង] LT',
      nextWeek: 'dddd [ម៉ោង] LT',
      lastDay: '[ម្សិលមិញ ម៉ោង] LT',
      lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%sទៀត',
      past: '%sមុន',
      s: 'ប៉ុន្មានវិនាទី',
      ss: '%d វិនាទី',
      m: 'មួយនាទី',
      mm: '%d នាទី',
      h: 'មួយម៉ោង',
      hh: '%d ម៉ោង',
      d: 'មួយថ្ងៃ',
      dd: '%d ថ្ងៃ',
      M: 'មួយខែ',
      MM: '%d ខែ',
      y: 'មួយឆ្នាំ',
      yy: '%d ឆ្នាំ'
    },
    dayOfMonthOrdinalParse: /ទី\d{1,2}/,
    ordinal: 'ទី%d',
    preparse: function (string) {
      return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return km;
});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '೧',
    '2': '೨',
    '3': '೩',
    '4': '೪',
    '5': '೫',
    '6': '೬',
    '7': '೭',
    '8': '೮',
    '9': '೯',
    '0': '೦'
  },
      numberMap = {
    '೧': '1',
    '೨': '2',
    '೩': '3',
    '೪': '4',
    '೫': '5',
    '೬': '6',
    '೭': '7',
    '೮': '8',
    '೯': '9',
    '೦': '0'
  };
  var kn = moment.defineLocale('kn', {
    months: 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split('_'),
    monthsShort: 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ'.split('_'),
    monthsParseExact: true,
    weekdays: 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split('_'),
    weekdaysShort: 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
    weekdaysMin: 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[ಇಂದು] LT',
      nextDay: '[ನಾಳೆ] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[ನಿನ್ನೆ] LT',
      lastWeek: '[ಕೊನೆಯ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ನಂತರ',
      past: '%s ಹಿಂದೆ',
      s: 'ಕೆಲವು ಕ್ಷಣಗಳು',
      ss: '%d ಸೆಕೆಂಡುಗಳು',
      m: 'ಒಂದು ನಿಮಿಷ',
      mm: '%d ನಿಮಿಷ',
      h: 'ಒಂದು ಗಂಟೆ',
      hh: '%d ಗಂಟೆ',
      d: 'ಒಂದು ದಿನ',
      dd: '%d ದಿನ',
      M: 'ಒಂದು ತಿಂಗಳು',
      MM: '%d ತಿಂಗಳು',
      y: 'ಒಂದು ವರ್ಷ',
      yy: '%d ವರ್ಷ'
    },
    preparse: function (string) {
      return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'ರಾತ್ರಿ') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
        return hour;
      } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'ಸಂಜೆ') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'ರಾತ್ರಿ';
      } else if (hour < 10) {
        return 'ಬೆಳಿಗ್ಗೆ';
      } else if (hour < 17) {
        return 'ಮಧ್ಯಾಹ್ನ';
      } else if (hour < 20) {
        return 'ಸಂಜೆ';
      } else {
        return 'ರಾತ್ರಿ';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
    ordinal: function (number) {
      return number + 'ನೇ';
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return kn;
});

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ko = moment.defineLocale('ko', {
    months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
    monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
    weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
    weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
    weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY년 MMMM D일',
      LLL: 'YYYY년 MMMM D일 A h:mm',
      LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
      l: 'YYYY.MM.DD.',
      ll: 'YYYY년 MMMM D일',
      lll: 'YYYY년 MMMM D일 A h:mm',
      llll: 'YYYY년 MMMM D일 dddd A h:mm'
    },
    calendar: {
      sameDay: '오늘 LT',
      nextDay: '내일 LT',
      nextWeek: 'dddd LT',
      lastDay: '어제 LT',
      lastWeek: '지난주 dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s 후',
      past: '%s 전',
      s: '몇 초',
      ss: '%d초',
      m: '1분',
      mm: '%d분',
      h: '한 시간',
      hh: '%d시간',
      d: '하루',
      dd: '%d일',
      M: '한 달',
      MM: '%d달',
      y: '일 년',
      yy: '%d년'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '일';

        case 'M':
          return number + '월';

        case 'w':
        case 'W':
          return number + '주';

        default:
          return number;
      }
    },
    meridiemParse: /오전|오후/,
    isPM: function (token) {
      return token === '오후';
    },
    meridiem: function (hour, minute, isUpper) {
      return hour < 12 ? '오전' : '오후';
    }
  });
  return ko;
});

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '١',
    '2': '٢',
    '3': '٣',
    '4': '٤',
    '5': '٥',
    '6': '٦',
    '7': '٧',
    '8': '٨',
    '9': '٩',
    '0': '٠'
  },
      numberMap = {
    '١': '1',
    '٢': '2',
    '٣': '3',
    '٤': '4',
    '٥': '5',
    '٦': '6',
    '٧': '7',
    '٨': '8',
    '٩': '9',
    '٠': '0'
  },
      months = ['کانونی دووەم', 'شوبات', 'ئازار', 'نیسان', 'ئایار', 'حوزەیران', 'تەمموز', 'ئاب', 'ئەیلوول', 'تشرینی یەكەم', 'تشرینی دووەم', 'كانونی یەکەم'];
  var ku = moment.defineLocale('ku', {
    months: months,
    monthsShort: months,
    weekdays: 'یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌'.split('_'),
    weekdaysShort: 'یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌'.split('_'),
    weekdaysMin: 'ی_د_س_چ_پ_ه_ش'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /ئێواره‌|به‌یانی/,
    isPM: function (input) {
      return /ئێواره‌/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'به‌یانی';
      } else {
        return 'ئێواره‌';
      }
    },
    calendar: {
      sameDay: '[ئه‌مرۆ كاتژمێر] LT',
      nextDay: '[به‌یانی كاتژمێر] LT',
      nextWeek: 'dddd [كاتژمێر] LT',
      lastDay: '[دوێنێ كاتژمێر] LT',
      lastWeek: 'dddd [كاتژمێر] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'له‌ %s',
      past: '%s',
      s: 'چه‌ند چركه‌یه‌ك',
      ss: 'چركه‌ %d',
      m: 'یه‌ك خوله‌ك',
      mm: '%d خوله‌ك',
      h: 'یه‌ك كاتژمێر',
      hh: '%d كاتژمێر',
      d: 'یه‌ك ڕۆژ',
      dd: '%d ڕۆژ',
      M: 'یه‌ك مانگ',
      MM: '%d مانگ',
      y: 'یه‌ك ساڵ',
      yy: '%d ساڵ'
    },
    preparse: function (string) {
      return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
        return numberMap[match];
      }).replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '،');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return ku;
});

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var suffixes = {
    0: '-чү',
    1: '-чи',
    2: '-чи',
    3: '-чү',
    4: '-чү',
    5: '-чи',
    6: '-чы',
    7: '-чи',
    8: '-чи',
    9: '-чу',
    10: '-чу',
    20: '-чы',
    30: '-чу',
    40: '-чы',
    50: '-чү',
    60: '-чы',
    70: '-чи',
    80: '-чи',
    90: '-чу',
    100: '-чү'
  };
  var ky = moment.defineLocale('ky', {
    months: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
    monthsShort: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
    weekdays: 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
    weekdaysShort: 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
    weekdaysMin: 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Бүгүн саат] LT',
      nextDay: '[Эртең саат] LT',
      nextWeek: 'dddd [саат] LT',
      lastDay: '[Кечээ саат] LT',
      lastWeek: '[Өткөн аптанын] dddd [күнү] [саат] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ичинде',
      past: '%s мурун',
      s: 'бирнече секунд',
      ss: '%d секунд',
      m: 'бир мүнөт',
      mm: '%d мүнөт',
      h: 'бир саат',
      hh: '%d саат',
      d: 'бир күн',
      dd: '%d күн',
      M: 'бир ай',
      MM: '%d ай',
      y: 'бир жыл',
      yy: '%d жыл'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
    ordinal: function (number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ky;
});

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eng Minutt', 'enger Minutt'],
      'h': ['eng Stonn', 'enger Stonn'],
      'd': ['een Dag', 'engem Dag'],
      'M': ['ee Mount', 'engem Mount'],
      'y': ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));

    if (eifelerRegelAppliesToNumber(number)) {
      return 'a ' + string;
    }

    return 'an ' + string;
  }

  function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));

    if (eifelerRegelAppliesToNumber(number)) {
      return 'viru ' + string;
    }

    return 'virun ' + string;
  }
  /**
   * Returns true if the word before the given number loses the '-n' ending.
   * e.g. 'an 10 Deeg' but 'a 5 Deeg'
   *
   * @param number {integer}
   * @returns {boolean}
   */


  function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);

    if (isNaN(number)) {
      return false;
    }

    if (number < 0) {
      // Negative Number --> always true
      return true;
    } else if (number < 10) {
      // Only 1 digit
      if (4 <= number && number <= 7) {
        return true;
      }

      return false;
    } else if (number < 100) {
      // 2 digits
      var lastDigit = number % 10,
          firstDigit = number / 10;

      if (lastDigit === 0) {
        return eifelerRegelAppliesToNumber(firstDigit);
      }

      return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
      // 3 or 4 digits --> recursively check first digit
      while (number >= 10) {
        number = number / 10;
      }

      return eifelerRegelAppliesToNumber(number);
    } else {
      // Anything larger than 4 digits: recursively check first n-3 digits
      number = number / 1000;
      return eifelerRegelAppliesToNumber(number);
    }
  }

  var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm [Auer]',
      LTS: 'H:mm:ss [Auer]',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm [Auer]',
      LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
      sameDay: '[Haut um] LT',
      sameElse: 'L',
      nextDay: '[Muer um] LT',
      nextWeek: 'dddd [um] LT',
      lastDay: '[Gëschter um] LT',
      lastWeek: function () {
        // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
        switch (this.day()) {
          case 2:
          case 4:
            return '[Leschten] dddd [um] LT';

          default:
            return '[Leschte] dddd [um] LT';
        }
      }
    },
    relativeTime: {
      future: processFutureTime,
      past: processPastTime,
      s: 'e puer Sekonnen',
      ss: '%d Sekonnen',
      m: processRelativeTime,
      mm: '%d Minutten',
      h: processRelativeTime,
      hh: '%d Stonnen',
      d: processRelativeTime,
      dd: '%d Deeg',
      M: processRelativeTime,
      MM: '%d Méint',
      y: processRelativeTime,
      yy: '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lb;
});

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var lo = moment.defineLocale('lo', {
    months: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
    monthsShort: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
    weekdays: 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
    weekdaysShort: 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
    weekdaysMin: 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'ວັນdddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
    isPM: function (input) {
      return input === 'ຕອນແລງ';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ຕອນເຊົ້າ';
      } else {
        return 'ຕອນແລງ';
      }
    },
    calendar: {
      sameDay: '[ມື້ນີ້ເວລາ] LT',
      nextDay: '[ມື້ອື່ນເວລາ] LT',
      nextWeek: '[ວັນ]dddd[ໜ້າເວລາ] LT',
      lastDay: '[ມື້ວານນີ້ເວລາ] LT',
      lastWeek: '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ອີກ %s',
      past: '%sຜ່ານມາ',
      s: 'ບໍ່ເທົ່າໃດວິນາທີ',
      ss: '%d ວິນາທີ',
      m: '1 ນາທີ',
      mm: '%d ນາທີ',
      h: '1 ຊົ່ວໂມງ',
      hh: '%d ຊົ່ວໂມງ',
      d: '1 ມື້',
      dd: '%d ມື້',
      M: '1 ເດືອນ',
      MM: '%d ເດືອນ',
      y: '1 ປີ',
      yy: '%d ປີ'
    },
    dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
    ordinal: function (number) {
      return 'ທີ່' + number;
    }
  });
  return lo;
});

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var units = {
    'ss': 'sekundė_sekundžių_sekundes',
    'm': 'minutė_minutės_minutę',
    'mm': 'minutės_minučių_minutes',
    'h': 'valanda_valandos_valandą',
    'hh': 'valandos_valandų_valandas',
    'd': 'diena_dienos_dieną',
    'dd': 'dienos_dienų_dienas',
    'M': 'mėnuo_mėnesio_mėnesį',
    'MM': 'mėnesiai_mėnesių_mėnesius',
    'y': 'metai_metų_metus',
    'yy': 'metai_metų_metus'
  };

  function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
      return 'kelios sekundės';
    } else {
      return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
    }
  }

  function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
  }

  function special(number) {
    return number % 10 === 0 || number > 10 && number < 20;
  }

  function forms(key) {
    return units[key].split('_');
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    if (number === 1) {
      return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
      return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
      if (isFuture) {
        return result + forms(key)[1];
      } else {
        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
      }
    }
  }

  var lt = moment.defineLocale('lt', {
    months: {
      format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
      standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
      isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays: {
      format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
      standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
      isFormat: /dddd HH:mm/
    },
    weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
    weekdaysMin: 'S_P_A_T_K_Pn_Š'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY [m.] MMMM D [d.]',
      LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
      l: 'YYYY-MM-DD',
      ll: 'YYYY [m.] MMMM D [d.]',
      lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar: {
      sameDay: '[Šiandien] LT',
      nextDay: '[Rytoj] LT',
      nextWeek: 'dddd LT',
      lastDay: '[Vakar] LT',
      lastWeek: '[Praėjusį] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'po %s',
      past: 'prieš %s',
      s: translateSeconds,
      ss: translate,
      m: translateSingular,
      mm: translate,
      h: translateSingular,
      hh: translate,
      d: translateSingular,
      dd: translate,
      M: translateSingular,
      MM: translate,
      y: translateSingular,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal: function (number) {
      return number + '-oji';
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lt;
});

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var units = {
    'ss': 'sekundes_sekundēm_sekunde_sekundes'.split('_'),
    'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
    'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
    'h': 'stundas_stundām_stunda_stundas'.split('_'),
    'hh': 'stundas_stundām_stunda_stundas'.split('_'),
    'd': 'dienas_dienām_diena_dienas'.split('_'),
    'dd': 'dienas_dienām_diena_dienas'.split('_'),
    'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
    'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
    'y': 'gada_gadiem_gads_gadi'.split('_'),
    'yy': 'gada_gadiem_gads_gadi'.split('_')
  };
  /**
   * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
   */

  function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
      // E.g. "21 minūte", "3 minūtes".
      return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
      // E.g. "21 minūtes" as in "pēc 21 minūtes".
      // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
      return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
  }

  function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
  }

  function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
  }

  var lv = moment.defineLocale('lv', {
    months: 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY.',
      LL: 'YYYY. [gada] D. MMMM',
      LLL: 'YYYY. [gada] D. MMMM, HH:mm',
      LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar: {
      sameDay: '[Šodien pulksten] LT',
      nextDay: '[Rīt pulksten] LT',
      nextWeek: 'dddd [pulksten] LT',
      lastDay: '[Vakar pulksten] LT',
      lastWeek: '[Pagājušā] dddd [pulksten] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'pēc %s',
      past: 'pirms %s',
      s: relativeSeconds,
      ss: relativeTimeWithPlural,
      m: relativeTimeWithSingular,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithSingular,
      hh: relativeTimeWithPlural,
      d: relativeTimeWithSingular,
      dd: relativeTimeWithPlural,
      M: relativeTimeWithSingular,
      MM: relativeTimeWithPlural,
      y: relativeTimeWithSingular,
      yy: relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lv;
});

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekund', 'sekunda', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mjesec', 'mjeseca', 'mjeseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function (number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sjutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juče u] LT',
      lastWeek: function () {
        var lastWeekDays = ['[prošle] [nedjelje] [u] LT', '[prošlog] [ponedjeljka] [u] LT', '[prošlog] [utorka] [u] LT', '[prošle] [srijede] [u] LT', '[prošlog] [četvrtka] [u] LT', '[prošlog] [petka] [u] LT', '[prošle] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mjesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return me;
});

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var mi = moment.defineLocale('mi', {
    months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
    weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
    weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [i] HH:mm',
      LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
      sameDay: '[i teie mahana, i] LT',
      nextDay: '[apopo i] LT',
      nextWeek: 'dddd [i] LT',
      lastDay: '[inanahi i] LT',
      lastWeek: 'dddd [whakamutunga i] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i roto i %s',
      past: '%s i mua',
      s: 'te hēkona ruarua',
      ss: '%d hēkona',
      m: 'he meneti',
      mm: '%d meneti',
      h: 'te haora',
      hh: '%d haora',
      d: 'he ra',
      dd: '%d ra',
      M: 'he marama',
      MM: '%d marama',
      y: 'he tau',
      yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return mi;
});

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var mk = moment.defineLocale('mk', {
    months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
    monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
    weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
    weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
    weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Денес во] LT',
      nextDay: '[Утре во] LT',
      nextWeek: '[Во] dddd [во] LT',
      lastDay: '[Вчера во] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[Изминатата] dddd [во] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[Изминатиот] dddd [во] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'после %s',
      past: 'пред %s',
      s: 'неколку секунди',
      ss: '%d секунди',
      m: 'минута',
      mm: '%d минути',
      h: 'час',
      hh: '%d часа',
      d: 'ден',
      dd: '%d дена',
      M: 'месец',
      MM: '%d месеци',
      y: 'година',
      yy: '%d години'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
    ordinal: function (number) {
      var lastDigit = number % 10,
          last2Digits = number % 100;

      if (number === 0) {
        return number + '-ев';
      } else if (last2Digits === 0) {
        return number + '-ен';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-ти';
      } else if (lastDigit === 1) {
        return number + '-ви';
      } else if (lastDigit === 2) {
        return number + '-ри';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-ми';
      } else {
        return number + '-ти';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return mk;
});

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ml = moment.defineLocale('ml', {
    months: 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
    monthsShort: 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
    monthsParseExact: true,
    weekdays: 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
    weekdaysShort: 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
    weekdaysMin: 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
    longDateFormat: {
      LT: 'A h:mm -നു',
      LTS: 'A h:mm:ss -നു',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm -നു',
      LLLL: 'dddd, D MMMM YYYY, A h:mm -നു'
    },
    calendar: {
      sameDay: '[ഇന്ന്] LT',
      nextDay: '[നാളെ] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[ഇന്നലെ] LT',
      lastWeek: '[കഴിഞ്ഞ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s കഴിഞ്ഞ്',
      past: '%s മുൻപ്',
      s: 'അൽപ നിമിഷങ്ങൾ',
      ss: '%d സെക്കൻഡ്',
      m: 'ഒരു മിനിറ്റ്',
      mm: '%d മിനിറ്റ്',
      h: 'ഒരു മണിക്കൂർ',
      hh: '%d മണിക്കൂർ',
      d: 'ഒരു ദിവസം',
      dd: '%d ദിവസം',
      M: 'ഒരു മാസം',
      MM: '%d മാസം',
      y: 'ഒരു വർഷം',
      yy: '%d വർഷം'
    },
    meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'രാത്രി' && hour >= 4 || meridiem === 'ഉച്ച കഴിഞ്ഞ്' || meridiem === 'വൈകുന്നേരം') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'രാത്രി';
      } else if (hour < 12) {
        return 'രാവിലെ';
      } else if (hour < 17) {
        return 'ഉച്ച കഴിഞ്ഞ്';
      } else if (hour < 20) {
        return 'വൈകുന്നേരം';
      } else {
        return 'രാത്രി';
      }
    }
  });
  return ml;
});

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function translate(number, withoutSuffix, key, isFuture) {
    switch (key) {
      case 's':
        return withoutSuffix ? 'хэдхэн секунд' : 'хэдхэн секундын';

      case 'ss':
        return number + (withoutSuffix ? ' секунд' : ' секундын');

      case 'm':
      case 'mm':
        return number + (withoutSuffix ? ' минут' : ' минутын');

      case 'h':
      case 'hh':
        return number + (withoutSuffix ? ' цаг' : ' цагийн');

      case 'd':
      case 'dd':
        return number + (withoutSuffix ? ' өдөр' : ' өдрийн');

      case 'M':
      case 'MM':
        return number + (withoutSuffix ? ' сар' : ' сарын');

      case 'y':
      case 'yy':
        return number + (withoutSuffix ? ' жил' : ' жилийн');

      default:
        return number;
    }
  }

  var mn = moment.defineLocale('mn', {
    months: 'Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар'.split('_'),
    monthsShort: '1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар'.split('_'),
    monthsParseExact: true,
    weekdays: 'Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба'.split('_'),
    weekdaysShort: 'Ням_Дав_Мяг_Лха_Пүр_Баа_Бям'.split('_'),
    weekdaysMin: 'Ня_Да_Мя_Лх_Пү_Ба_Бя'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY оны MMMMын D',
      LLL: 'YYYY оны MMMMын D HH:mm',
      LLLL: 'dddd, YYYY оны MMMMын D HH:mm'
    },
    meridiemParse: /ҮӨ|ҮХ/i,
    isPM: function (input) {
      return input === 'ҮХ';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ҮӨ';
      } else {
        return 'ҮХ';
      }
    },
    calendar: {
      sameDay: '[Өнөөдөр] LT',
      nextDay: '[Маргааш] LT',
      nextWeek: '[Ирэх] dddd LT',
      lastDay: '[Өчигдөр] LT',
      lastWeek: '[Өнгөрсөн] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s дараа',
      past: '%s өмнө',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + ' өдөр';

        default:
          return number;
      }
    }
  });
  return mn;
});

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '१',
    '2': '२',
    '3': '३',
    '4': '४',
    '5': '५',
    '6': '६',
    '7': '७',
    '8': '८',
    '9': '९',
    '0': '०'
  },
      numberMap = {
    '१': '1',
    '२': '2',
    '३': '3',
    '४': '4',
    '५': '5',
    '६': '6',
    '७': '7',
    '८': '8',
    '९': '9',
    '०': '0'
  };

  function relativeTimeMr(number, withoutSuffix, string, isFuture) {
    var output = '';

    if (withoutSuffix) {
      switch (string) {
        case 's':
          output = 'काही सेकंद';
          break;

        case 'ss':
          output = '%d सेकंद';
          break;

        case 'm':
          output = 'एक मिनिट';
          break;

        case 'mm':
          output = '%d मिनिटे';
          break;

        case 'h':
          output = 'एक तास';
          break;

        case 'hh':
          output = '%d तास';
          break;

        case 'd':
          output = 'एक दिवस';
          break;

        case 'dd':
          output = '%d दिवस';
          break;

        case 'M':
          output = 'एक महिना';
          break;

        case 'MM':
          output = '%d महिने';
          break;

        case 'y':
          output = 'एक वर्ष';
          break;

        case 'yy':
          output = '%d वर्षे';
          break;
      }
    } else {
      switch (string) {
        case 's':
          output = 'काही सेकंदां';
          break;

        case 'ss':
          output = '%d सेकंदां';
          break;

        case 'm':
          output = 'एका मिनिटा';
          break;

        case 'mm':
          output = '%d मिनिटां';
          break;

        case 'h':
          output = 'एका तासा';
          break;

        case 'hh':
          output = '%d तासां';
          break;

        case 'd':
          output = 'एका दिवसा';
          break;

        case 'dd':
          output = '%d दिवसां';
          break;

        case 'M':
          output = 'एका महिन्या';
          break;

        case 'MM':
          output = '%d महिन्यां';
          break;

        case 'y':
          output = 'एका वर्षा';
          break;

        case 'yy':
          output = '%d वर्षां';
          break;
      }
    }

    return output.replace(/%d/i, number);
  }

  var mr = moment.defineLocale('mr', {
    months: 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
    monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
    monthsParseExact: true,
    weekdays: 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
    weekdaysShort: 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
    weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
    longDateFormat: {
      LT: 'A h:mm वाजता',
      LTS: 'A h:mm:ss वाजता',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm वाजता',
      LLLL: 'dddd, D MMMM YYYY, A h:mm वाजता'
    },
    calendar: {
      sameDay: '[आज] LT',
      nextDay: '[उद्या] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[काल] LT',
      lastWeek: '[मागील] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%sमध्ये',
      past: '%sपूर्वी',
      s: relativeTimeMr,
      ss: relativeTimeMr,
      m: relativeTimeMr,
      mm: relativeTimeMr,
      h: relativeTimeMr,
      hh: relativeTimeMr,
      d: relativeTimeMr,
      dd: relativeTimeMr,
      M: relativeTimeMr,
      MM: relativeTimeMr,
      y: relativeTimeMr,
      yy: relativeTimeMr
    },
    preparse: function (string) {
      return string.replace(/[१२३४५६७८९०]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'रात्री') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'सकाळी') {
        return hour;
      } else if (meridiem === 'दुपारी') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'सायंकाळी') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'रात्री';
      } else if (hour < 10) {
        return 'सकाळी';
      } else if (hour < 17) {
        return 'दुपारी';
      } else if (hour < 20) {
        return 'सायंकाळी';
      } else {
        return 'रात्री';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return mr;
});

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ms = moment.defineLocale('ms', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ms;
});

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var msMy = moment.defineLocale('ms-my', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return msMy;
});

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var mt = moment.defineLocale('mt', {
    months: 'Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru'.split('_'),
    monthsShort: 'Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ'.split('_'),
    weekdays: 'Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt'.split('_'),
    weekdaysShort: 'Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib'.split('_'),
    weekdaysMin: 'Ħa_Tn_Tl_Er_Ħa_Ġi_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Illum fil-]LT',
      nextDay: '[Għada fil-]LT',
      nextWeek: 'dddd [fil-]LT',
      lastDay: '[Il-bieraħ fil-]LT',
      lastWeek: 'dddd [li għadda] [fil-]LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'f’ %s',
      past: '%s ilu',
      s: 'ftit sekondi',
      ss: '%d sekondi',
      m: 'minuta',
      mm: '%d minuti',
      h: 'siegħa',
      hh: '%d siegħat',
      d: 'ġurnata',
      dd: '%d ġranet',
      M: 'xahar',
      MM: '%d xhur',
      y: 'sena',
      yy: '%d sni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return mt;
});

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '၁',
    '2': '၂',
    '3': '၃',
    '4': '၄',
    '5': '၅',
    '6': '၆',
    '7': '၇',
    '8': '၈',
    '9': '၉',
    '0': '၀'
  },
      numberMap = {
    '၁': '1',
    '၂': '2',
    '၃': '3',
    '၄': '4',
    '၅': '5',
    '၆': '6',
    '၇': '7',
    '၈': '8',
    '၉': '9',
    '၀': '0'
  };
  var my = moment.defineLocale('my', {
    months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
    monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
    weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
    weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
    weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ယနေ.] LT [မှာ]',
      nextDay: '[မနက်ဖြန်] LT [မှာ]',
      nextWeek: 'dddd LT [မှာ]',
      lastDay: '[မနေ.က] LT [မှာ]',
      lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'လာမည့် %s မှာ',
      past: 'လွန်ခဲ့သော %s က',
      s: 'စက္ကန်.အနည်းငယ်',
      ss: '%d စက္ကန့်',
      m: 'တစ်မိနစ်',
      mm: '%d မိနစ်',
      h: 'တစ်နာရီ',
      hh: '%d နာရီ',
      d: 'တစ်ရက်',
      dd: '%d ရက်',
      M: 'တစ်လ',
      MM: '%d လ',
      y: 'တစ်နှစ်',
      yy: '%d နှစ်'
    },
    preparse: function (string) {
      return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return my;
});

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var nb = moment.defineLocale('nb', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
    weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
    weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[i går kl.] LT',
      lastWeek: '[forrige] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'noen sekunder',
      ss: '%d sekunder',
      m: 'ett minutt',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dager',
      M: 'en måned',
      MM: '%d måneder',
      y: 'ett år',
      yy: '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nb;
});

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '१',
    '2': '२',
    '3': '३',
    '4': '४',
    '5': '५',
    '6': '६',
    '7': '७',
    '8': '८',
    '9': '९',
    '0': '०'
  },
      numberMap = {
    '१': '1',
    '२': '2',
    '३': '3',
    '४': '4',
    '५': '5',
    '६': '6',
    '७': '7',
    '८': '8',
    '९': '9',
    '०': '0'
  };
  var ne = moment.defineLocale('ne', {
    months: 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
    monthsShort: 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
    monthsParseExact: true,
    weekdays: 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
    weekdaysShort: 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
    weekdaysMin: 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'Aको h:mm बजे',
      LTS: 'Aको h:mm:ss बजे',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, Aको h:mm बजे',
      LLLL: 'dddd, D MMMM YYYY, Aको h:mm बजे'
    },
    preparse: function (string) {
      return string.replace(/[१२३४५६७८९०]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'राति') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'बिहान') {
        return hour;
      } else if (meridiem === 'दिउँसो') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'साँझ') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 3) {
        return 'राति';
      } else if (hour < 12) {
        return 'बिहान';
      } else if (hour < 16) {
        return 'दिउँसो';
      } else if (hour < 20) {
        return 'साँझ';
      } else {
        return 'राति';
      }
    },
    calendar: {
      sameDay: '[आज] LT',
      nextDay: '[भोलि] LT',
      nextWeek: '[आउँदो] dddd[,] LT',
      lastDay: '[हिजो] LT',
      lastWeek: '[गएको] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%sमा',
      past: '%s अगाडि',
      s: 'केही क्षण',
      ss: '%d सेकेण्ड',
      m: 'एक मिनेट',
      mm: '%d मिनेट',
      h: 'एक घण्टा',
      hh: '%d घण्टा',
      d: 'एक दिन',
      dd: '%d दिन',
      M: 'एक महिना',
      MM: '%d महिना',
      y: 'एक बर्ष',
      yy: '%d बर्ष'
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return ne;
});

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
  var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
  var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nl = moment.defineLocale('nl', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'één minuut',
      mm: '%d minuten',
      h: 'één uur',
      hh: '%d uur',
      d: 'één dag',
      dd: '%d dagen',
      M: 'één maand',
      MM: '%d maanden',
      y: 'één jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nl;
});

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
  var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
  var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nlBe = moment.defineLocale('nl-be', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'één minuut',
      mm: '%d minuten',
      h: 'één uur',
      hh: '%d uur',
      d: 'één dag',
      dd: '%d dagen',
      M: 'één maand',
      MM: '%d maanden',
      y: 'één jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nlBe;
});

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var nn = moment.defineLocale('nn', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort: 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
    weekdaysMin: 'su_må_ty_on_to_fr_lø'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[I dag klokka] LT',
      nextDay: '[I morgon klokka] LT',
      nextWeek: 'dddd [klokka] LT',
      lastDay: '[I går klokka] LT',
      lastWeek: '[Føregåande] dddd [klokka] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s sidan',
      s: 'nokre sekund',
      ss: '%d sekund',
      m: 'eit minutt',
      mm: '%d minutt',
      h: 'ein time',
      hh: '%d timar',
      d: 'ein dag',
      dd: '%d dagar',
      M: 'ein månad',
      MM: '%d månader',
      y: 'eit år',
      yy: '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nn;
});

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '੧',
    '2': '੨',
    '3': '੩',
    '4': '੪',
    '5': '੫',
    '6': '੬',
    '7': '੭',
    '8': '੮',
    '9': '੯',
    '0': '੦'
  },
      numberMap = {
    '੧': '1',
    '੨': '2',
    '੩': '3',
    '੪': '4',
    '੫': '5',
    '੬': '6',
    '੭': '7',
    '੮': '8',
    '੯': '9',
    '੦': '0'
  };
  var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
    months: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
    monthsShort: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
    weekdays: 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
    weekdaysShort: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
    weekdaysMin: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ਵਜੇ',
      LTS: 'A h:mm:ss ਵਜੇ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ਵਜੇ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
    },
    calendar: {
      sameDay: '[ਅਜ] LT',
      nextDay: '[ਕਲ] LT',
      nextWeek: '[ਅਗਲਾ] dddd, LT',
      lastDay: '[ਕਲ] LT',
      lastWeek: '[ਪਿਛਲੇ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ਵਿੱਚ',
      past: '%s ਪਿਛਲੇ',
      s: 'ਕੁਝ ਸਕਿੰਟ',
      ss: '%d ਸਕਿੰਟ',
      m: 'ਇਕ ਮਿੰਟ',
      mm: '%d ਮਿੰਟ',
      h: 'ਇੱਕ ਘੰਟਾ',
      hh: '%d ਘੰਟੇ',
      d: 'ਇੱਕ ਦਿਨ',
      dd: '%d ਦਿਨ',
      M: 'ਇੱਕ ਮਹੀਨਾ',
      MM: '%d ਮਹੀਨੇ',
      y: 'ਇੱਕ ਸਾਲ',
      yy: '%d ਸਾਲ'
    },
    preparse: function (string) {
      return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'ਰਾਤ') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'ਸਵੇਰ') {
        return hour;
      } else if (meridiem === 'ਦੁਪਹਿਰ') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'ਸ਼ਾਮ') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'ਰਾਤ';
      } else if (hour < 10) {
        return 'ਸਵੇਰ';
      } else if (hour < 17) {
        return 'ਦੁਪਹਿਰ';
      } else if (hour < 20) {
        return 'ਸ਼ਾਮ';
      } else {
        return 'ਰਾਤ';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return paIn;
});

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
      monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');

  function plural(n) {
    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        return result + (plural(number) ? 'sekundy' : 'sekund');

      case 'm':
        return withoutSuffix ? 'minuta' : 'minutę';

      case 'mm':
        return result + (plural(number) ? 'minuty' : 'minut');

      case 'h':
        return withoutSuffix ? 'godzina' : 'godzinę';

      case 'hh':
        return result + (plural(number) ? 'godziny' : 'godzin');

      case 'MM':
        return result + (plural(number) ? 'miesiące' : 'miesięcy');

      case 'yy':
        return result + (plural(number) ? 'lata' : 'lat');
    }
  }

  var pl = moment.defineLocale('pl', {
    months: function (momentToFormat, format) {
      if (!momentToFormat) {
        return monthsNominative;
      } else if (format === '') {
        // Hack: if format empty we know this is used to generate
        // RegExp by moment. Give then back both valid forms of months
        // in RegExp ready format.
        return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
      } else if (/D MMMM/.test(format)) {
        return monthsSubjective[momentToFormat.month()];
      } else {
        return monthsNominative[momentToFormat.month()];
      }
    },
    monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
    weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
    weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
    weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Dziś o] LT',
      nextDay: '[Jutro o] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[W niedzielę o] LT';

          case 2:
            return '[We wtorek o] LT';

          case 3:
            return '[W środę o] LT';

          case 6:
            return '[W sobotę o] LT';

          default:
            return '[W] dddd [o] LT';
        }
      },
      lastDay: '[Wczoraj o] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[W zeszłą niedzielę o] LT';

          case 3:
            return '[W zeszłą środę o] LT';

          case 6:
            return '[W zeszłą sobotę o] LT';

          default:
            return '[W zeszły] dddd [o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: '%s temu',
      s: 'kilka sekund',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: '1 dzień',
      dd: '%d dni',
      M: 'miesiąc',
      MM: translate,
      y: 'rok',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return pl;
});

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var pt = moment.defineLocale('pt', {
    months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
    weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hoje às] LT',
      nextDay: '[Amanhã às] LT',
      nextWeek: 'dddd [às] LT',
      lastDay: '[Ontem às] LT',
      lastWeek: function () {
        return this.day() === 0 || this.day() === 6 ? '[Último] dddd [às] LT' : // Saturday + Sunday
        '[Última] dddd [às] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'há %s',
      s: 'segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um mês',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return pt;
});

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ptBr = moment.defineLocale('pt-br', {
    months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
    weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
    },
    calendar: {
      sameDay: '[Hoje às] LT',
      nextDay: '[Amanhã às] LT',
      nextWeek: 'dddd [às] LT',
      lastDay: '[Ontem às] LT',
      lastWeek: function () {
        return this.day() === 0 || this.day() === 6 ? '[Último] dddd [às] LT' : // Saturday + Sunday
        '[Última] dddd [às] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'há %s',
      s: 'poucos segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um mês',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº'
  });
  return ptBr;
});

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': 'secunde',
      'mm': 'minute',
      'hh': 'ore',
      'dd': 'zile',
      'MM': 'luni',
      'yy': 'ani'
    },
        separator = ' ';

    if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
      separator = ' de ';
    }

    return number + separator + format[key];
  }

  var ro = moment.defineLocale('ro', {
    months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
    weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
    weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[azi la] LT',
      nextDay: '[mâine la] LT',
      nextWeek: 'dddd [la] LT',
      lastDay: '[ieri la] LT',
      lastWeek: '[fosta] dddd [la] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'peste %s',
      past: '%s în urmă',
      s: 'câteva secunde',
      ss: relativeTimeWithPlural,
      m: 'un minut',
      mm: relativeTimeWithPlural,
      h: 'o oră',
      hh: relativeTimeWithPlural,
      d: 'o zi',
      dd: relativeTimeWithPlural,
      M: 'o lună',
      MM: relativeTimeWithPlural,
      y: 'un an',
      yy: relativeTimeWithPlural
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ro;
});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
      'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
      'hh': 'час_часа_часов',
      'dd': 'день_дня_дней',
      'MM': 'месяц_месяца_месяцев',
      'yy': 'год_года_лет'
    };

    if (key === 'm') {
      return withoutSuffix ? 'минута' : 'минуту';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i]; // http://new.gramota.ru/spravka/rules/139-prop : § 103
  // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
  // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753

  var ru = moment.defineLocale('ru', {
    months: {
      format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
      standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
    },
    monthsShort: {
      // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
      format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
      standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
    },
    weekdays: {
      standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
      format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
      isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
    },
    weekdaysShort: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
    weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
    monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
    // копия предыдущего
    monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
    // полные названия с падежами
    monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
    // Выражение, которое соотвествует только сокращённым формам
    monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY г.',
      LLL: 'D MMMM YYYY г., H:mm',
      LLLL: 'dddd, D MMMM YYYY г., H:mm'
    },
    calendar: {
      sameDay: '[Сегодня, в] LT',
      nextDay: '[Завтра, в] LT',
      lastDay: '[Вчера, в] LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[В следующее] dddd, [в] LT';

            case 1:
            case 2:
            case 4:
              return '[В следующий] dddd, [в] LT';

            case 3:
            case 5:
            case 6:
              return '[В следующую] dddd, [в] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[Во] dddd, [в] LT';
          } else {
            return '[В] dddd, [в] LT';
          }
        }
      },
      lastWeek: function (now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[В прошлое] dddd, [в] LT';

            case 1:
            case 2:
            case 4:
              return '[В прошлый] dddd, [в] LT';

            case 3:
            case 5:
            case 6:
              return '[В прошлую] dddd, [в] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[Во] dddd, [в] LT';
          } else {
            return '[В] dddd, [в] LT';
          }
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'через %s',
      past: '%s назад',
      s: 'несколько секунд',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: 'час',
      hh: relativeTimeWithPlural,
      d: 'день',
      dd: relativeTimeWithPlural,
      M: 'месяц',
      MM: relativeTimeWithPlural,
      y: 'год',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /ночи|утра|дня|вечера/i,
    isPM: function (input) {
      return /^(дня|вечера)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'ночи';
      } else if (hour < 12) {
        return 'утра';
      } else if (hour < 17) {
        return 'дня';
      } else {
        return 'вечера';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
          return number + '-й';

        case 'D':
          return number + '-го';

        case 'w':
        case 'W':
          return number + '-я';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ru;
});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var months = ['جنوري', 'فيبروري', 'مارچ', 'اپريل', 'مئي', 'جون', 'جولاءِ', 'آگسٽ', 'سيپٽمبر', 'آڪٽوبر', 'نومبر', 'ڊسمبر'];
  var days = ['آچر', 'سومر', 'اڱارو', 'اربع', 'خميس', 'جمع', 'ڇنڇر'];
  var sd = moment.defineLocale('sd', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd، D MMMM YYYY HH:mm'
    },
    meridiemParse: /صبح|شام/,
    isPM: function (input) {
      return 'شام' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'صبح';
      }

      return 'شام';
    },
    calendar: {
      sameDay: '[اڄ] LT',
      nextDay: '[سڀاڻي] LT',
      nextWeek: 'dddd [اڳين هفتي تي] LT',
      lastDay: '[ڪالهه] LT',
      lastWeek: '[گزريل هفتي] dddd [تي] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s پوء',
      past: '%s اڳ',
      s: 'چند سيڪنڊ',
      ss: '%d سيڪنڊ',
      m: 'هڪ منٽ',
      mm: '%d منٽ',
      h: 'هڪ ڪلاڪ',
      hh: '%d ڪلاڪ',
      d: 'هڪ ڏينهن',
      dd: '%d ڏينهن',
      M: 'هڪ مهينو',
      MM: '%d مهينا',
      y: 'هڪ سال',
      yy: '%d سال'
    },
    preparse: function (string) {
      return string.replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '،');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sd;
});

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var se = moment.defineLocale('se', {
    months: 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
    monthsShort: 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
    weekdays: 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
    weekdaysShort: 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
    weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'MMMM D. [b.] YYYY',
      LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
      LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar: {
      sameDay: '[otne ti] LT',
      nextDay: '[ihttin ti] LT',
      nextWeek: 'dddd [ti] LT',
      lastDay: '[ikte ti] LT',
      lastWeek: '[ovddit] dddd [ti] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s geažes',
      past: 'maŋit %s',
      s: 'moadde sekunddat',
      ss: '%d sekunddat',
      m: 'okta minuhta',
      mm: '%d minuhtat',
      h: 'okta diimmu',
      hh: '%d diimmut',
      d: 'okta beaivi',
      dd: '%d beaivvit',
      M: 'okta mánnu',
      MM: '%d mánut',
      y: 'okta jahki',
      yy: '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return se;
});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';
  /*jshint -W100*/

  var si = moment.defineLocale('si', {
    months: 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
    monthsShort: 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
    weekdays: 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
    weekdaysShort: 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
    weekdaysMin: 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'a h:mm',
      LTS: 'a h:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D, a h:mm',
      LLLL: 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
    },
    calendar: {
      sameDay: '[අද] LT[ට]',
      nextDay: '[හෙට] LT[ට]',
      nextWeek: 'dddd LT[ට]',
      lastDay: '[ඊයේ] LT[ට]',
      lastWeek: '[පසුගිය] dddd LT[ට]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%sකින්',
      past: '%sකට පෙර',
      s: 'තත්පර කිහිපය',
      ss: 'තත්පර %d',
      m: 'මිනිත්තුව',
      mm: 'මිනිත්තු %d',
      h: 'පැය',
      hh: 'පැය %d',
      d: 'දිනය',
      dd: 'දින %d',
      M: 'මාසය',
      MM: 'මාස %d',
      y: 'වසර',
      yy: 'වසර %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
    ordinal: function (number) {
      return number + ' වැනි';
    },
    meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
    isPM: function (input) {
      return input === 'ප.ව.' || input === 'පස් වරු';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'ප.ව.' : 'පස් වරු';
      } else {
        return isLower ? 'පෙ.ව.' : 'පෙර වරු';
      }
    }
  });
  return si;
});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
      monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');

  function plural(n) {
    return n > 1 && n < 5;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami';

      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'sekúnd');
        } else {
          return result + 'sekundami';
        }

        break;

      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou';

      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minúty' : 'minút');
        } else {
          return result + 'minútami';
        }

        break;

      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodín');
        } else {
          return result + 'hodinami';
        }

        break;

      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'deň' : 'dňom';

      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dni' : 'dní');
        } else {
          return result + 'dňami';
        }

        break;

      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';

      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'mesiace' : 'mesiacov');
        } else {
          return result + 'mesiacmi';
        }

        break;

      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokom';

      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'rokov');
        } else {
          return result + 'rokmi';
        }

        break;
    }
  }

  var sk = moment.defineLocale('sk', {
    months: months,
    monthsShort: monthsShort,
    weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
    weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
    weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[dnes o] LT',
      nextDay: '[zajtra o] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v nedeľu o] LT';

          case 1:
          case 2:
            return '[v] dddd [o] LT';

          case 3:
            return '[v stredu o] LT';

          case 4:
            return '[vo štvrtok o] LT';

          case 5:
            return '[v piatok o] LT';

          case 6:
            return '[v sobotu o] LT';
        }
      },
      lastDay: '[včera o] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[minulú nedeľu o] LT';

          case 1:
          case 2:
            return '[minulý] dddd [o] LT';

          case 3:
            return '[minulú stredu o] LT';

          case 4:
          case 5:
            return '[minulý] dddd [o] LT';

          case 6:
            return '[minulú sobotu o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pred %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sk;
});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';

      case 'ss':
        if (number === 1) {
          result += withoutSuffix ? 'sekundo' : 'sekundi';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
        } else {
          result += 'sekund';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'ena minuta' : 'eno minuto';

      case 'mm':
        if (number === 1) {
          result += withoutSuffix ? 'minuta' : 'minuto';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'minute' : 'minutami';
        } else {
          result += withoutSuffix || isFuture ? 'minut' : 'minutami';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'ena ura' : 'eno uro';

      case 'hh':
        if (number === 1) {
          result += withoutSuffix ? 'ura' : 'uro';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'uri' : 'urama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'ure' : 'urami';
        } else {
          result += withoutSuffix || isFuture ? 'ur' : 'urami';
        }

        return result;

      case 'd':
        return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';

      case 'dd':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'dan' : 'dnem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
        } else {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
        }

        return result;

      case 'M':
        return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';

      case 'MM':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
        } else {
          result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
        }

        return result;

      case 'y':
        return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';

      case 'yy':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'leto' : 'letom';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'leti' : 'letoma';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'leta' : 'leti';
        } else {
          result += withoutSuffix || isFuture ? 'let' : 'leti';
        }

        return result;
    }
  }

  var sl = moment.defineLocale('sl', {
    months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
    weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
    weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danes ob] LT',
      nextDay: '[jutri ob] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v] [nedeljo] [ob] LT';

          case 3:
            return '[v] [sredo] [ob] LT';

          case 6:
            return '[v] [soboto] [ob] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[v] dddd [ob] LT';
        }
      },
      lastDay: '[včeraj ob] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[prejšnjo] [nedeljo] [ob] LT';

          case 3:
            return '[prejšnjo] [sredo] [ob] LT';

          case 6:
            return '[prejšnjo] [soboto] [ob] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[prejšnji] dddd [ob] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'čez %s',
      past: 'pred %s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sl;
});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var sq = moment.defineLocale('sq', {
    months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
    monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
    weekdays: 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
    weekdaysShort: 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
    weekdaysMin: 'D_H_Ma_Më_E_P_Sh'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
      return input.charAt(0) === 'M';
    },
    meridiem: function (hours, minutes, isLower) {
      return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Sot në] LT',
      nextDay: '[Nesër në] LT',
      nextWeek: 'dddd [në] LT',
      lastDay: '[Dje në] LT',
      lastWeek: 'dddd [e kaluar në] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'në %s',
      past: '%s më parë',
      s: 'disa sekonda',
      ss: '%d sekonda',
      m: 'një minutë',
      mm: '%d minuta',
      h: 'një orë',
      hh: '%d orë',
      d: 'një ditë',
      dd: '%d ditë',
      M: 'një muaj',
      MM: '%d muaj',
      y: 'një vit',
      yy: '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sq;
});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekunda', 'sekunde', 'sekundi'],
      m: ['jedan minut', 'jedne minute'],
      mm: ['minut', 'minute', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mesec', 'meseca', 'meseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function (number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedelju] [u] LT';

          case 3:
            return '[u] [sredu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juče u] LT',
      lastWeek: function () {
        var lastWeekDays = ['[prošle] [nedelje] [u] LT', '[prošlog] [ponedeljka] [u] LT', '[prošlog] [utorka] [u] LT', '[prošle] [srede] [u] LT', '[prošlog] [četvrtka] [u] LT', '[prošlog] [petka] [u] LT', '[prošle] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pre %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sr;
});

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['секунда', 'секунде', 'секунди'],
      m: ['један минут', 'једне минуте'],
      mm: ['минут', 'минуте', 'минута'],
      h: ['један сат', 'једног сата'],
      hh: ['сат', 'сата', 'сати'],
      dd: ['дан', 'дана', 'дана'],
      MM: ['месец', 'месеца', 'месеци'],
      yy: ['година', 'године', 'година']
    },
    correctGrammaticalCase: function (number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function (number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var srCyrl = moment.defineLocale('sr-cyrl', {
    months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
    monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
    monthsParseExact: true,
    weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
    weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
    weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[данас у] LT',
      nextDay: '[сутра у] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[у] [недељу] [у] LT';

          case 3:
            return '[у] [среду] [у] LT';

          case 6:
            return '[у] [суботу] [у] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[у] dddd [у] LT';
        }
      },
      lastDay: '[јуче у] LT',
      lastWeek: function () {
        var lastWeekDays = ['[прошле] [недеље] [у] LT', '[прошлог] [понедељка] [у] LT', '[прошлог] [уторка] [у] LT', '[прошле] [среде] [у] LT', '[прошлог] [четвртка] [у] LT', '[прошлог] [петка] [у] LT', '[прошле] [суботе] [у] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'за %s',
      past: 'пре %s',
      s: 'неколико секунди',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'дан',
      dd: translator.translate,
      M: 'месец',
      MM: translator.translate,
      y: 'годину',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return srCyrl;
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ss = moment.defineLocale('ss', {
    months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Namuhla nga] LT',
      nextDay: '[Kusasa nga] LT',
      nextWeek: 'dddd [nga] LT',
      lastDay: '[Itolo nga] LT',
      lastWeek: 'dddd [leliphelile] [nga] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'nga %s',
      past: 'wenteka nga %s',
      s: 'emizuzwana lomcane',
      ss: '%d mzuzwana',
      m: 'umzuzu',
      mm: '%d emizuzu',
      h: 'lihora',
      hh: '%d emahora',
      d: 'lilanga',
      dd: '%d emalanga',
      M: 'inyanga',
      MM: '%d tinyanga',
      y: 'umnyaka',
      yy: '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'ekuseni';
      } else if (hours < 15) {
        return 'emini';
      } else if (hours < 19) {
        return 'entsambama';
      } else {
        return 'ebusuku';
      }
    },
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'ekuseni') {
        return hour;
      } else if (meridiem === 'emini') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
        if (hour === 0) {
          return 0;
        }

        return hour + 12;
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ss;
});

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var sv = moment.defineLocale('sv', {
    months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
    weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
    weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Idag] LT',
      nextDay: '[Imorgon] LT',
      lastDay: '[Igår] LT',
      nextWeek: '[På] dddd LT',
      lastWeek: '[I] dddd[s] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: 'för %s sedan',
      s: 'några sekunder',
      ss: '%d sekunder',
      m: 'en minut',
      mm: '%d minuter',
      h: 'en timme',
      hh: '%d timmar',
      d: 'en dag',
      dd: '%d dagar',
      M: 'en månad',
      MM: '%d månader',
      y: 'ett år',
      yy: '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'e' : b === 1 ? 'a' : b === 2 ? 'a' : b === 3 ? 'e' : 'e';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sv;
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var sw = moment.defineLocale('sw', {
    months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[leo saa] LT',
      nextDay: '[kesho saa] LT',
      nextWeek: '[wiki ijayo] dddd [saat] LT',
      lastDay: '[jana] LT',
      lastWeek: '[wiki iliyopita] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s baadaye',
      past: 'tokea %s',
      s: 'hivi punde',
      ss: 'sekunde %d',
      m: 'dakika moja',
      mm: 'dakika %d',
      h: 'saa limoja',
      hh: 'masaa %d',
      d: 'siku moja',
      dd: 'masiku %d',
      M: 'mwezi mmoja',
      MM: 'miezi %d',
      y: 'mwaka mmoja',
      yy: 'miaka %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sw;
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var symbolMap = {
    '1': '௧',
    '2': '௨',
    '3': '௩',
    '4': '௪',
    '5': '௫',
    '6': '௬',
    '7': '௭',
    '8': '௮',
    '9': '௯',
    '0': '௦'
  },
      numberMap = {
    '௧': '1',
    '௨': '2',
    '௩': '3',
    '௪': '4',
    '௫': '5',
    '௬': '6',
    '௭': '7',
    '௮': '8',
    '௯': '9',
    '௦': '0'
  };
  var ta = moment.defineLocale('ta', {
    months: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
    monthsShort: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
    weekdays: 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
    weekdaysShort: 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
    weekdaysMin: 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, HH:mm',
      LLLL: 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar: {
      sameDay: '[இன்று] LT',
      nextDay: '[நாளை] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[நேற்று] LT',
      lastWeek: '[கடந்த வாரம்] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s இல்',
      past: '%s முன்',
      s: 'ஒரு சில விநாடிகள்',
      ss: '%d விநாடிகள்',
      m: 'ஒரு நிமிடம்',
      mm: '%d நிமிடங்கள்',
      h: 'ஒரு மணி நேரம்',
      hh: '%d மணி நேரம்',
      d: 'ஒரு நாள்',
      dd: '%d நாட்கள்',
      M: 'ஒரு மாதம்',
      MM: '%d மாதங்கள்',
      y: 'ஒரு வருடம்',
      yy: '%d ஆண்டுகள்'
    },
    dayOfMonthOrdinalParse: /\d{1,2}வது/,
    ordinal: function (number) {
      return number + 'வது';
    },
    preparse: function (string) {
      return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
    meridiem: function (hour, minute, isLower) {
      if (hour < 2) {
        return ' யாமம்';
      } else if (hour < 6) {
        return ' வைகறை'; // வைகறை
      } else if (hour < 10) {
        return ' காலை'; // காலை
      } else if (hour < 14) {
        return ' நண்பகல்'; // நண்பகல்
      } else if (hour < 18) {
        return ' எற்பாடு'; // எற்பாடு
      } else if (hour < 22) {
        return ' மாலை'; // மாலை
      } else {
        return ' யாமம்';
      }
    },
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'யாமம்') {
        return hour < 2 ? hour : hour + 12;
      } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
        return hour;
      } else if (meridiem === 'நண்பகல்') {
        return hour >= 10 ? hour : hour + 12;
      } else {
        return hour + 12;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return ta;
});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var te = moment.defineLocale('te', {
    months: 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
    monthsShort: 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
    monthsParseExact: true,
    weekdays: 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
    weekdaysShort: 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
    weekdaysMin: 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[నేడు] LT',
      nextDay: '[రేపు] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[నిన్న] LT',
      lastWeek: '[గత] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s లో',
      past: '%s క్రితం',
      s: 'కొన్ని క్షణాలు',
      ss: '%d సెకన్లు',
      m: 'ఒక నిమిషం',
      mm: '%d నిమిషాలు',
      h: 'ఒక గంట',
      hh: '%d గంటలు',
      d: 'ఒక రోజు',
      dd: '%d రోజులు',
      M: 'ఒక నెల',
      MM: '%d నెలలు',
      y: 'ఒక సంవత్సరం',
      yy: '%d సంవత్సరాలు'
    },
    dayOfMonthOrdinalParse: /\d{1,2}వ/,
    ordinal: '%dవ',
    meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'రాత్రి') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'ఉదయం') {
        return hour;
      } else if (meridiem === 'మధ్యాహ్నం') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === 'సాయంత్రం') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'రాత్రి';
      } else if (hour < 10) {
        return 'ఉదయం';
      } else if (hour < 17) {
        return 'మధ్యాహ్నం';
      } else if (hour < 20) {
        return 'సాయంత్రం';
      } else {
        return 'రాత్రి';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return te;
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var tet = moment.defineLocale('tet', {
    months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
    weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
    weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Ohin iha] LT',
      nextDay: '[Aban iha] LT',
      nextWeek: 'dddd [iha] LT',
      lastDay: '[Horiseik iha] LT',
      lastWeek: 'dddd [semana kotuk] [iha] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'iha %s',
      past: '%s liuba',
      s: 'minutu balun',
      ss: 'minutu %d',
      m: 'minutu ida',
      mm: 'minutu %d',
      h: 'oras ida',
      hh: 'oras %d',
      d: 'loron ida',
      dd: 'loron %d',
      M: 'fulan ida',
      MM: 'fulan %d',
      y: 'tinan ida',
      yy: 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tet;
});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var suffixes = {
    0: '-ум',
    1: '-ум',
    2: '-юм',
    3: '-юм',
    4: '-ум',
    5: '-ум',
    6: '-ум',
    7: '-ум',
    8: '-ум',
    9: '-ум',
    10: '-ум',
    12: '-ум',
    13: '-ум',
    20: '-ум',
    30: '-юм',
    40: '-ум',
    50: '-ум',
    60: '-ум',
    70: '-ум',
    80: '-ум',
    90: '-ум',
    100: '-ум'
  };
  var tg = moment.defineLocale('tg', {
    months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
    monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
    weekdays: 'якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе'.split('_'),
    weekdaysShort: 'яшб_дшб_сшб_чшб_пшб_ҷум_шнб'.split('_'),
    weekdaysMin: 'яш_дш_сш_чш_пш_ҷм_шб'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Имрӯз соати] LT',
      nextDay: '[Пагоҳ соати] LT',
      lastDay: '[Дирӯз соати] LT',
      nextWeek: 'dddd[и] [ҳафтаи оянда соати] LT',
      lastWeek: 'dddd[и] [ҳафтаи гузашта соати] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'баъди %s',
      past: '%s пеш',
      s: 'якчанд сония',
      m: 'як дақиқа',
      mm: '%d дақиқа',
      h: 'як соат',
      hh: '%d соат',
      d: 'як рӯз',
      dd: '%d рӯз',
      M: 'як моҳ',
      MM: '%d моҳ',
      y: 'як сол',
      yy: '%d сол'
    },
    meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'шаб') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'субҳ') {
        return hour;
      } else if (meridiem === 'рӯз') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'бегоҳ') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'шаб';
      } else if (hour < 11) {
        return 'субҳ';
      } else if (hour < 16) {
        return 'рӯз';
      } else if (hour < 19) {
        return 'бегоҳ';
      } else {
        return 'шаб';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
    ordinal: function (number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1th is the first week of the year.

    }
  });
  return tg;
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var th = moment.defineLocale('th', {
    months: 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
    monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
    monthsParseExact: true,
    weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
    weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'),
    // yes, three characters difference
    weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY เวลา H:mm',
      LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm'
    },
    meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
    isPM: function (input) {
      return input === 'หลังเที่ยง';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'ก่อนเที่ยง';
      } else {
        return 'หลังเที่ยง';
      }
    },
    calendar: {
      sameDay: '[วันนี้ เวลา] LT',
      nextDay: '[พรุ่งนี้ เวลา] LT',
      nextWeek: 'dddd[หน้า เวลา] LT',
      lastDay: '[เมื่อวานนี้ เวลา] LT',
      lastWeek: '[วัน]dddd[ที่แล้ว เวลา] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'อีก %s',
      past: '%sที่แล้ว',
      s: 'ไม่กี่วินาที',
      ss: '%d วินาที',
      m: '1 นาที',
      mm: '%d นาที',
      h: '1 ชั่วโมง',
      hh: '%d ชั่วโมง',
      d: '1 วัน',
      dd: '%d วัน',
      M: '1 เดือน',
      MM: '%d เดือน',
      y: '1 ปี',
      yy: '%d ปี'
    }
  });
  return th;
});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var tlPh = moment.defineLocale('tl-ph', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tlPh;
});

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

  function translateFuture(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
    return time;
  }

  function translatePast(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu’' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
    return time;
  }

  function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);

    switch (string) {
      case 'ss':
        return numberNoun + ' lup';

      case 'mm':
        return numberNoun + ' tup';

      case 'hh':
        return numberNoun + ' rep';

      case 'dd':
        return numberNoun + ' jaj';

      case 'MM':
        return numberNoun + ' jar';

      case 'yy':
        return numberNoun + ' DIS';
    }
  }

  function numberAsNoun(number) {
    var hundred = Math.floor(number % 1000 / 100),
        ten = Math.floor(number % 100 / 10),
        one = number % 10,
        word = '';

    if (hundred > 0) {
      word += numbersNouns[hundred] + 'vatlh';
    }

    if (ten > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
    }

    if (one > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[one];
    }

    return word === '' ? 'pagh' : word;
  }

  var tlh = moment.defineLocale('tlh', {
    months: 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
    monthsShort: 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
    monthsParseExact: true,
    weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[DaHjaj] LT',
      nextDay: '[wa’leS] LT',
      nextWeek: 'LLL',
      lastDay: '[wa’Hu’] LT',
      lastWeek: 'LLL',
      sameElse: 'L'
    },
    relativeTime: {
      future: translateFuture,
      past: translatePast,
      s: 'puS lup',
      ss: translate,
      m: 'wa’ tup',
      mm: translate,
      h: 'wa’ rep',
      hh: translate,
      d: 'wa’ jaj',
      dd: translate,
      M: 'wa’ jar',
      MM: translate,
      y: 'wa’ DIS',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tlh;
});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var suffixes = {
    1: '\'inci',
    5: '\'inci',
    8: '\'inci',
    70: '\'inci',
    80: '\'inci',
    2: '\'nci',
    7: '\'nci',
    20: '\'nci',
    50: '\'nci',
    3: '\'üncü',
    4: '\'üncü',
    100: '\'üncü',
    6: '\'ncı',
    9: '\'uncu',
    10: '\'uncu',
    30: '\'uncu',
    60: '\'ıncı',
    90: '\'ıncı'
  };
  var tr = moment.defineLocale('tr', {
    months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
    monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
    weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugün saat] LT',
      nextDay: '[yarın saat] LT',
      nextWeek: '[gelecek] dddd [saat] LT',
      lastDay: '[dün] LT',
      lastWeek: '[geçen] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s önce',
      s: 'birkaç saniye',
      ss: '%d saniye',
      m: 'bir dakika',
      mm: '%d dakika',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gün',
      dd: '%d gün',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir yıl',
      yy: '%d yıl'
    },
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;

        default:
          if (number === 0) {
            // special case for zero
            return number + '\'ıncı';
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return tr;
});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict'; // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
  // This is currently too difficult (maybe even impossible) to add.

  var tzl = moment.defineLocale('tzl', {
    months: 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays: 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
    weekdaysShort: 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
    weekdaysMin: 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM [dallas] YYYY',
      LLL: 'D. MMMM [dallas] YYYY HH.mm',
      LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM: function (input) {
      return 'd\'o' === input.toLowerCase();
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'd\'o' : 'D\'O';
      } else {
        return isLower ? 'd\'a' : 'D\'A';
      }
    },
    calendar: {
      sameDay: '[oxhi à] LT',
      nextDay: '[demà à] LT',
      nextWeek: 'dddd [à] LT',
      lastDay: '[ieiri à] LT',
      lastWeek: '[sür el] dddd [lasteu à] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'osprei %s',
      past: 'ja%s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      's': ['viensas secunds', '\'iensas secunds'],
      'ss': [number + ' secunds', '' + number + ' secunds'],
      'm': ['\'n míut', '\'iens míut'],
      'mm': [number + ' míuts', '' + number + ' míuts'],
      'h': ['\'n þora', '\'iensa þora'],
      'hh': [number + ' þoras', '' + number + ' þoras'],
      'd': ['\'n ziua', '\'iensa ziua'],
      'dd': [number + ' ziuas', '' + number + ' ziuas'],
      'M': ['\'n mes', '\'iens mes'],
      'MM': [number + ' mesen', '' + number + ' mesen'],
      'y': ['\'n ar', '\'iens ar'],
      'yy': [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
  }

  return tzl;
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var tzm = moment.defineLocale('tzm', {
    months: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
    monthsShort: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
    weekdays: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
    weekdaysShort: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
    weekdaysMin: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
      nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
      nextWeek: 'dddd [ⴴ] LT',
      lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
      lastWeek: 'dddd [ⴴ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
      past: 'ⵢⴰⵏ %s',
      s: 'ⵉⵎⵉⴽ',
      ss: '%d ⵉⵎⵉⴽ',
      m: 'ⵎⵉⵏⵓⴺ',
      mm: '%d ⵎⵉⵏⵓⴺ',
      h: 'ⵙⴰⵄⴰ',
      hh: '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
      d: 'ⴰⵙⵙ',
      dd: '%d oⵙⵙⴰⵏ',
      M: 'ⴰⵢoⵓⵔ',
      MM: '%d ⵉⵢⵢⵉⵔⵏ',
      y: 'ⴰⵙⴳⴰⵙ',
      yy: '%d ⵉⵙⴳⴰⵙⵏ'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return tzm;
});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var tzmLatn = moment.defineLocale('tzm-latn', {
    months: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
    monthsShort: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
    weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
    weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
    weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[asdkh g] LT',
      nextDay: '[aska g] LT',
      nextWeek: 'dddd [g] LT',
      lastDay: '[assant g] LT',
      lastWeek: 'dddd [g] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dadkh s yan %s',
      past: 'yan %s',
      s: 'imik',
      ss: '%d imik',
      m: 'minuḍ',
      mm: '%d minuḍ',
      h: 'saɛa',
      hh: '%d tassaɛin',
      d: 'ass',
      dd: '%d ossan',
      M: 'ayowr',
      MM: '%d iyyirn',
      y: 'asgas',
      yy: '%d isgasn'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return tzmLatn;
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js language configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var ugCn = moment.defineLocale('ug-cn', {
    months: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split('_'),
    monthsShort: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split('_'),
    weekdays: 'يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە'.split('_'),
    weekdaysShort: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
    weekdaysMin: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY-يىلىM-ئاينىڭD-كۈنى',
      LLL: 'YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
      LLLL: 'dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm'
    },
    meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'يېرىم كېچە' || meridiem === 'سەھەر' || meridiem === 'چۈشتىن بۇرۇن') {
        return hour;
      } else if (meridiem === 'چۈشتىن كېيىن' || meridiem === 'كەچ') {
        return hour + 12;
      } else {
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return 'يېرىم كېچە';
      } else if (hm < 900) {
        return 'سەھەر';
      } else if (hm < 1130) {
        return 'چۈشتىن بۇرۇن';
      } else if (hm < 1230) {
        return 'چۈش';
      } else if (hm < 1800) {
        return 'چۈشتىن كېيىن';
      } else {
        return 'كەچ';
      }
    },
    calendar: {
      sameDay: '[بۈگۈن سائەت] LT',
      nextDay: '[ئەتە سائەت] LT',
      nextWeek: '[كېلەركى] dddd [سائەت] LT',
      lastDay: '[تۆنۈگۈن] LT',
      lastWeek: '[ئالدىنقى] dddd [سائەت] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s كېيىن',
      past: '%s بۇرۇن',
      s: 'نەچچە سېكونت',
      ss: '%d سېكونت',
      m: 'بىر مىنۇت',
      mm: '%d مىنۇت',
      h: 'بىر سائەت',
      hh: '%d سائەت',
      d: 'بىر كۈن',
      dd: '%d كۈن',
      M: 'بىر ئاي',
      MM: '%d ئاي',
      y: 'بىر يىل',
      yy: '%d يىل'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '-كۈنى';

        case 'w':
        case 'W':
          return number + '-ھەپتە';

        default:
          return number;
      }
    },
    preparse: function (string) {
      return string.replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '،');
    },
    week: {
      // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return ugCn;
});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
      'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
      'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
      'dd': 'день_дні_днів',
      'MM': 'місяць_місяці_місяців',
      'yy': 'рік_роки_років'
    };

    if (key === 'm') {
      return withoutSuffix ? 'хвилина' : 'хвилину';
    } else if (key === 'h') {
      return withoutSuffix ? 'година' : 'годину';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  function weekdaysCaseReplace(m, format) {
    var weekdays = {
      'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
      'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
      'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
    };

    if (!m) {
      return weekdays['nominative'];
    }

    var nounCase = /(\[[ВвУу]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
    return weekdays[nounCase][m.day()];
  }

  function processHoursFunction(str) {
    return function () {
      return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
    };
  }

  var uk = moment.defineLocale('uk', {
    months: {
      'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
      'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
    },
    monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
    weekdays: weekdaysCaseReplace,
    weekdaysShort: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
    weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY р.',
      LLL: 'D MMMM YYYY р., HH:mm',
      LLLL: 'dddd, D MMMM YYYY р., HH:mm'
    },
    calendar: {
      sameDay: processHoursFunction('[Сьогодні '),
      nextDay: processHoursFunction('[Завтра '),
      lastDay: processHoursFunction('[Вчора '),
      nextWeek: processHoursFunction('[У] dddd ['),
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return processHoursFunction('[Минулої] dddd [').call(this);

          case 1:
          case 2:
          case 4:
            return processHoursFunction('[Минулого] dddd [').call(this);
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'за %s',
      past: '%s тому',
      s: 'декілька секунд',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: 'годину',
      hh: relativeTimeWithPlural,
      d: 'день',
      dd: relativeTimeWithPlural,
      M: 'місяць',
      MM: relativeTimeWithPlural,
      y: 'рік',
      yy: relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /ночі|ранку|дня|вечора/,
    isPM: function (input) {
      return /^(дня|вечора)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'ночі';
      } else if (hour < 12) {
        return 'ранку';
      } else if (hour < 17) {
        return 'дня';
      } else {
        return 'вечора';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return number + '-й';

        case 'D':
          return number + '-го';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return uk;
});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var months = ['جنوری', 'فروری', 'مارچ', 'اپریل', 'مئی', 'جون', 'جولائی', 'اگست', 'ستمبر', 'اکتوبر', 'نومبر', 'دسمبر'];
  var days = ['اتوار', 'پیر', 'منگل', 'بدھ', 'جمعرات', 'جمعہ', 'ہفتہ'];
  var ur = moment.defineLocale('ur', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd، D MMMM YYYY HH:mm'
    },
    meridiemParse: /صبح|شام/,
    isPM: function (input) {
      return 'شام' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return 'صبح';
      }

      return 'شام';
    },
    calendar: {
      sameDay: '[آج بوقت] LT',
      nextDay: '[کل بوقت] LT',
      nextWeek: 'dddd [بوقت] LT',
      lastDay: '[گذشتہ روز بوقت] LT',
      lastWeek: '[گذشتہ] dddd [بوقت] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s بعد',
      past: '%s قبل',
      s: 'چند سیکنڈ',
      ss: '%d سیکنڈ',
      m: 'ایک منٹ',
      mm: '%d منٹ',
      h: 'ایک گھنٹہ',
      hh: '%d گھنٹے',
      d: 'ایک دن',
      dd: '%d دن',
      M: 'ایک ماہ',
      MM: '%d ماہ',
      y: 'ایک سال',
      yy: '%d سال'
    },
    preparse: function (string) {
      return string.replace(/،/g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '،');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ur;
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var uz = moment.defineLocale('uz', {
    months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
    monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
    weekdays: 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
    weekdaysShort: 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
    weekdaysMin: 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[Бугун соат] LT [да]',
      nextDay: '[Эртага] LT [да]',
      nextWeek: 'dddd [куни соат] LT [да]',
      lastDay: '[Кеча соат] LT [да]',
      lastWeek: '[Утган] dddd [куни соат] LT [да]',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'Якин %s ичида',
      past: 'Бир неча %s олдин',
      s: 'фурсат',
      ss: '%d фурсат',
      m: 'бир дакика',
      mm: '%d дакика',
      h: 'бир соат',
      hh: '%d соат',
      d: 'бир кун',
      dd: '%d кун',
      M: 'бир ой',
      MM: '%d ой',
      y: 'бир йил',
      yy: '%d йил'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return uz;
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var uzLatn = moment.defineLocale('uz-latn', {
    months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[Bugun soat] LT [da]',
      nextDay: '[Ertaga] LT [da]',
      nextWeek: 'dddd [kuni soat] LT [da]',
      lastDay: '[Kecha soat] LT [da]',
      lastWeek: '[O\'tgan] dddd [kuni soat] LT [da]',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'Yaqin %s ichida',
      past: 'Bir necha %s oldin',
      s: 'soniya',
      ss: '%d soniya',
      m: 'bir daqiqa',
      mm: '%d daqiqa',
      h: 'bir soat',
      hh: '%d soat',
      d: 'bir kun',
      dd: '%d kun',
      M: 'bir oy',
      MM: '%d oy',
      y: 'bir yil',
      yy: '%d yil'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return uzLatn;
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var vi = moment.defineLocale('vi', {
    months: 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
    monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
    monthsParseExact: true,
    weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
    weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /sa|ch/i,
    isPM: function (input) {
      return /^ch$/i.test(input);
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'sa' : 'SA';
      } else {
        return isLower ? 'ch' : 'CH';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [năm] YYYY',
      LLL: 'D MMMM [năm] YYYY HH:mm',
      LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
      l: 'DD/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hôm nay lúc] LT',
      nextDay: '[Ngày mai lúc] LT',
      nextWeek: 'dddd [tuần tới lúc] LT',
      lastDay: '[Hôm qua lúc] LT',
      lastWeek: 'dddd [tuần rồi lúc] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s tới',
      past: '%s trước',
      s: 'vài giây',
      ss: '%d giây',
      m: 'một phút',
      mm: '%d phút',
      h: 'một giờ',
      hh: '%d giờ',
      d: 'một ngày',
      dd: '%d ngày',
      M: 'một tháng',
      MM: '%d tháng',
      y: 'một năm',
      yy: '%d năm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return vi;
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var xPseudo = moment.defineLocale('x-pseudo', {
    months: 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
    monthsShort: 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
    monthsParseExact: true,
    weekdays: 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
    weekdaysShort: 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
    weekdaysMin: 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[T~ódá~ý át] LT',
      nextDay: '[T~ómó~rró~w át] LT',
      nextWeek: 'dddd [át] LT',
      lastDay: '[Ý~ést~érdá~ý át] LT',
      lastWeek: '[L~ást] dddd [át] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'í~ñ %s',
      past: '%s á~gó',
      s: 'á ~féw ~sécó~ñds',
      ss: '%d s~écóñ~ds',
      m: 'á ~míñ~úté',
      mm: '%d m~íñú~tés',
      h: 'á~ñ hó~úr',
      hh: '%d h~óúrs',
      d: 'á ~dáý',
      dd: '%d d~áýs',
      M: 'á ~móñ~th',
      MM: '%d m~óñt~hs',
      y: 'á ~ýéár',
      yy: '%d ý~éárs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return xPseudo;
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var yo = moment.defineLocale('yo', {
    months: 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
    monthsShort: 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
    weekdays: 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
    weekdaysShort: 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
    weekdaysMin: 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Ònì ni] LT',
      nextDay: '[Ọ̀la ni] LT',
      nextWeek: 'dddd [Ọsẹ̀ tón\'bọ] [ni] LT',
      lastDay: '[Àna ni] LT',
      lastWeek: 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ní %s',
      past: '%s kọjá',
      s: 'ìsẹjú aayá die',
      ss: 'aayá %d',
      m: 'ìsẹjú kan',
      mm: 'ìsẹjú %d',
      h: 'wákati kan',
      hh: 'wákati %d',
      d: 'ọjọ́ kan',
      dd: 'ọjọ́ %d',
      M: 'osù kan',
      MM: 'osù %d',
      y: 'ọdún kan',
      yy: 'ọdún %d'
    },
    dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
    ordinal: 'ọjọ́ %d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return yo;
});

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var zhCn = moment.defineLocale('zh-cn', {
    months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
    monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
    weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
    weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY年M月D日',
      LLL: 'YYYY年M月D日Ah点mm分',
      LLLL: 'YYYY年M月D日ddddAh点mm分',
      l: 'YYYY/M/D',
      ll: 'YYYY年M月D日',
      lll: 'YYYY年M月D日 HH:mm',
      llll: 'YYYY年M月D日dddd HH:mm'
    },
    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
        return hour;
      } else if (meridiem === '下午' || meridiem === '晚上') {
        return hour + 12;
      } else {
        // '中午'
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '凌晨';
      } else if (hm < 900) {
        return '早上';
      } else if (hm < 1130) {
        return '上午';
      } else if (hm < 1230) {
        return '中午';
      } else if (hm < 1800) {
        return '下午';
      } else {
        return '晚上';
      }
    },
    calendar: {
      sameDay: '[今天]LT',
      nextDay: '[明天]LT',
      nextWeek: '[下]ddddLT',
      lastDay: '[昨天]LT',
      lastWeek: '[上]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '日';

        case 'M':
          return number + '月';

        case 'w':
        case 'W':
          return number + '周';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s内',
      past: '%s前',
      s: '几秒',
      ss: '%d 秒',
      m: '1 分钟',
      mm: '%d 分钟',
      h: '1 小时',
      hh: '%d 小时',
      d: '1 天',
      dd: '%d 天',
      M: '1 个月',
      MM: '%d 个月',
      y: '1 年',
      yy: '%d 年'
    },
    week: {
      // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return zhCn;
});

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var zhHk = moment.defineLocale('zh-hk', {
    months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
    monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
    weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
    weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY年M月D日',
      LLL: 'YYYY年M月D日 HH:mm',
      LLLL: 'YYYY年M月D日dddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYY年M月D日',
      lll: 'YYYY年M月D日 HH:mm',
      llll: 'YYYY年M月D日dddd HH:mm'
    },
    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
        return hour;
      } else if (meridiem === '中午') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '下午' || meridiem === '晚上') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '凌晨';
      } else if (hm < 900) {
        return '早上';
      } else if (hm < 1130) {
        return '上午';
      } else if (hm < 1230) {
        return '中午';
      } else if (hm < 1800) {
        return '下午';
      } else {
        return '晚上';
      }
    },
    calendar: {
      sameDay: '[今天]LT',
      nextDay: '[明天]LT',
      nextWeek: '[下]ddddLT',
      lastDay: '[昨天]LT',
      lastWeek: '[上]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '日';

        case 'M':
          return number + '月';

        case 'w':
        case 'W':
          return number + '週';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s內',
      past: '%s前',
      s: '幾秒',
      ss: '%d 秒',
      m: '1 分鐘',
      mm: '%d 分鐘',
      h: '1 小時',
      hh: '%d 小時',
      d: '1 天',
      dd: '%d 天',
      M: '1 個月',
      MM: '%d 個月',
      y: '1 年',
      yy: '%d 年'
    }
  });
  return zhHk;
});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
;

(function (global, factory) {
   true ? factory(__webpack_require__(0)) : typeof define === 'function' && define.amd ? define(['../moment'], factory) : factory(global.moment);
})(this, function (moment) {
  'use strict';

  var zhTw = moment.defineLocale('zh-tw', {
    months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
    monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
    weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
    weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY年M月D日',
      LLL: 'YYYY年M月D日 HH:mm',
      LLLL: 'YYYY年M月D日dddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYY年M月D日',
      lll: 'YYYY年M月D日 HH:mm',
      llll: 'YYYY年M月D日dddd HH:mm'
    },
    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
        return hour;
      } else if (meridiem === '中午') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '下午' || meridiem === '晚上') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '凌晨';
      } else if (hm < 900) {
        return '早上';
      } else if (hm < 1130) {
        return '上午';
      } else if (hm < 1230) {
        return '中午';
      } else if (hm < 1800) {
        return '下午';
      } else {
        return '晚上';
      }
    },
    calendar: {
      sameDay: '[今天] LT',
      nextDay: '[明天] LT',
      nextWeek: '[下]dddd LT',
      lastDay: '[昨天] LT',
      lastWeek: '[上]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '日';

        case 'M':
          return number + '月';

        case 'w':
        case 'W':
          return number + '週';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s內',
      past: '%s前',
      s: '幾秒',
      ss: '%d 秒',
      m: '1 分鐘',
      mm: '%d 分鐘',
      h: '1 小時',
      hh: '%d 小時',
      d: '1 天',
      dd: '%d 天',
      M: '1 個月',
      MM: '%d 個月',
      y: '1 年',
      yy: '%d 年'
    }
  });
  return zhTw;
});

/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Promise) {/* unused harmony export Headers */
/* unused harmony export Request */
/* unused harmony export Response */
/* unused harmony export DOMException */
/* unused harmony export fetch */
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob: 'FileReader' in self && 'Blob' in self && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }

  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }

  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }

  return value;
} // Build a destructive iterator for the value list


function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }

  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };

    reader.onerror = function () {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }

  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    this._bodyInit = body;

    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);

      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);

    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse);
  };

  return this;
} // HTTP methods whose capitalization should be normalized


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }

    this.url = input.url;
    this.credentials = input.credentials;

    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }

    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;

    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';

  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }

  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }

  this._initBody(body);
}

Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};

function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2

  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();

    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';

  this._initBody(bodyInit);
}
Body.call(Response.prototype);

Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response.error = function () {
  var response = new Response(null, {
    status: 0,
    statusText: ''
  });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response(null, {
    status: status,
    headers: {
      location: url
    }
  });
};

var DOMException = self.DOMException;

try {
  new DOMException();
} catch (err) {
  DOMException = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };

  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response(body, options));
    };

    xhr.onerror = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function () {
      reject(new DOMException('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function (value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(130)))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Swiper 4.4.6
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://www.idangero.us/swiper/
 *
 * Copyright 2014-2018 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: December 19, 2018
 */
(function (global, factory) {
   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Swiper = factory();
})(this, function () {
  'use strict';
  /**
   * SSR Window 1.0.1
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2018, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: July 18, 2018
   */

  var doc = typeof document === 'undefined' ? {
    body: {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    activeElement: {
      blur: function blur() {},
      nodeName: ''
    },
    querySelector: function querySelector() {
      return null;
    },
    querySelectorAll: function querySelectorAll() {
      return [];
    },
    getElementById: function getElementById() {
      return null;
    },
    createEvent: function createEvent() {
      return {
        initEvent: function initEvent() {}
      };
    },
    createElement: function createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute: function setAttribute() {},
        getElementsByTagName: function getElementsByTagName() {
          return [];
        }
      };
    },
    location: {
      hash: ''
    }
  } : document; // eslint-disable-line

  var win = typeof window === 'undefined' ? {
    document: doc,
    navigator: {
      userAgent: ''
    },
    location: {},
    history: {},
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    getComputedStyle: function getComputedStyle() {
      return {
        getPropertyValue: function getPropertyValue() {
          return '';
        }
      };
    },
    Image: function Image() {},
    Date: function Date() {},
    screen: {},
    setTimeout: function setTimeout() {},
    clearTimeout: function clearTimeout() {}
  } : window; // eslint-disable-line

  /**
   * Dom7 2.1.2
   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
   * http://framework7.io/docs/dom.html
   *
   * Copyright 2018, Vladimir Kharlampidi
   * The iDangero.us
   * http://www.idangero.us/
   *
   * Licensed under MIT
   *
   * Released on: September 13, 2018
   */

  var Dom7 = function Dom7(arr) {
    var self = this; // Create array-like object

    for (var i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }

    self.length = arr.length; // Return collection with methods

    return this;
  };

  function $(selector, context) {
    var arr = [];
    var i = 0;

    if (selector && !context) {
      if (selector instanceof Dom7) {
        return selector;
      }
    }

    if (selector) {
      // String
      if (typeof selector === 'string') {
        var els;
        var tempParent;
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';

          if (html.indexOf('<li') === 0) {
            toCreate = 'ul';
          }

          if (html.indexOf('<tr') === 0) {
            toCreate = 'tbody';
          }

          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
            toCreate = 'tr';
          }

          if (html.indexOf('<tbody') === 0) {
            toCreate = 'table';
          }

          if (html.indexOf('<option') === 0) {
            toCreate = 'select';
          }

          tempParent = doc.createElement(toCreate);
          tempParent.innerHTML = html;

          for (i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [doc.getElementById(selector.trim().split('#')[1])];
          } else {
            // Other selectors
            els = (context || doc).querySelectorAll(selector.trim());
          }

          for (i = 0; i < els.length; i += 1) {
            if (els[i]) {
              arr.push(els[i]);
            }
          }
        }
      } else if (selector.nodeType || selector === win || selector === doc) {
        // Node/element
        arr.push(selector);
      } else if (selector.length > 0 && selector[0].nodeType) {
        // Array of elements or instance of Dom
        for (i = 0; i < selector.length; i += 1) {
          arr.push(selector[i]);
        }
      }
    }

    return new Dom7(arr);
  }

  $.fn = Dom7.prototype;
  $.Class = Dom7;
  $.Dom7 = Dom7;

  function unique(arr) {
    var uniqueArray = [];

    for (var i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) {
        uniqueArray.push(arr[i]);
      }
    }

    return uniqueArray;
  } // Classes and attributes


  function addClass(className) {
    if (typeof className === 'undefined') {
      return this;
    }

    var classes = className.split(' ');

    for (var i = 0; i < classes.length; i += 1) {
      for (var j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
          this[j].classList.add(classes[i]);
        }
      }
    }

    return this;
  }

  function removeClass(className) {
    var classes = className.split(' ');

    for (var i = 0; i < classes.length; i += 1) {
      for (var j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
          this[j].classList.remove(classes[i]);
        }
      }
    }

    return this;
  }

  function hasClass(className) {
    if (!this[0]) {
      return false;
    }

    return this[0].classList.contains(className);
  }

  function toggleClass(className) {
    var classes = className.split(' ');

    for (var i = 0; i < classes.length; i += 1) {
      for (var j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
          this[j].classList.toggle(classes[i]);
        }
      }
    }

    return this;
  }

  function attr(attrs, value) {
    var arguments$1 = arguments;

    if (arguments.length === 1 && typeof attrs === 'string') {
      // Get attr
      if (this[0]) {
        return this[0].getAttribute(attrs);
      }

      return undefined;
    } // Set attrs


    for (var i = 0; i < this.length; i += 1) {
      if (arguments$1.length === 2) {
        // String
        this[i].setAttribute(attrs, value);
      } else {
        // Object
        // eslint-disable-next-line
        for (var attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }

    return this;
  } // eslint-disable-next-line


  function removeAttr(attr) {
    for (var i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr);
    }

    return this;
  }

  function data(key, value) {
    var el;

    if (typeof value === 'undefined') {
      el = this[0]; // Get value

      if (el) {
        if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
          return el.dom7ElementDataStorage[key];
        }

        var dataKey = el.getAttribute("data-" + key);

        if (dataKey) {
          return dataKey;
        }

        return undefined;
      }

      return undefined;
    } // Set value


    for (var i = 0; i < this.length; i += 1) {
      el = this[i];

      if (!el.dom7ElementDataStorage) {
        el.dom7ElementDataStorage = {};
      }

      el.dom7ElementDataStorage[key] = value;
    }

    return this;
  } // Transforms
  // eslint-disable-next-line


  function transform(transform) {
    for (var i = 0; i < this.length; i += 1) {
      var elStyle = this[i].style;
      elStyle.webkitTransform = transform;
      elStyle.transform = transform;
    }

    return this;
  }

  function transition(duration) {
    if (typeof duration !== 'string') {
      duration = duration + "ms"; // eslint-disable-line
    }

    for (var i = 0; i < this.length; i += 1) {
      var elStyle = this[i].style;
      elStyle.webkitTransitionDuration = duration;
      elStyle.transitionDuration = duration;
    }

    return this;
  } // Events


  function on() {
    var assign;
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var eventType = args[0];
    var targetSelector = args[1];
    var listener = args[2];
    var capture = args[3];

    if (typeof args[1] === 'function') {
      assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
      targetSelector = undefined;
    }

    if (!capture) {
      capture = false;
    }

    function handleLiveEvent(e) {
      var target = e.target;

      if (!target) {
        return;
      }

      var eventData = e.target.dom7EventData || [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      if ($(target).is(targetSelector)) {
        listener.apply(target, eventData);
      } else {
        var parents = $(target).parents(); // eslint-disable-line

        for (var k = 0; k < parents.length; k += 1) {
          if ($(parents[k]).is(targetSelector)) {
            listener.apply(parents[k], eventData);
          }
        }
      }
    }

    function handleEvent(e) {
      var eventData = e && e.target ? e.target.dom7EventData || [] : [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      listener.apply(this, eventData);
    }

    var events = eventType.split(' ');
    var j;

    for (var i = 0; i < this.length; i += 1) {
      var el = this[i];

      if (!targetSelector) {
        for (j = 0; j < events.length; j += 1) {
          var event = events[j];

          if (!el.dom7Listeners) {
            el.dom7Listeners = {};
          }

          if (!el.dom7Listeners[event]) {
            el.dom7Listeners[event] = [];
          }

          el.dom7Listeners[event].push({
            listener: listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event, handleEvent, capture);
        }
      } else {
        // Live events
        for (j = 0; j < events.length; j += 1) {
          var event$1 = events[j];

          if (!el.dom7LiveListeners) {
            el.dom7LiveListeners = {};
          }

          if (!el.dom7LiveListeners[event$1]) {
            el.dom7LiveListeners[event$1] = [];
          }

          el.dom7LiveListeners[event$1].push({
            listener: listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event$1, handleLiveEvent, capture);
        }
      }
    }

    return this;
  }

  function off() {
    var assign;
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var eventType = args[0];
    var targetSelector = args[1];
    var listener = args[2];
    var capture = args[3];

    if (typeof args[1] === 'function') {
      assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
      targetSelector = undefined;
    }

    if (!capture) {
      capture = false;
    }

    var events = eventType.split(' ');

    for (var i = 0; i < events.length; i += 1) {
      var event = events[i];

      for (var j = 0; j < this.length; j += 1) {
        var el = this[j];
        var handlers = void 0;

        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event];
        }

        if (handlers && handlers.length) {
          for (var k = handlers.length - 1; k >= 0; k -= 1) {
            var handler = handlers[k];

            if (listener && handler.listener === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }

    return this;
  }

  function trigger() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var events = args[0].split(' ');
    var eventData = args[1];

    for (var i = 0; i < events.length; i += 1) {
      var event = events[i];

      for (var j = 0; j < this.length; j += 1) {
        var el = this[j];
        var evt = void 0;

        try {
          evt = new win.CustomEvent(event, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
        } catch (e) {
          evt = doc.createEvent('Event');
          evt.initEvent(event, true, true);
          evt.detail = eventData;
        } // eslint-disable-next-line


        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }

    return this;
  }

  function transitionEnd(callback) {
    var events = ['webkitTransitionEnd', 'transitionend'];
    var dom = this;
    var i;

    function fireCallBack(e) {
      /* jshint validthis:true */
      if (e.target !== this) {
        return;
      }

      callback.call(this, e);

      for (i = 0; i < events.length; i += 1) {
        dom.off(events[i], fireCallBack);
      }
    }

    if (callback) {
      for (i = 0; i < events.length; i += 1) {
        dom.on(events[i], fireCallBack);
      }
    }

    return this;
  }

  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        // eslint-disable-next-line
        var styles = this.styles();
        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
      }

      return this[0].offsetWidth;
    }

    return null;
  }

  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        // eslint-disable-next-line
        var styles = this.styles();
        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
      }

      return this[0].offsetHeight;
    }

    return null;
  }

  function offset() {
    if (this.length > 0) {
      var el = this[0];
      var box = el.getBoundingClientRect();
      var body = doc.body;
      var clientTop = el.clientTop || body.clientTop || 0;
      var clientLeft = el.clientLeft || body.clientLeft || 0;
      var scrollTop = el === win ? win.scrollY : el.scrollTop;
      var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }

    return null;
  }

  function styles() {
    if (this[0]) {
      return win.getComputedStyle(this[0], null);
    }

    return {};
  }

  function css(props, value) {
    var i;

    if (arguments.length === 1) {
      if (typeof props === 'string') {
        if (this[0]) {
          return win.getComputedStyle(this[0], null).getPropertyValue(props);
        }
      } else {
        for (i = 0; i < this.length; i += 1) {
          // eslint-disable-next-line
          for (var prop in props) {
            this[i].style[prop] = props[prop];
          }
        }

        return this;
      }
    }

    if (arguments.length === 2 && typeof props === 'string') {
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }

      return this;
    }

    return this;
  } // Iterate over the collection passing elements to `callback`


  function each(callback) {
    // Don't bother continuing without a callback
    if (!callback) {
      return this;
    } // Iterate over the current collection


    for (var i = 0; i < this.length; i += 1) {
      // If the callback returns false
      if (callback.call(this[i], i, this[i]) === false) {
        // End the loop early
        return this;
      }
    } // Return `this` to allow chained DOM operations


    return this;
  } // eslint-disable-next-line


  function html(html) {
    if (typeof html === 'undefined') {
      return this[0] ? this[0].innerHTML : undefined;
    }

    for (var i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html;
    }

    return this;
  } // eslint-disable-next-line


  function text(text) {
    if (typeof text === 'undefined') {
      if (this[0]) {
        return this[0].textContent.trim();
      }

      return null;
    }

    for (var i = 0; i < this.length; i += 1) {
      this[i].textContent = text;
    }

    return this;
  }

  function is(selector) {
    var el = this[0];
    var compareWith;
    var i;

    if (!el || typeof selector === 'undefined') {
      return false;
    }

    if (typeof selector === 'string') {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      }

      compareWith = $(selector);

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) {
          return true;
        }
      }

      return false;
    } else if (selector === doc) {
      return el === doc;
    } else if (selector === win) {
      return el === win;
    }

    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) {
          return true;
        }
      }

      return false;
    }

    return false;
  }

  function index() {
    var child = this[0];
    var i;

    if (child) {
      i = 0; // eslint-disable-next-line

      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) {
          i += 1;
        }
      }

      return i;
    }

    return undefined;
  } // eslint-disable-next-line


  function eq(index) {
    if (typeof index === 'undefined') {
      return this;
    }

    var length = this.length;
    var returnIndex;

    if (index > length - 1) {
      return new Dom7([]);
    }

    if (index < 0) {
      returnIndex = length + index;

      if (returnIndex < 0) {
        return new Dom7([]);
      }

      return new Dom7([this[returnIndex]]);
    }

    return new Dom7([this[index]]);
  }

  function append() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var newChild;

    for (var k = 0; k < args.length; k += 1) {
      newChild = args[k];

      for (var i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = doc.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (var j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }

    return this;
  }

  function prepend(newChild) {
    var i;
    var j;

    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = doc.createElement('div');
        tempDiv.innerHTML = newChild;

        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }

    return this;
  }

  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return new Dom7([this[0].nextElementSibling]);
        }

        return new Dom7([]);
      }

      if (this[0].nextElementSibling) {
        return new Dom7([this[0].nextElementSibling]);
      }

      return new Dom7([]);
    }

    return new Dom7([]);
  }

  function nextAll(selector) {
    var nextEls = [];
    var el = this[0];

    if (!el) {
      return new Dom7([]);
    }

    while (el.nextElementSibling) {
      var next = el.nextElementSibling; // eslint-disable-line

      if (selector) {
        if ($(next).is(selector)) {
          nextEls.push(next);
        }
      } else {
        nextEls.push(next);
      }

      el = next;
    }

    return new Dom7(nextEls);
  }

  function prev(selector) {
    if (this.length > 0) {
      var el = this[0];

      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return new Dom7([el.previousElementSibling]);
        }

        return new Dom7([]);
      }

      if (el.previousElementSibling) {
        return new Dom7([el.previousElementSibling]);
      }

      return new Dom7([]);
    }

    return new Dom7([]);
  }

  function prevAll(selector) {
    var prevEls = [];
    var el = this[0];

    if (!el) {
      return new Dom7([]);
    }

    while (el.previousElementSibling) {
      var prev = el.previousElementSibling; // eslint-disable-line

      if (selector) {
        if ($(prev).is(selector)) {
          prevEls.push(prev);
        }
      } else {
        prevEls.push(prev);
      }

      el = prev;
    }

    return new Dom7(prevEls);
  }

  function parent(selector) {
    var parents = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) {
            parents.push(this[i].parentNode);
          }
        } else {
          parents.push(this[i].parentNode);
        }
      }
    }

    return $(unique(parents));
  }

  function parents(selector) {
    var parents = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      var parent = this[i].parentNode; // eslint-disable-line

      while (parent) {
        if (selector) {
          if ($(parent).is(selector)) {
            parents.push(parent);
          }
        } else {
          parents.push(parent);
        }

        parent = parent.parentNode;
      }
    }

    return $(unique(parents));
  }

  function closest(selector) {
    var closest = this; // eslint-disable-line

    if (typeof selector === 'undefined') {
      return new Dom7([]);
    }

    if (!closest.is(selector)) {
      closest = closest.parents(selector).eq(0);
    }

    return closest;
  }

  function find(selector) {
    var foundElements = [];

    for (var i = 0; i < this.length; i += 1) {
      var found = this[i].querySelectorAll(selector);

      for (var j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }

    return new Dom7(foundElements);
  }

  function children(selector) {
    var children = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      var childNodes = this[i].childNodes;

      for (var j = 0; j < childNodes.length; j += 1) {
        if (!selector) {
          if (childNodes[j].nodeType === 1) {
            children.push(childNodes[j]);
          }
        } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
          children.push(childNodes[j]);
        }
      }
    }

    return new Dom7(unique(children));
  }

  function remove() {
    for (var i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) {
        this[i].parentNode.removeChild(this[i]);
      }
    }

    return this;
  }

  function add() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var dom = this;
    var i;
    var j;

    for (i = 0; i < args.length; i += 1) {
      var toAdd = $(args[i]);

      for (j = 0; j < toAdd.length; j += 1) {
        dom[dom.length] = toAdd[j];
        dom.length += 1;
      }
    }

    return dom;
  }

  var Methods = {
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    toggleClass: toggleClass,
    attr: attr,
    removeAttr: removeAttr,
    data: data,
    transform: transform,
    transition: transition,
    on: on,
    off: off,
    trigger: trigger,
    transitionEnd: transitionEnd,
    outerWidth: outerWidth,
    outerHeight: outerHeight,
    offset: offset,
    css: css,
    each: each,
    html: html,
    text: text,
    is: is,
    index: index,
    eq: eq,
    append: append,
    prepend: prepend,
    next: next,
    nextAll: nextAll,
    prev: prev,
    prevAll: prevAll,
    parent: parent,
    parents: parents,
    closest: closest,
    find: find,
    children: children,
    remove: remove,
    add: add,
    styles: styles
  };
  Object.keys(Methods).forEach(function (methodName) {
    $.fn[methodName] = Methods[methodName];
  });
  var Utils = {
    deleteProps: function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    },
    nextTick: function nextTick(callback, delay) {
      if (delay === void 0) delay = 0;
      return setTimeout(callback, delay);
    },
    now: function now() {
      return Date.now();
    },
    getTranslate: function getTranslate(el, axis) {
      if (axis === void 0) axis = 'x';
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = win.getComputedStyle(el, null);

      if (win.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (win.WebKitCSSMatrix) {
          curTransform = transformMatrix.m41;
        } // Crazy IE10 Matrix
        else if (matrix.length === 16) {
            curTransform = parseFloat(matrix[12]);
          } // Normal Browsers
          else {
              curTransform = parseFloat(matrix[4]);
            }
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (win.WebKitCSSMatrix) {
          curTransform = transformMatrix.m42;
        } // Crazy IE10 Matrix
        else if (matrix.length === 16) {
            curTransform = parseFloat(matrix[13]);
          } // Normal Browsers
          else {
              curTransform = parseFloat(matrix[5]);
            }
      }

      return curTransform || 0;
    },
    parseUrlQuery: function parseUrlQuery(url) {
      var query = {};
      var urlToParse = url || win.location.href;
      var i;
      var params;
      var param;
      var length;

      if (typeof urlToParse === 'string' && urlToParse.length) {
        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
        params = urlToParse.split('&').filter(function (paramsPart) {
          return paramsPart !== '';
        });
        length = params.length;

        for (i = 0; i < length; i += 1) {
          param = params[i].replace(/#\S+/g, '').split('=');
          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
        }
      }

      return query;
    },
    isObject: function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    },
    extend: function extend() {
      var args = [],
          len$1 = arguments.length;

      while (len$1--) args[len$1] = arguments[len$1];

      var to = Object(args[0]);

      for (var i = 1; i < args.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                Utils.extend(to[nextKey], nextSource[nextKey]);
              } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                Utils.extend(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }
  };

  var Support = function Support() {
    var testDiv = doc.createElement('div');
    return {
      touch: win.Modernizr && win.Modernizr.touch === true || function checkTouch() {
        return !!(win.navigator.maxTouchPoints > 0 || 'ontouchstart' in win || win.DocumentTouch && doc instanceof win.DocumentTouch);
      }(),
      pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || 'maxTouchPoints' in win.navigator),
      prefixedPointerEvents: !!win.navigator.msPointerEnabled,
      transition: function checkTransition() {
        var style = testDiv.style;
        return 'transition' in style || 'webkitTransition' in style || 'MozTransition' in style;
      }(),
      transforms3d: win.Modernizr && win.Modernizr.csstransforms3d === true || function checkTransforms3d() {
        var style = testDiv.style;
        return 'webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style;
      }(),
      flexbox: function checkFlexbox() {
        var style = testDiv.style;
        var styles = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');

        for (var i = 0; i < styles.length; i += 1) {
          if (styles[i] in style) {
            return true;
          }
        }

        return false;
      }(),
      observer: function checkObserver() {
        return 'MutationObserver' in win || 'WebkitMutationObserver' in win;
      }(),
      passiveListener: function checkPassiveListener() {
        var supportsPassive = false;

        try {
          var opts = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line
            get: function get() {
              supportsPassive = true;
            }
          });
          win.addEventListener('testPassiveListener', null, opts);
        } catch (e) {// No support
        }

        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return 'ongesturestart' in win;
      }()
    };
  }();

  var SwiperClass = function SwiperClass(params) {
    if (params === void 0) params = {};
    var self = this;
    self.params = params; // Events

    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach(function (eventName) {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  };

  var staticAccessors = {
    components: {
      configurable: true
    }
  };

  SwiperClass.prototype.on = function on(events, handler, priority) {
    var self = this;

    if (typeof handler !== 'function') {
      return self;
    }

    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) {
        self.eventsListeners[event] = [];
      }

      self.eventsListeners[event][method](handler);
    });
    return self;
  };

  SwiperClass.prototype.once = function once(events, handler, priority) {
    var self = this;

    if (typeof handler !== 'function') {
      return self;
    }

    function onceHandler() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      handler.apply(self, args);
      self.off(events, onceHandler);
    }

    return self.on(events, onceHandler, priority);
  };

  SwiperClass.prototype.off = function off(events, handler) {
    var self = this;

    if (!self.eventsListeners) {
      return self;
    }

    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  };

  SwiperClass.prototype.emit = function emit() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var self = this;

    if (!self.eventsListeners) {
      return self;
    }

    var events;
    var data;
    var context;

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsListeners && self.eventsListeners[event]) {
        var handlers = [];
        self.eventsListeners[event].forEach(function (eventHandler) {
          handlers.push(eventHandler);
        });
        handlers.forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  };

  SwiperClass.prototype.useModulesParams = function useModulesParams(instanceParams) {
    var instance = this;

    if (!instance.modules) {
      return;
    }

    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  };

  SwiperClass.prototype.useModules = function useModules(modulesParams) {
    if (modulesParams === void 0) modulesParams = {};
    var instance = this;

    if (!instance.modules) {
      return;
    }

    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {}; // Extend instance methods and props

      if (module.instance) {
        Object.keys(module.instance).forEach(function (modulePropName) {
          var moduleProp = module.instance[modulePropName];

          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      } // Add event listeners


      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      } // Module create callback


      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  };

  staticAccessors.components.set = function (components) {
    var Class = this;

    if (!Class.use) {
      return;
    }

    Class.use(components);
  };

  SwiperClass.installModule = function installModule(module) {
    var params = [],
        len = arguments.length - 1;

    while (len-- > 0) params[len] = arguments[len + 1];

    var Class = this;

    if (!Class.prototype.modules) {
      Class.prototype.modules = {};
    }

    var name = module.name || Object.keys(Class.prototype.modules).length + "_" + Utils.now();
    Class.prototype.modules[name] = module; // Prototype

    if (module.proto) {
      Object.keys(module.proto).forEach(function (key) {
        Class.prototype[key] = module.proto[key];
      });
    } // Class


    if (module.static) {
      Object.keys(module.static).forEach(function (key) {
        Class[key] = module.static[key];
      });
    } // Callback


    if (module.install) {
      module.install.apply(Class, params);
    }

    return Class;
  };

  SwiperClass.use = function use(module) {
    var params = [],
        len = arguments.length - 1;

    while (len-- > 0) params[len] = arguments[len + 1];

    var Class = this;

    if (Array.isArray(module)) {
      module.forEach(function (m) {
        return Class.installModule(m);
      });
      return Class;
    }

    return Class.installModule.apply(Class, [module].concat(params));
  };

  Object.defineProperties(SwiperClass, staticAccessors);

  function updateSize() {
    var swiper = this;
    var width;
    var height;
    var $el = swiper.$el;

    if (typeof swiper.params.width !== 'undefined') {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }

    if (typeof swiper.params.height !== 'undefined') {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }

    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    } // Subtract paddings


    width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
    height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
    Utils.extend(swiper, {
      width: width,
      height: height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  function updateSlides() {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var swiperSize = swiper.size;
    var rtl = swiper.rtlTranslate;
    var wrongRTL = swiper.wrongRTL;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    var slides = $wrapperEl.children("." + swiper.params.slideClass);
    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    var snapGrid = [];
    var slidesGrid = [];
    var slidesSizesGrid = [];
    var offsetBefore = params.slidesOffsetBefore;

    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }

    var offsetAfter = params.slidesOffsetAfter;

    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }

    var previousSnapGridLength = swiper.snapGrid.length;
    var previousSlidesGridLength = swiper.snapGrid.length;
    var spaceBetween = params.spaceBetween;
    var slidePosition = -offsetBefore;
    var prevSlideSize = 0;
    var index = 0;

    if (typeof swiperSize === 'undefined') {
      return;
    }

    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    }

    swiper.virtualSize = -spaceBetween; // reset margins

    if (rtl) {
      slides.css({
        marginLeft: '',
        marginTop: ''
      });
    } else {
      slides.css({
        marginRight: '',
        marginBottom: ''
      });
    }

    var slidesNumberEvenToRows;

    if (params.slidesPerColumn > 1) {
      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
      }

      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
      }
    } // Calc slides


    var slideSize;
    var slidesPerColumn = params.slidesPerColumn;
    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

    for (var i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      var slide = slides.eq(i);

      if (params.slidesPerColumn > 1) {
        // Set slides order
        var newSlideOrderIndex = void 0;
        var column = void 0;
        var row = void 0;

        if (params.slidesPerColumnFill === 'column') {
          column = Math.floor(i / slidesPerColumn);
          row = i - column * slidesPerColumn;

          if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
            row += 1;

            if (row >= slidesPerColumn) {
              row = 0;
              column += 1;
            }
          }

          newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
          slide.css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex
          });
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - row * slidesPerRow;
        }

        slide.css("margin-" + (swiper.isHorizontal() ? 'top' : 'left'), row !== 0 && params.spaceBetween && params.spaceBetween + "px").attr('data-swiper-column', column).attr('data-swiper-row', row);
      }

      if (slide.css('display') === 'none') {
        continue;
      } // eslint-disable-line


      if (params.slidesPerView === 'auto') {
        var slideStyles = win.getComputedStyle(slide[0], null);
        var currentTransform = slide[0].style.transform;
        var currentWebKitTransform = slide[0].style.webkitTransform;

        if (currentTransform) {
          slide[0].style.transform = 'none';
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = 'none';
        }

        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          // eslint-disable-next-line
          if (swiper.isHorizontal()) {
            var width = parseFloat(slideStyles.getPropertyValue('width'));
            var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
            var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
            var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
            var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
            }
          } else {
            var height = parseFloat(slideStyles.getPropertyValue('height'));
            var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
            var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
            var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
            var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
            var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing$1 && boxSizing$1 === 'border-box') {
              slideSize = height + marginTop + marginBottom;
            } else {
              slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
            }
          }
        }

        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }

        if (params.roundLengths) {
          slideSize = Math.floor(slideSize);
        }
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;

        if (params.roundLengths) {
          slideSize = Math.floor(slideSize);
        }

        if (slides[i]) {
          if (swiper.isHorizontal()) {
            slides[i].style.width = slideSize + "px";
          } else {
            slides[i].style.height = slideSize + "px";
          }
        }
      }

      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }

      slidesSizesGrid.push(slideSize);

      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;

        if (prevSlideSize === 0 && i !== 0) {
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        }

        if (i === 0) {
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        }

        if (Math.abs(slidePosition) < 1 / 1000) {
          slidePosition = 0;
        }

        if (params.roundLengths) {
          slidePosition = Math.floor(slidePosition);
        }

        if (index % params.slidesPerGroup === 0) {
          snapGrid.push(slidePosition);
        }

        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) {
          slidePosition = Math.floor(slidePosition);
        }

        if (index % params.slidesPerGroup === 0) {
          snapGrid.push(slidePosition);
        }

        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }

      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }

    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    var newSlidesGrid;

    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      $wrapperEl.css({
        width: swiper.virtualSize + params.spaceBetween + "px"
      });
    }

    if (!Support.flexbox || params.setWrapperSize) {
      if (swiper.isHorizontal()) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      } else {
        $wrapperEl.css({
          height: swiper.virtualSize + params.spaceBetween + "px"
        });
      }
    }

    if (params.slidesPerColumn > 1) {
      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;

      if (swiper.isHorizontal()) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      } else {
        $wrapperEl.css({
          height: swiper.virtualSize + params.spaceBetween + "px"
        });
      }

      if (params.centeredSlides) {
        newSlidesGrid = [];

        for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
          var slidesGridItem = snapGrid[i$1];

          if (params.roundLengths) {
            slidesGridItem = Math.floor(slidesGridItem);
          }

          if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) {
            newSlidesGrid.push(slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;
      }
    } // Remove last grid elements depending on width


    if (!params.centeredSlides) {
      newSlidesGrid = [];

      for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
        var slidesGridItem$1 = snapGrid[i$2];

        if (params.roundLengths) {
          slidesGridItem$1 = Math.floor(slidesGridItem$1);
        }

        if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem$1);
        }
      }

      snapGrid = newSlidesGrid;

      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }

    if (snapGrid.length === 0) {
      snapGrid = [0];
    }

    if (params.spaceBetween !== 0) {
      if (swiper.isHorizontal()) {
        if (rtl) {
          slides.css({
            marginLeft: spaceBetween + "px"
          });
        } else {
          slides.css({
            marginRight: spaceBetween + "px"
          });
        }
      } else {
        slides.css({
          marginBottom: spaceBetween + "px"
        });
      }
    }

    if (params.centerInsufficientSlides) {
      var allSlidesSize = 0;
      slidesSizesGrid.forEach(function (slideSizeValue) {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;

      if (allSlidesSize < swiperSize) {
        var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach(function (snap, snapIndex) {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach(function (snap, snapIndex) {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }

    Utils.extend(swiper, {
      slides: slides,
      snapGrid: snapGrid,
      slidesGrid: slidesGrid,
      slidesSizesGrid: slidesSizesGrid
    });

    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }

    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }

      swiper.emit('snapGridLengthChange');
    }

    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }

    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateSlidesOffset();
    }
  }

  function updateAutoHeight(speed) {
    var swiper = this;
    var activeSlides = [];
    var newHeight = 0;
    var i;

    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    } // Find slides currently in view


    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index = swiper.activeIndex + i;

        if (index > swiper.slides.length) {
          break;
        }

        activeSlides.push(swiper.slides.eq(index)[0]);
      }
    } else {
      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
    } // Find new height from highest slide in view


    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        var height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    } // Update Height


    if (newHeight) {
      swiper.$wrapperEl.css('height', newHeight + "px");
    }
  }

  function updateSlidesOffset() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  function updateSlidesProgress(translate) {
    if (translate === void 0) translate = this && this.translate || 0;
    var swiper = this;
    var params = swiper.params;
    var slides = swiper.slides;
    var rtl = swiper.rtlTranslate;

    if (slides.length === 0) {
      return;
    }

    if (typeof slides[0].swiperSlideOffset === 'undefined') {
      swiper.updateSlidesOffset();
    }

    var offsetCenter = -translate;

    if (rtl) {
      offsetCenter = translate;
    } // Visible Slides


    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];

    for (var i = 0; i < slides.length; i += 1) {
      var slide = slides[i];
      var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

      if (params.watchSlidesVisibility) {
        var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        var isVisible = slideBefore >= 0 && slideBefore < swiper.size || slideAfter > 0 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }
      }

      slide.progress = rtl ? -slideProgress : slideProgress;
    }

    swiper.visibleSlides = $(swiper.visibleSlides);
  }

  function updateProgress(translate) {
    if (translate === void 0) translate = this && this.translate || 0;
    var swiper = this;
    var params = swiper.params;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    var progress = swiper.progress;
    var isBeginning = swiper.isBeginning;
    var isEnd = swiper.isEnd;
    var wasBeginning = isBeginning;
    var wasEnd = isEnd;

    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }

    Utils.extend(swiper, {
      progress: progress,
      isBeginning: isBeginning,
      isEnd: isEnd
    });

    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateSlidesProgress(translate);
    }

    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }

    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }

    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit('fromEdge');
    }

    swiper.emit('progress', progress);
  }

  function updateSlidesClasses() {
    var swiper = this;
    var slides = swiper.slides;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var activeIndex = swiper.activeIndex;
    var realIndex = swiper.realIndex;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
    var activeSlide;

    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
    } else {
      activeSlide = slides.eq(activeIndex);
    } // Active classes


    activeSlide.addClass(params.slideActiveClass);

    if (params.loop) {
      // Duplicate to all looped slides
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
      }
    } // Next Slide


    var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    } // Prev Slide


    var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }

    if (params.loop) {
      // Duplicate to all looped slides
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
      }

      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
      }
    }
  }

  function updateActiveIndex(newActiveIndex) {
    var swiper = this;
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    var slidesGrid = swiper.slidesGrid;
    var snapGrid = swiper.snapGrid;
    var params = swiper.params;
    var previousIndex = swiper.activeIndex;
    var previousRealIndex = swiper.realIndex;
    var previousSnapIndex = swiper.snapIndex;
    var activeIndex = newActiveIndex;
    var snapIndex;

    if (typeof activeIndex === 'undefined') {
      for (var i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      } // Normalize slideIndex


      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') {
          activeIndex = 0;
        }
      }
    }

    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
    }

    if (snapIndex >= snapGrid.length) {
      snapIndex = snapGrid.length - 1;
    }

    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }

      return;
    } // Get real index


    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
    Utils.extend(swiper, {
      snapIndex: snapIndex,
      realIndex: realIndex,
      previousIndex: previousIndex,
      activeIndex: activeIndex
    });
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');

    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }

    swiper.emit('slideChange');
  }

  function updateClickedSlide(e) {
    var swiper = this;
    var params = swiper.params;
    var slide = $(e.target).closest("." + params.slideClass)[0];
    var slideFound = false;

    if (slide) {
      for (var i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) {
          slideFound = true;
        }
      }
    }

    if (slide && slideFound) {
      swiper.clickedSlide = slide;

      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = $(slide).index();
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }

    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update = {
    updateSize: updateSize,
    updateSlides: updateSlides,
    updateAutoHeight: updateAutoHeight,
    updateSlidesOffset: updateSlidesOffset,
    updateSlidesProgress: updateSlidesProgress,
    updateProgress: updateProgress,
    updateSlidesClasses: updateSlidesClasses,
    updateActiveIndex: updateActiveIndex,
    updateClickedSlide: updateClickedSlide
  };

  function getTranslate(axis) {
    if (axis === void 0) axis = this.isHorizontal() ? 'x' : 'y';
    var swiper = this;
    var params = swiper.params;
    var rtl = swiper.rtlTranslate;
    var translate = swiper.translate;
    var $wrapperEl = swiper.$wrapperEl;

    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }

    var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);

    if (rtl) {
      currentTranslate = -currentTranslate;
    }

    return currentTranslate || 0;
  }

  function setTranslate(translate, byController) {
    var swiper = this;
    var rtl = swiper.rtlTranslate;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var progress = swiper.progress;
    var x = 0;
    var y = 0;
    var z = 0;

    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }

    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }

    if (!params.virtualTranslate) {
      if (Support.transforms3d) {
        $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
      } else {
        $wrapperEl.transform("translate(" + x + "px, " + y + "px)");
      }
    }

    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }

    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate() {
    return -this.snapGrid[0];
  }

  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  var translate = {
    getTranslate: getTranslate,
    setTranslate: setTranslate,
    minTranslate: minTranslate,
    maxTranslate: maxTranslate
  };

  function setTransition(duration, byController) {
    var swiper = this;
    swiper.$wrapperEl.transition(duration);
    swiper.emit('setTransition', duration, byController);
  }

  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var params = swiper.params;
    var previousIndex = swiper.previousIndex;

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    var dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) {
        dir = 'next';
      } else if (activeIndex < previousIndex) {
        dir = 'prev';
      } else {
        dir = 'reset';
      }
    }

    swiper.emit('transitionStart');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionStart');
        return;
      }

      swiper.emit('slideChangeTransitionStart');

      if (dir === 'next') {
        swiper.emit('slideNextTransitionStart');
      } else {
        swiper.emit('slidePrevTransitionStart');
      }
    }
  }

  function transitionEnd$1(runCallbacks, direction) {
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var previousIndex = swiper.previousIndex;
    swiper.animating = false;
    swiper.setTransition(0);
    var dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) {
        dir = 'next';
      } else if (activeIndex < previousIndex) {
        dir = 'prev';
      } else {
        dir = 'reset';
      }
    }

    swiper.emit('transitionEnd');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionEnd');
        return;
      }

      swiper.emit('slideChangeTransitionEnd');

      if (dir === 'next') {
        swiper.emit('slideNextTransitionEnd');
      } else {
        swiper.emit('slidePrevTransitionEnd');
      }
    }
  }

  var transition$1 = {
    setTransition: setTransition,
    transitionStart: transitionStart,
    transitionEnd: transitionEnd$1
  };

  function slideTo(index, speed, runCallbacks, internal) {
    if (index === void 0) index = 0;
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var slideIndex = index;

    if (slideIndex < 0) {
      slideIndex = 0;
    }

    var params = swiper.params;
    var snapGrid = swiper.snapGrid;
    var slidesGrid = swiper.slidesGrid;
    var previousIndex = swiper.previousIndex;
    var activeIndex = swiper.activeIndex;
    var rtl = swiper.rtlTranslate;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);

    if (snapIndex >= snapGrid.length) {
      snapIndex = snapGrid.length - 1;
    }

    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    }

    var translate = -snapGrid[snapIndex]; // Update progress

    swiper.updateProgress(translate); // Normalize slideIndex

    if (params.normalizeSlideIndex) {
      for (var i = 0; i < slidesGrid.length; i += 1) {
        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
          slideIndex = i;
        }
      }
    } // Directions locks


    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }

      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }

    var direction;

    if (slideIndex > activeIndex) {
      direction = 'next';
    } else if (slideIndex < activeIndex) {
      direction = 'prev';
    } else {
      direction = 'reset';
    } // Update Index


    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex); // Update Height

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      swiper.updateSlidesClasses();

      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }

      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }

      return false;
    }

    if (speed === 0 || !Support.transition) {
      swiper.setTransition(0);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) {
              return;
            }

            if (e.target !== this) {
              return;
            }

            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }
    }

    return true;
  }

  function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) index = 0;
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var newIndex = index;

    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }

    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideNext(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var params = swiper.params;
    var animating = swiper.animating;

    if (params.loop) {
      if (animating) {
        return false;
      }

      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
    }

    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slidePrev(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var params = swiper.params;
    var animating = swiper.animating;
    var snapGrid = swiper.snapGrid;
    var slidesGrid = swiper.slidesGrid;
    var rtlTranslate = swiper.rtlTranslate;

    if (params.loop) {
      if (animating) {
        return false;
      }

      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    var translate = rtlTranslate ? swiper.translate : -swiper.translate;

    function normalize(val) {
      if (val < 0) {
        return -Math.floor(Math.abs(val));
      }

      return Math.floor(val);
    }

    var normalizedTranslate = normalize(translate);
    var normalizedSnapGrid = snapGrid.map(function (val) {
      return normalize(val);
    });
    var normalizedSlidesGrid = slidesGrid.map(function (val) {
      return normalize(val);
    });
    var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    var prevIndex;

    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);

      if (prevIndex < 0) {
        prevIndex = swiper.activeIndex - 1;
      }
    }

    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideReset(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideToClosest(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var index = swiper.activeIndex;
    var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

    if (snapIndex < swiper.snapGrid.length - 1) {
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      var currentSnap = swiper.snapGrid[snapIndex];
      var nextSnap = swiper.snapGrid[snapIndex + 1];

      if (translate - currentSnap > (nextSnap - currentSnap) / 2) {
        index = swiper.params.slidesPerGroup;
      }
    }

    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide() {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    var slideToIndex = swiper.clickedIndex;
    var realIndex;

    if (params.loop) {
      if (swiper.animating) {
        return;
      }

      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
          Utils.nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
        Utils.nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo: slideTo,
    slideToLoop: slideToLoop,
    slideNext: slideNext,
    slidePrev: slidePrev,
    slideReset: slideReset,
    slideToClosest: slideToClosest,
    slideToClickedSlide: slideToClickedSlide
  };

  function loopCreate() {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
    var slides = $wrapperEl.children("." + params.slideClass);

    if (params.loopFillGroupWithBlank) {
      var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

      if (blankSlidesNum !== params.slidesPerGroup) {
        for (var i = 0; i < blankSlidesNum; i += 1) {
          var blankNode = $(doc.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
          $wrapperEl.append(blankNode);
        }

        slides = $wrapperEl.children("." + params.slideClass);
      }
    }

    if (params.slidesPerView === 'auto' && !params.loopedSlides) {
      params.loopedSlides = slides.length;
    }

    swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
    swiper.loopedSlides += params.loopAdditionalSlides;

    if (swiper.loopedSlides > slides.length) {
      swiper.loopedSlides = slides.length;
    }

    var prependSlides = [];
    var appendSlides = [];
    slides.each(function (index, el) {
      var slide = $(el);

      if (index < swiper.loopedSlides) {
        appendSlides.push(el);
      }

      if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
        prependSlides.push(el);
      }

      slide.attr('data-swiper-slide-index', index);
    });

    for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
      $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
    }

    for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
      $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  function loopFix() {
    var swiper = this;
    var params = swiper.params;
    var activeIndex = swiper.activeIndex;
    var slides = swiper.slides;
    var loopedSlides = swiper.loopedSlides;
    var allowSlidePrev = swiper.allowSlidePrev;
    var allowSlideNext = swiper.allowSlideNext;
    var snapGrid = swiper.snapGrid;
    var rtl = swiper.rtlTranslate;
    var newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    var snapTranslate = -snapGrid[activeIndex];
    var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      var slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2 || activeIndex >= slides.length - loopedSlides) {
      // Fix For Positive Oversliding
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged$1 && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }

    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
  }

  function loopDestroy() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl;
    var params = swiper.params;
    var slides = swiper.slides;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
    slides.removeAttr('data-swiper-slide-index');
  }

  var loop = {
    loopCreate: loopCreate,
    loopFix: loopFix,
    loopDestroy: loopDestroy
  };

  function setGrabCursor(moving) {
    var swiper = this;

    if (Support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked) {
      return;
    }

    var el = swiper.el;
    el.style.cursor = 'move';
    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
    el.style.cursor = moving ? 'grabbing' : 'grab';
  }

  function unsetGrabCursor() {
    var swiper = this;

    if (Support.touch || swiper.params.watchOverflow && swiper.isLocked) {
      return;
    }

    swiper.el.style.cursor = '';
  }

  var grabCursor = {
    setGrabCursor: setGrabCursor,
    unsetGrabCursor: unsetGrabCursor
  };

  function appendSlide(slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl;
    var params = swiper.params;

    if (params.loop) {
      swiper.loopDestroy();
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) {
          $wrapperEl.append(slides[i]);
        }
      }
    } else {
      $wrapperEl.append(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }
  }

  function prependSlide(slides) {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var activeIndex = swiper.activeIndex;

    if (params.loop) {
      swiper.loopDestroy();
    }

    var newActiveIndex = activeIndex + 1;

    if (typeof slides === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) {
          $wrapperEl.prepend(slides[i]);
        }
      }

      newActiveIndex = activeIndex + slides.length;
    } else {
      $wrapperEl.prepend(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }

    swiper.slideTo(newActiveIndex, 0, false);
  }

  function addSlide(index, slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl;
    var params = swiper.params;
    var activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children("." + params.slideClass);
    }

    var baseLength = swiper.slides.length;

    if (index <= 0) {
      swiper.prependSlide(slides);
      return;
    }

    if (index >= baseLength) {
      swiper.appendSlide(slides);
      return;
    }

    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    var slidesBuffer = [];

    for (var i = baseLength - 1; i >= index; i -= 1) {
      var currentSlide = swiper.slides.eq(i);
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
        if (slides[i$1]) {
          $wrapperEl.append(slides[i$1]);
        }
      }

      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      $wrapperEl.append(slides);
    }

    for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
      $wrapperEl.append(slidesBuffer[i$2]);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeSlide(slidesIndexes) {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children("." + params.slideClass);
    }

    var newActiveIndex = activeIndexBuffer;
    var indexToRemove;

    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
      for (var i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];

        if (swiper.slides[indexToRemove]) {
          swiper.slides.eq(indexToRemove).remove();
        }

        if (indexToRemove < newActiveIndex) {
          newActiveIndex -= 1;
        }
      }

      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;

      if (swiper.slides[indexToRemove]) {
        swiper.slides.eq(indexToRemove).remove();
      }

      if (indexToRemove < newActiveIndex) {
        newActiveIndex -= 1;
      }

      newActiveIndex = Math.max(newActiveIndex, 0);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeAllSlides() {
    var swiper = this;
    var slidesIndexes = [];

    for (var i = 0; i < swiper.slides.length; i += 1) {
      slidesIndexes.push(i);
    }

    swiper.removeSlide(slidesIndexes);
  }

  var manipulation = {
    appendSlide: appendSlide,
    prependSlide: prependSlide,
    addSlide: addSlide,
    removeSlide: removeSlide,
    removeAllSlides: removeAllSlides
  };

  var Device = function Device() {
    var ua = win.navigator.userAgent;
    var device = {
      ios: false,
      android: false,
      androidChrome: false,
      desktop: false,
      windows: false,
      iphone: false,
      ipod: false,
      ipad: false,
      cordova: win.cordova || win.phonegap,
      phonegap: win.cordova || win.phonegap
    };
    var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line

    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/); // Windows

    if (windows) {
      device.os = 'windows';
      device.osVersion = windows[2];
      device.windows = true;
    } // Android


    if (android && !windows) {
      device.os = 'android';
      device.osVersion = android[2];
      device.android = true;
      device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
    }

    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    } // iOS


    if (iphone && !ipod) {
      device.osVersion = iphone[2].replace(/_/g, '.');
      device.iphone = true;
    }

    if (ipad) {
      device.osVersion = ipad[2].replace(/_/g, '.');
      device.ipad = true;
    }

    if (ipod) {
      device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
      device.iphone = true;
    } // iOS 8+ changed UA


    if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
      if (device.osVersion.split('.')[0] === '10') {
        device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
      }
    } // Desktop


    device.desktop = !(device.os || device.android || device.webView); // Webview

    device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i); // Minimal UI

    if (device.os && device.os === 'ios') {
      var osVersionArr = device.osVersion.split('.');
      var metaViewport = doc.querySelector('meta[name="viewport"]');
      device.minimalUi = !device.webView && (ipod || iphone) && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
    } // Pixel Ratio


    device.pixelRatio = win.devicePixelRatio || 1; // Export object

    return device;
  }();

  function onTouchStart(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params;
    var touches = swiper.touches;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }

    var e = event;

    if (e.originalEvent) {
      e = e.originalEvent;
    }

    data.isTouchEvent = e.type === 'touchstart';

    if (!data.isTouchEvent && 'which' in e && e.which === 3) {
      return;
    }

    if (!data.isTouchEvent && 'button' in e && e.button > 0) {
      return;
    }

    if (data.isTouched && data.isMoved) {
      return;
    }

    if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
      swiper.allowClick = true;
      return;
    }

    if (params.swipeHandler) {
      if (!$(e).closest(params.swipeHandler)[0]) {
        return;
      }
    }

    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    var startX = touches.currentX;
    var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
      return;
    }

    Utils.extend(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = Utils.now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;

    if (params.threshold > 0) {
      data.allowThresholdMove = false;
    }

    if (e.type !== 'touchstart') {
      var preventDefault = true;

      if ($(e.target).is(data.formElements)) {
        preventDefault = false;
      }

      if (doc.activeElement && $(doc.activeElement).is(data.formElements) && doc.activeElement !== e.target) {
        doc.activeElement.blur();
      }

      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

      if (params.touchStartForcePreventDefault || shouldPreventDefault) {
        e.preventDefault();
      }
    }

    swiper.emit('touchStart', e);
  }

  function onTouchMove(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params;
    var touches = swiper.touches;
    var rtl = swiper.rtlTranslate;
    var e = event;

    if (e.originalEvent) {
      e = e.originalEvent;
    }

    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      return;
    }

    if (data.isTouchEvent && e.type === 'mousemove') {
      return;
    }

    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }

    if (!swiper.allowTouchMove) {
      // isMoved = true;
      swiper.allowClick = false;

      if (data.isTouched) {
        Utils.extend(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = Utils.now();
      }

      return;
    }

    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }

    if (data.isTouchEvent && doc.activeElement) {
      if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }

    if (e.targetTouches && e.targetTouches.length > 1) {
      return;
    }

    touches.currentX = pageX;
    touches.currentY = pageY;
    var diffX = touches.currentX - touches.startX;
    var diffY = touches.currentY - touches.startY;

    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) {
      return;
    }

    if (typeof data.isScrolling === 'undefined') {
      var touchAngle;

      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }

    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }

    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }

    if (!data.startMoving) {
      return;
    }

    swiper.allowClick = false;
    e.preventDefault();

    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }

    if (!data.isMoved) {
      if (params.loop) {
        swiper.loopFix();
      }

      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);

      if (swiper.animating) {
        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
      }

      data.allowMomentumBounce = false; // Grab Cursor

      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }

      swiper.emit('sliderFirstMove', e);
    }

    swiper.emit('sliderMove', e);
    data.isMoved = true;
    var diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;

    if (rtl) {
      diff = -diff;
    }

    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    data.currentTranslate = diff + data.startTranslate;
    var disableParentSwiper = true;
    var resistanceRatio = params.resistanceRatio;

    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }

    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;

      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      }
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;

      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }
    }

    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    } // Directions locks


    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    } // Threshold


    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }

    if (!params.followFinger) {
      return;
    } // Update active index in free mode


    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    if (params.freeMode) {
      // Velocity
      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
          time: data.touchStartTime
        });
      }

      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
        time: Utils.now()
      });
    } // Update progress


    swiper.updateProgress(data.currentTranslate); // Update translate

    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params;
    var touches = swiper.touches;
    var rtl = swiper.rtlTranslate;
    var $wrapperEl = swiper.$wrapperEl;
    var slidesGrid = swiper.slidesGrid;
    var snapGrid = swiper.snapGrid;
    var e = event;

    if (e.originalEvent) {
      e = e.originalEvent;
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }

    data.allowTouchCallbacks = false;

    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }

      data.isMoved = false;
      data.startMoving = false;
      return;
    } // Return Grab Cursor


    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    } // Time diff


    var touchEndTime = Utils.now();
    var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

    if (swiper.allowClick) {
      swiper.updateClickedSlide(e);
      swiper.emit('tap', e);

      if (timeDiff < 300 && touchEndTime - data.lastClickTime > 300) {
        if (data.clickTimeout) {
          clearTimeout(data.clickTimeout);
        }

        data.clickTimeout = Utils.nextTick(function () {
          if (!swiper || swiper.destroyed) {
            return;
          }

          swiper.emit('click', e);
        }, 300);
      }

      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        if (data.clickTimeout) {
          clearTimeout(data.clickTimeout);
        }

        swiper.emit('doubleTap', e);
      }
    }

    data.lastClickTime = Utils.now();
    Utils.nextTick(function () {
      if (!swiper.destroyed) {
        swiper.allowClick = true;
      }
    });

    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }

    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    var currentPos;

    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }

    if (params.freeMode) {
      if (currentPos < -swiper.minTranslate()) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (currentPos > -swiper.maxTranslate()) {
        if (swiper.slides.length < snapGrid.length) {
          swiper.slideTo(snapGrid.length - 1);
        } else {
          swiper.slideTo(swiper.slides.length - 1);
        }

        return;
      }

      if (params.freeModeMomentum) {
        if (data.velocities.length > 1) {
          var lastMoveEvent = data.velocities.pop();
          var velocityEvent = data.velocities.pop();
          var distance = lastMoveEvent.position - velocityEvent.position;
          var time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;

          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
            swiper.velocity = 0;
          } // this implies that the user stopped moving a finger then released.
          // There would be no events with distance zero, so the last event is stale.


          if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
            swiper.velocity = 0;
          }
        } else {
          swiper.velocity = 0;
        }

        swiper.velocity *= params.freeModeMomentumVelocityRatio;
        data.velocities.length = 0;
        var momentumDuration = 1000 * params.freeModeMomentumRatio;
        var momentumDistance = swiper.velocity * momentumDuration;
        var newPosition = swiper.translate + momentumDistance;

        if (rtl) {
          newPosition = -newPosition;
        }

        var doBounce = false;
        var afterBouncePosition;
        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
        var needsLoopFix;

        if (newPosition < swiper.maxTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
              newPosition = swiper.maxTranslate() - bounceAmount;
            }

            afterBouncePosition = swiper.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.maxTranslate();
          }

          if (params.loop && params.centeredSlides) {
            needsLoopFix = true;
          }
        } else if (newPosition > swiper.minTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition - swiper.minTranslate() > bounceAmount) {
              newPosition = swiper.minTranslate() + bounceAmount;
            }

            afterBouncePosition = swiper.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.minTranslate();
          }

          if (params.loop && params.centeredSlides) {
            needsLoopFix = true;
          }
        } else if (params.freeModeSticky) {
          var nextSlide;

          for (var j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }

          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }

          newPosition = -newPosition;
        }

        if (needsLoopFix) {
          swiper.once('transitionEnd', function () {
            swiper.loopFix();
          });
        } // Fix duration


        if (swiper.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
          }
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        }

        if (params.freeModeMomentumBounce && doBounce) {
          swiper.updateProgress(afterBouncePosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) {
              return;
            }

            swiper.emit('momentumBounce');
            swiper.setTransition(params.speed);
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) {
                return;
              }

              swiper.transitionEnd();
            });
          });
        } else if (swiper.velocity) {
          swiper.updateProgress(newPosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);

          if (!swiper.animating) {
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) {
                return;
              }

              swiper.transitionEnd();
            });
          }
        } else {
          swiper.updateProgress(newPosition);
        }

        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      return;
    } // Find current slide


    var stopIndex = 0;
    var groupSize = swiper.slidesSizesGrid[0];

    for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
      if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
          stopIndex = i;
          groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    } // Find current slide size


    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) {
          swiper.slideTo(stopIndex + params.slidesPerGroup);
        } else {
          swiper.slideTo(stopIndex);
        }
      }

      if (swiper.swipeDirection === 'prev') {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + params.slidesPerGroup);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + params.slidesPerGroup);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize() {
    var swiper = this;
    var params = swiper.params;
    var el = swiper.el;

    if (el && el.offsetWidth === 0) {
      return;
    } // Breakpoints


    if (params.breakpoints) {
      swiper.setBreakpoint();
    } // Save locks


    var allowSlideNext = swiper.allowSlideNext;
    var allowSlidePrev = swiper.allowSlidePrev;
    var snapGrid = swiper.snapGrid; // Disable locks on resize

    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();

    if (params.freeMode) {
      var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    } // Return locks after resize


    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick(e) {
    var swiper = this;

    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) {
        e.preventDefault();
      }

      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function attachEvents() {
    var swiper = this;
    var params = swiper.params;
    var touchEvents = swiper.touchEvents;
    var el = swiper.el;
    var wrapperEl = swiper.wrapperEl;
    {
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
    var capture = !!params.nested; // Touch Events

    {
      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
        target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (Support.touch) {
          var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
            passive: false,
            capture: capture
          } : capture);
          target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
        }

        if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
          target.addEventListener('mousedown', swiper.onTouchStart, false);
          doc.addEventListener('mousemove', swiper.onTouchMove, capture);
          doc.addEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        target.addEventListener('click', swiper.onClick, true);
      }
    } // Resize handler

    swiper.on(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  }

  function detachEvents() {
    var swiper = this;
    var params = swiper.params;
    var touchEvents = swiper.touchEvents;
    var el = swiper.el;
    var wrapperEl = swiper.wrapperEl;
    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
    var capture = !!params.nested; // Touch Events

    {
      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
        target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (Support.touch) {
          var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
        }

        if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
          target.removeEventListener('mousedown', swiper.onTouchStart, false);
          doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
          doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        target.removeEventListener('click', swiper.onClick, true);
      }
    } // Resize handler

    swiper.off(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
  }

  var events = {
    attachEvents: attachEvents,
    detachEvents: detachEvents
  };

  function setBreakpoint() {
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var initialized = swiper.initialized;
    var loopedSlides = swiper.loopedSlides;
    if (loopedSlides === void 0) loopedSlides = 0;
    var params = swiper.params;
    var breakpoints = params.breakpoints;

    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) {
      return;
    } // Set breakpoint for window width and update parameters


    var breakpoint = swiper.getBreakpoint(breakpoints);

    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];

          if (typeof paramValue === 'undefined') {
            return;
          }

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var needsReLoop = params.loop && breakpointParams.slidesPerView !== params.slidesPerView;
      Utils.extend(swiper.params, breakpointParams);
      Utils.extend(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });
      swiper.currentBreakpoint = breakpoint;

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }
  }

  function getBreakpoint(breakpoints) {
    var swiper = this; // Get breakpoint for window width

    if (!breakpoints) {
      return undefined;
    }

    var breakpoint = false;
    var points = [];
    Object.keys(breakpoints).forEach(function (point) {
      points.push(point);
    });
    points.sort(function (a, b) {
      return parseInt(a, 10) - parseInt(b, 10);
    });

    for (var i = 0; i < points.length; i += 1) {
      var point = points[i];

      if (swiper.params.breakpointsInverse) {
        if (point <= win.innerWidth) {
          breakpoint = point;
        }
      } else if (point >= win.innerWidth && !breakpoint) {
        breakpoint = point;
      }
    }

    return breakpoint || 'max';
  }

  var breakpoints = {
    setBreakpoint: setBreakpoint,
    getBreakpoint: getBreakpoint
  };

  var Browser = function Browser() {
    function isSafari() {
      var ua = win.navigator.userAgent.toLowerCase();
      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }

    return {
      isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
      isEdge: !!win.navigator.userAgent.match(/Edge/g),
      isSafari: isSafari(),
      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent)
    };
  }();

  function addClasses() {
    var swiper = this;
    var classNames = swiper.classNames;
    var params = swiper.params;
    var rtl = swiper.rtl;
    var $el = swiper.$el;
    var suffixes = [];
    suffixes.push(params.direction);

    if (params.freeMode) {
      suffixes.push('free-mode');
    }

    if (!Support.flexbox) {
      suffixes.push('no-flexbox');
    }

    if (params.autoHeight) {
      suffixes.push('autoheight');
    }

    if (rtl) {
      suffixes.push('rtl');
    }

    if (params.slidesPerColumn > 1) {
      suffixes.push('multirow');
    }

    if (Device.android) {
      suffixes.push('android');
    }

    if (Device.ios) {
      suffixes.push('ios');
    } // WP8 Touch Events Fix


    if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      suffixes.push("wp8-" + params.direction);
    }

    suffixes.forEach(function (suffix) {
      classNames.push(params.containerModifierClass + suffix);
    });
    $el.addClass(classNames.join(' '));
  }

  function removeClasses() {
    var swiper = this;
    var $el = swiper.$el;
    var classNames = swiper.classNames;
    $el.removeClass(classNames.join(' '));
  }

  var classes = {
    addClasses: addClasses,
    removeClasses: removeClasses
  };

  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    var image;

    function onReady() {
      if (callback) {
        callback();
      }
    }

    if (!imageEl.complete || !checkForComplete) {
      if (src) {
        image = new win.Image();
        image.onload = onReady;
        image.onerror = onReady;

        if (sizes) {
          image.sizes = sizes;
        }

        if (srcset) {
          image.srcset = srcset;
        }

        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      // image already loaded...
      onReady();
    }
  }

  function preloadImages() {
    var swiper = this;
    swiper.imagesToLoad = swiper.$el.find('img');

    function onReady() {
      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) {
        return;
      }

      if (swiper.imagesLoaded !== undefined) {
        swiper.imagesLoaded += 1;
      }

      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) {
          swiper.update();
        }

        swiper.emit('imagesReady');
      }
    }

    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
      var imageEl = swiper.imagesToLoad[i];
      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
    }
  }

  var images = {
    loadImage: loadImage,
    preloadImages: preloadImages
  };

  function checkOverflow() {
    var swiper = this;
    var wasLocked = swiper.isLocked;
    swiper.isLocked = swiper.snapGrid.length === 1;
    swiper.allowSlideNext = !swiper.isLocked;
    swiper.allowSlidePrev = !swiper.isLocked; // events

    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
    }

    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
      swiper.navigation.update();
    }
  }

  var checkOverflow$1 = {
    checkOverflow: checkOverflow
  };
  var defaults = {
    init: true,
    direction: 'horizontal',
    touchEventsTarget: 'container',
    initialSlide: 0,
    speed: 300,
    //
    preventInteractionOnTransition: false,
    // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Free mode
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: undefined,
    breakpointsInverse: false,
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: 'column',
    slidesPerGroup: 1,
    centeredSlides: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: false,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: true,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    watchSlidesVisibility: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    // NS
    containerModifierClass: 'swiper-container-',
    // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    // Callbacks
    runCallbacksOnInit: true
  };
  var prototypes = {
    update: update,
    translate: translate,
    transition: transition$1,
    slide: slide,
    loop: loop,
    grabCursor: grabCursor,
    manipulation: manipulation,
    events: events,
    breakpoints: breakpoints,
    checkOverflow: checkOverflow$1,
    classes: classes,
    images: images
  };
  var extendedDefaults = {};

  var Swiper =
  /*@__PURE__*/
  function (SwiperClass$$1) {
    function Swiper() {
      var assign;
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var el;
      var params;

      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
        params = args[0];
      } else {
        assign = args, el = assign[0], params = assign[1];
      }

      if (!params) {
        params = {};
      }

      params = Utils.extend({}, params);

      if (el && !params.el) {
        params.el = el;
      }

      SwiperClass$$1.call(this, params);
      Object.keys(prototypes).forEach(function (prototypeGroup) {
        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
          if (!Swiper.prototype[protoMethod]) {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
          }
        });
      }); // Swiper Instance

      var swiper = this;

      if (typeof swiper.modules === 'undefined') {
        swiper.modules = {};
      }

      Object.keys(swiper.modules).forEach(function (moduleName) {
        var module = swiper.modules[moduleName];

        if (module.params) {
          var moduleParamName = Object.keys(module.params)[0];
          var moduleParams = module.params[moduleParamName];

          if (typeof moduleParams !== 'object' || moduleParams === null) {
            return;
          }

          if (!(moduleParamName in params && 'enabled' in moduleParams)) {
            return;
          }

          if (params[moduleParamName] === true) {
            params[moduleParamName] = {
              enabled: true
            };
          }

          if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
            params[moduleParamName].enabled = true;
          }

          if (!params[moduleParamName]) {
            params[moduleParamName] = {
              enabled: false
            };
          }
        }
      }); // Extend defaults with modules params

      var swiperParams = Utils.extend({}, defaults);
      swiper.useModulesParams(swiperParams); // Extend defaults with passed params

      swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = Utils.extend({}, swiper.params);
      swiper.passedParams = Utils.extend({}, params); // Save Dom lib

      swiper.$ = $; // Find el

      var $el = $(swiper.params.el);
      el = $el[0];

      if (!el) {
        return undefined;
      }

      if ($el.length > 1) {
        var swipers = [];
        $el.each(function (index, containerEl) {
          var newParams = Utils.extend({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      }

      el.swiper = swiper;
      $el.data('swiper', swiper); // Find Wrapper

      var $wrapperEl = $el.children("." + swiper.params.wrapperClass); // Extend Swiper

      Utils.extend(swiper, {
        $el: $el,
        el: el,
        $wrapperEl: $wrapperEl,
        wrapperEl: $wrapperEl[0],
        // Classes
        classNames: [],
        // Slides
        slides: $(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal: function isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },
        isVertical: function isVertical() {
          return swiper.params.direction === 'vertical';
        },
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box',
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          var touch = ['touchstart', 'touchmove', 'touchend'];
          var desktop = ['mousedown', 'mousemove', 'mouseup'];

          if (Support.pointerEvents) {
            desktop = ['pointerdown', 'pointermove', 'pointerup'];
          } else if (Support.prefixedPointerEvents) {
            desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
          }

          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2]
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          formElements: 'input, select, option, textarea, button, video',
          // Last click time
          lastClickTime: Utils.now(),
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          isTouchEvent: undefined,
          startMoving: undefined
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      }); // Install Modules

      swiper.useModules(); // Init

      if (swiper.params.init) {
        swiper.init();
      } // Return app instance


      return swiper;
    }

    if (SwiperClass$$1) Swiper.__proto__ = SwiperClass$$1;
    Swiper.prototype = Object.create(SwiperClass$$1 && SwiperClass$$1.prototype);
    Swiper.prototype.constructor = Swiper;
    var staticAccessors = {
      extendedDefaults: {
        configurable: true
      },
      defaults: {
        configurable: true
      },
      Class: {
        configurable: true
      },
      $: {
        configurable: true
      }
    };

    Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic() {
      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides;
      var slidesGrid = swiper.slidesGrid;
      var swiperSize = swiper.size;
      var activeIndex = swiper.activeIndex;
      var spv = 1;

      if (params.centeredSlides) {
        var slideSize = slides[activeIndex].swiperSlideSize;
        var breakLoop;

        for (var i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;

            if (slideSize > swiperSize) {
              breakLoop = true;
            }
          }
        }

        for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
          if (slides[i$1] && !breakLoop) {
            slideSize += slides[i$1].swiperSlideSize;
            spv += 1;

            if (slideSize > swiperSize) {
              breakLoop = true;
            }
          }
        }
      } else {
        for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
          if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
            spv += 1;
          }
        }
      }

      return spv;
    };

    Swiper.prototype.update = function update$$1() {
      var swiper = this;

      if (!swiper || swiper.destroyed) {
        return;
      }

      var snapGrid = swiper.snapGrid;
      var params = swiper.params; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      var translated;

      if (swiper.params.freeMode) {
        setTranslate();

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (!translated) {
          setTranslate();
        }
      }

      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }

      swiper.emit('update');
    };

    Swiper.prototype.init = function init() {
      var swiper = this;

      if (swiper.initialized) {
        return;
      }

      swiper.emit('beforeInit'); // Set breakpoint

      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      } // Add Classes


      swiper.addClasses(); // Create loop

      if (swiper.params.loop) {
        swiper.loopCreate();
      } // Update size


      swiper.updateSize(); // Update slides

      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      } // Set Grab Cursor


      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      } // Slide To Initial Slide


      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
      } // Attach events


      swiper.attachEvents(); // Init Flag

      swiper.initialized = true; // Emit

      swiper.emit('init');
    };

    Swiper.prototype.destroy = function destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) deleteInstance = true;
      if (cleanStyles === void 0) cleanStyles = true;
      var swiper = this;
      var params = swiper.params;
      var $el = swiper.$el;
      var $wrapperEl = swiper.$wrapperEl;
      var slides = swiper.slides;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy'); // Init Flag

      swiper.initialized = false; // Detach events

      swiper.detachEvents(); // Destroy loop

      if (params.loop) {
        swiper.loopDestroy();
      } // Cleanup styles


      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');

        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
        }
      }

      swiper.emit('destroy'); // Detach emitter events

      Object.keys(swiper.eventsListeners).forEach(function (eventName) {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        swiper.$el.data('swiper', null);
        Utils.deleteProps(swiper);
      }

      swiper.destroyed = true;
      return null;
    };

    Swiper.extendDefaults = function extendDefaults(newDefaults) {
      Utils.extend(extendedDefaults, newDefaults);
    };

    staticAccessors.extendedDefaults.get = function () {
      return extendedDefaults;
    };

    staticAccessors.defaults.get = function () {
      return defaults;
    };

    staticAccessors.Class.get = function () {
      return SwiperClass$$1;
    };

    staticAccessors.$.get = function () {
      return $;
    };

    Object.defineProperties(Swiper, staticAccessors);
    return Swiper;
  }(SwiperClass);

  var Device$1 = {
    name: 'device',
    proto: {
      device: Device
    },
    static: {
      device: Device
    }
  };
  var Support$1 = {
    name: 'support',
    proto: {
      support: Support
    },
    static: {
      support: Support
    }
  };
  var Browser$1 = {
    name: 'browser',
    proto: {
      browser: Browser
    },
    static: {
      browser: Browser
    }
  };
  var Resize = {
    name: 'resize',
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        resize: {
          resizeHandler: function resizeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) {
              return;
            }

            swiper.emit('beforeResize');
            swiper.emit('resize');
          },
          orientationChangeHandler: function orientationChangeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) {
              return;
            }

            swiper.emit('orientationchange');
          }
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this; // Emit resize

        win.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

        win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      },
      destroy: function destroy() {
        var swiper = this;
        win.removeEventListener('resize', swiper.resize.resizeHandler);
        win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      }
    }
  };
  var Observer = {
    func: win.MutationObserver || win.WebkitMutationObserver,
    attach: function attach(target, options) {
      if (options === void 0) options = {};
      var swiper = this;
      var ObserverFunc = Observer.func;
      var observer = new ObserverFunc(function (mutations) {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (mutations.length === 1) {
          swiper.emit('observerUpdate', mutations[0]);
          return;
        }

        var observerUpdate = function observerUpdate() {
          swiper.emit('observerUpdate', mutations[0]);
        };

        if (win.requestAnimationFrame) {
          win.requestAnimationFrame(observerUpdate);
        } else {
          win.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData
      });
      swiper.observer.observers.push(observer);
    },
    init: function init() {
      var swiper = this;

      if (!Support.observer || !swiper.params.observer) {
        return;
      }

      if (swiper.params.observeParents) {
        var containerParents = swiper.$el.parents();

        for (var i = 0; i < containerParents.length; i += 1) {
          swiper.observer.attach(containerParents[i]);
        }
      } // Observe container


      swiper.observer.attach(swiper.$el[0], {
        childList: swiper.params.observeSlideChildren
      }); // Observe wrapper

      swiper.observer.attach(swiper.$wrapperEl[0], {
        attributes: false
      });
    },
    destroy: function destroy() {
      var swiper = this;
      swiper.observer.observers.forEach(function (observer) {
        observer.disconnect();
      });
      swiper.observer.observers = [];
    }
  };
  var Observer$1 = {
    name: 'observer',
    params: {
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        observer: {
          init: Observer.init.bind(swiper),
          attach: Observer.attach.bind(swiper),
          destroy: Observer.destroy.bind(swiper),
          observers: []
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.observer.init();
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.observer.destroy();
      }
    }
  };
  var Virtual = {
    update: function update(force) {
      var swiper = this;
      var ref = swiper.params;
      var slidesPerView = ref.slidesPerView;
      var slidesPerGroup = ref.slidesPerGroup;
      var centeredSlides = ref.centeredSlides;
      var ref$1 = swiper.params.virtual;
      var addSlidesBefore = ref$1.addSlidesBefore;
      var addSlidesAfter = ref$1.addSlidesAfter;
      var ref$2 = swiper.virtual;
      var previousFrom = ref$2.from;
      var previousTo = ref$2.to;
      var slides = ref$2.slides;
      var previousSlidesGrid = ref$2.slidesGrid;
      var renderSlide = ref$2.renderSlide;
      var previousOffset = ref$2.offset;
      swiper.updateActiveIndex();
      var activeIndex = swiper.activeIndex || 0;
      var offsetProp;

      if (swiper.rtlTranslate) {
        offsetProp = 'right';
      } else {
        offsetProp = swiper.isHorizontal() ? 'left' : 'top';
      }

      var slidesAfter;
      var slidesBefore;

      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
        slidesBefore = slidesPerGroup + addSlidesAfter;
      }

      var from = Math.max((activeIndex || 0) - slidesBefore, 0);
      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
      Utils.extend(swiper.virtual, {
        from: from,
        to: to,
        offset: offset,
        slidesGrid: swiper.slidesGrid
      });

      function onRendered() {
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        if (swiper.lazy && swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      }

      if (previousFrom === from && previousTo === to && !force) {
        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
          swiper.slides.css(offsetProp, offset + "px");
        }

        swiper.updateProgress();
        return;
      }

      if (swiper.params.virtual.renderExternal) {
        swiper.params.virtual.renderExternal.call(swiper, {
          offset: offset,
          from: from,
          to: to,
          slides: function getSlides() {
            var slidesToRender = [];

            for (var i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }

            return slidesToRender;
          }()
        });
        onRendered();
        return;
      }

      var prependIndexes = [];
      var appendIndexes = [];

      if (force) {
        swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
      } else {
        for (var i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + i + "\"]").remove();
          }
        }
      }

      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
        if (i$1 >= from && i$1 <= to) {
          if (typeof previousTo === 'undefined' || force) {
            appendIndexes.push(i$1);
          } else {
            if (i$1 > previousTo) {
              appendIndexes.push(i$1);
            }

            if (i$1 < previousFrom) {
              prependIndexes.push(i$1);
            }
          }
        }
      }

      appendIndexes.forEach(function (index) {
        swiper.$wrapperEl.append(renderSlide(slides[index], index));
      });
      prependIndexes.sort(function (a, b) {
        return b - a;
      }).forEach(function (index) {
        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
      });
      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, offset + "px");
      onRendered();
    },
    renderSlide: function renderSlide(slide, index) {
      var swiper = this;
      var params = swiper.params.virtual;

      if (params.cache && swiper.virtual.cache[index]) {
        return swiper.virtual.cache[index];
      }

      var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $("<div class=\"" + swiper.params.slideClass + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>");

      if (!$slideEl.attr('data-swiper-slide-index')) {
        $slideEl.attr('data-swiper-slide-index', index);
      }

      if (params.cache) {
        swiper.virtual.cache[index] = $slideEl;
      }

      return $slideEl;
    },
    appendSlide: function appendSlide(slide) {
      var swiper = this;
      swiper.virtual.slides.push(slide);
      swiper.virtual.update(true);
    },
    prependSlide: function prependSlide(slide) {
      var swiper = this;
      swiper.virtual.slides.unshift(slide);

      if (swiper.params.virtual.cache) {
        var cache = swiper.virtual.cache;
        var newCache = {};
        Object.keys(cache).forEach(function (cachedIndex) {
          newCache[cachedIndex + 1] = cache[cachedIndex];
        });
        swiper.virtual.cache = newCache;
      }

      swiper.virtual.update(true);
      swiper.slideNext(0);
    }
  };
  var Virtual$1 = {
    name: 'virtual',
    params: {
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        virtual: {
          update: Virtual.update.bind(swiper),
          appendSlide: Virtual.appendSlide.bind(swiper),
          prependSlide: Virtual.prependSlide.bind(swiper),
          renderSlide: Virtual.renderSlide.bind(swiper),
          slides: swiper.params.virtual.slides,
          cache: {}
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (!swiper.params.virtual.enabled) {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
        var overwriteParams = {
          watchSlidesProgress: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);

        if (!swiper.params.initialSlide) {
          swiper.virtual.update();
        }
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (!swiper.params.virtual.enabled) {
          return;
        }

        swiper.virtual.update();
      }
    }
  };
  var Keyboard = {
    handle: function handle(event) {
      var swiper = this;
      var rtl = swiper.rtlTranslate;
      var e = event;

      if (e.originalEvent) {
        e = e.originalEvent;
      } // jquery fix


      var kc = e.keyCode || e.charCode; // Directions locks

      if (!swiper.allowSlideNext && (swiper.isHorizontal() && kc === 39 || swiper.isVertical() && kc === 40)) {
        return false;
      }

      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && kc === 37 || swiper.isVertical() && kc === 38)) {
        return false;
      }

      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return undefined;
      }

      if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
        return undefined;
      }

      if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
        var inView = false; // Check that swiper should be inside of visible area of window

        if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
          return undefined;
        }

        var windowWidth = win.innerWidth;
        var windowHeight = win.innerHeight;
        var swiperOffset = swiper.$el.offset();

        if (rtl) {
          swiperOffset.left -= swiper.$el[0].scrollLeft;
        }

        var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

        for (var i = 0; i < swiperCoord.length; i += 1) {
          var point = swiperCoord[i];

          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
            inView = true;
          }
        }

        if (!inView) {
          return undefined;
        }
      }

      if (swiper.isHorizontal()) {
        if (kc === 37 || kc === 39) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }

        if (kc === 39 && !rtl || kc === 37 && rtl) {
          swiper.slideNext();
        }

        if (kc === 37 && !rtl || kc === 39 && rtl) {
          swiper.slidePrev();
        }
      } else {
        if (kc === 38 || kc === 40) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }

        if (kc === 40) {
          swiper.slideNext();
        }

        if (kc === 38) {
          swiper.slidePrev();
        }
      }

      swiper.emit('keyPress', kc);
      return undefined;
    },
    enable: function enable() {
      var swiper = this;

      if (swiper.keyboard.enabled) {
        return;
      }

      $(doc).on('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = true;
    },
    disable: function disable() {
      var swiper = this;

      if (!swiper.keyboard.enabled) {
        return;
      }

      $(doc).off('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = false;
    }
  };
  var Keyboard$1 = {
    name: 'keyboard',
    params: {
      keyboard: {
        enabled: false,
        onlyInViewport: true
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        keyboard: {
          enabled: false,
          enable: Keyboard.enable.bind(swiper),
          disable: Keyboard.disable.bind(swiper),
          handle: Keyboard.handle.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.keyboard.enabled) {
          swiper.keyboard.enable();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.keyboard.enabled) {
          swiper.keyboard.disable();
        }
      }
    }
  };

  function isEventSupported() {
    var eventName = 'onwheel';
    var isSupported = eventName in doc;

    if (!isSupported) {
      var element = doc.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && doc.implementation && doc.implementation.hasFeature // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && doc.implementation.hasFeature('', '') !== true) {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  var Mousewheel = {
    lastScrollTime: Utils.now(),
    event: function getEvent() {
      if (win.navigator.userAgent.indexOf('firefox') > -1) {
        return 'DOMMouseScroll';
      }

      return isEventSupported() ? 'wheel' : 'mousewheel';
    }(),
    normalize: function normalize(e) {
      // Reasonable defaults
      var PIXEL_STEP = 10;
      var LINE_HEIGHT = 40;
      var PAGE_HEIGHT = 800;
      var sX = 0;
      var sY = 0; // spinX, spinY

      var pX = 0;
      var pY = 0; // pixelX, pixelY
      // Legacy

      if ('detail' in e) {
        sY = e.detail;
      }

      if ('wheelDelta' in e) {
        sY = -e.wheelDelta / 120;
      }

      if ('wheelDeltaY' in e) {
        sY = -e.wheelDeltaY / 120;
      }

      if ('wheelDeltaX' in e) {
        sX = -e.wheelDeltaX / 120;
      } // side scrolling on FF with DOMMouseScroll


      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }

      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;

      if ('deltaY' in e) {
        pY = e.deltaY;
      }

      if ('deltaX' in e) {
        pX = e.deltaX;
      }

      if ((pX || pY) && e.deltaMode) {
        if (e.deltaMode === 1) {
          // delta in LINE units
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          // delta in PAGE units
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      } // Fall-back if spin cannot be determined


      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }

      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }

      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    },
    handleMouseEnter: function handleMouseEnter() {
      var swiper = this;
      swiper.mouseEntered = true;
    },
    handleMouseLeave: function handleMouseLeave() {
      var swiper = this;
      swiper.mouseEntered = false;
    },
    handle: function handle(event) {
      var e = event;
      var swiper = this;
      var params = swiper.params.mousewheel;

      if (!swiper.mouseEntered && !params.releaseOnEdges) {
        return true;
      }

      if (e.originalEvent) {
        e = e.originalEvent;
      } // jquery fix


      var delta = 0;
      var rtlFactor = swiper.rtlTranslate ? -1 : 1;
      var data = Mousewheel.normalize(e);

      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {
            delta = data.pixelX * rtlFactor;
          } else {
            return true;
          }
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {
          delta = data.pixelY;
        } else {
          return true;
        }
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }

      if (delta === 0) {
        return true;
      }

      if (params.invert) {
        delta = -delta;
      }

      if (!swiper.params.freeMode) {
        if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
          if (delta < 0) {
            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
              swiper.slideNext();
              swiper.emit('scroll', e);
            } else if (params.releaseOnEdges) {
              return true;
            }
          } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
            swiper.slidePrev();
            swiper.emit('scroll', e);
          } else if (params.releaseOnEdges) {
            return true;
          }
        }

        swiper.mousewheel.lastScrollTime = new win.Date().getTime();
      } else {
        // Freemode or scrollContainer:
        if (swiper.params.loop) {
          swiper.loopFix();
        }

        var position = swiper.getTranslate() + delta * params.sensitivity;
        var wasBeginning = swiper.isBeginning;
        var wasEnd = swiper.isEnd;

        if (position >= swiper.minTranslate()) {
          position = swiper.minTranslate();
        }

        if (position <= swiper.maxTranslate()) {
          position = swiper.maxTranslate();
        }

        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeModeSticky) {
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = Utils.nextTick(function () {
            swiper.slideToClosest();
          }, 300);
        } // Emit event


        swiper.emit('scroll', e); // Stop autoplay

        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) {
          swiper.autoplay.stop();
        } // Return page scroll on edge positions


        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) {
          return true;
        }
      }

      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }

      return false;
    },
    enable: function enable() {
      var swiper = this;

      if (!Mousewheel.event) {
        return false;
      }

      if (swiper.mousewheel.enabled) {
        return false;
      }

      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }

      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
      target.on(Mousewheel.event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = true;
      return true;
    },
    disable: function disable() {
      var swiper = this;

      if (!Mousewheel.event) {
        return false;
      }

      if (!swiper.mousewheel.enabled) {
        return false;
      }

      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }

      target.off(Mousewheel.event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = false;
      return true;
    }
  };
  var Mousewheel$1 = {
    name: 'mousewheel',
    params: {
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarged: 'container'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        mousewheel: {
          enabled: false,
          enable: Mousewheel.enable.bind(swiper),
          disable: Mousewheel.disable.bind(swiper),
          handle: Mousewheel.handle.bind(swiper),
          handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
          handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
          lastScrollTime: Utils.now()
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.mousewheel.enabled) {
          swiper.mousewheel.enable();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.mousewheel.enabled) {
          swiper.mousewheel.disable();
        }
      }
    }
  };
  var Navigation = {
    update: function update() {
      // Update Navigation Buttons
      var swiper = this;
      var params = swiper.params.navigation;

      if (swiper.params.loop) {
        return;
      }

      var ref = swiper.navigation;
      var $nextEl = ref.$nextEl;
      var $prevEl = ref.$prevEl;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          $prevEl.addClass(params.disabledClass);
        } else {
          $prevEl.removeClass(params.disabledClass);
        }

        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          $nextEl.addClass(params.disabledClass);
        } else {
          $nextEl.removeClass(params.disabledClass);
        }

        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    },
    onPrevClick: function onPrevClick(e) {
      var swiper = this;
      e.preventDefault();

      if (swiper.isBeginning && !swiper.params.loop) {
        return;
      }

      swiper.slidePrev();
    },
    onNextClick: function onNextClick(e) {
      var swiper = this;
      e.preventDefault();

      if (swiper.isEnd && !swiper.params.loop) {
        return;
      }

      swiper.slideNext();
    },
    init: function init() {
      var swiper = this;
      var params = swiper.params.navigation;

      if (!(params.nextEl || params.prevEl)) {
        return;
      }

      var $nextEl;
      var $prevEl;

      if (params.nextEl) {
        $nextEl = $(params.nextEl);

        if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
          $nextEl = swiper.$el.find(params.nextEl);
        }
      }

      if (params.prevEl) {
        $prevEl = $(params.prevEl);

        if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
          $prevEl = swiper.$el.find(params.prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on('click', swiper.navigation.onNextClick);
      }

      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on('click', swiper.navigation.onPrevClick);
      }

      Utils.extend(swiper.navigation, {
        $nextEl: $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl: $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });
    },
    destroy: function destroy() {
      var swiper = this;
      var ref = swiper.navigation;
      var $nextEl = ref.$nextEl;
      var $prevEl = ref.$prevEl;

      if ($nextEl && $nextEl.length) {
        $nextEl.off('click', swiper.navigation.onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }

      if ($prevEl && $prevEl.length) {
        $prevEl.off('click', swiper.navigation.onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    }
  };
  var Navigation$1 = {
    name: 'navigation',
    params: {
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        navigation: {
          init: Navigation.init.bind(swiper),
          update: Navigation.update.bind(swiper),
          destroy: Navigation.destroy.bind(swiper),
          onNextClick: Navigation.onNextClick.bind(swiper),
          onPrevClick: Navigation.onPrevClick.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.navigation.init();
        swiper.navigation.update();
      },
      toEdge: function toEdge() {
        var swiper = this;
        swiper.navigation.update();
      },
      fromEdge: function fromEdge() {
        var swiper = this;
        swiper.navigation.update();
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.navigation.destroy();
      },
      click: function click(e) {
        var swiper = this;
        var ref = swiper.navigation;
        var $nextEl = ref.$nextEl;
        var $prevEl = ref.$prevEl;

        if (swiper.params.navigation.hideOnClick && !$(e.target).is($prevEl) && !$(e.target).is($nextEl)) {
          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      }
    }
  };
  var Pagination = {
    update: function update() {
      // Render || Update Pagination bullets/items
      var swiper = this;
      var rtl = swiper.rtl;
      var params = swiper.params.pagination;

      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
        return;
      }

      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      var $el = swiper.pagination.$el; // Current/Total

      var current;
      var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
          current -= slidesLength - swiper.loopedSlides * 2;
        }

        if (current > total - 1) {
          current -= total;
        }

        if (current < 0 && swiper.params.paginationType !== 'bullets') {
          current = total + current;
        }
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      } // Types


      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        var bullets = swiper.pagination.bullets;
        var firstIndex;
        var lastIndex;
        var midIndex;

        if (params.dynamicBullets) {
          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
          $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
            swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

            if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (swiper.pagination.dynamicBulletIndex < 0) {
              swiper.pagination.dynamicBulletIndex = 0;
            }
          }

          firstIndex = current - swiper.pagination.dynamicBulletIndex;
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }

        bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

        if ($el.length > 1) {
          bullets.each(function (index, bullet) {
            var $bullet = $(bullet);
            var bulletIndex = $bullet.index();

            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }

            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(params.bulletActiveClass + "-main");
              }

              if (bulletIndex === firstIndex) {
                $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              }

              if (bulletIndex === lastIndex) {
                $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            }
          });
        } else {
          var $bullet = bullets.eq(current);
          $bullet.addClass(params.bulletActiveClass);

          if (params.dynamicBullets) {
            var $firstDisplayedBullet = bullets.eq(firstIndex);
            var $lastDisplayedBullet = bullets.eq(lastIndex);

            for (var i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(params.bulletActiveClass + "-main");
            }

            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
          }
        }

        if (params.dynamicBullets) {
          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
          var offsetProp = rtl ? 'right' : 'left';
          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
        }
      }

      if (params.type === 'fraction') {
        $el.find("." + params.currentClass).text(params.formatFractionCurrent(current + 1));
        $el.find("." + params.totalClass).text(params.formatFractionTotal(total));
      }

      if (params.type === 'progressbar') {
        var progressbarDirection;

        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }

        var scale = (current + 1) / total;
        var scaleX = 1;
        var scaleY = 1;

        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }

        $el.find("." + params.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
      }

      if (params.type === 'custom' && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        swiper.emit('paginationRender', swiper, $el[0]);
      } else {
        swiper.emit('paginationUpdate', swiper, $el[0]);
      }

      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    },
    render: function render() {
      // Render Container
      var swiper = this;
      var params = swiper.params.pagination;

      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
        return;
      }

      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      var $el = swiper.pagination.$el;
      var paginationHTML = '';

      if (params.type === 'bullets') {
        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        for (var i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
          }
        }

        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find("." + params.bulletClass);
      }

      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + "<span class=\"" + params.totalClass + "\"></span>";
        }

        $el.html(paginationHTML);
      }

      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
        }

        $el.html(paginationHTML);
      }

      if (params.type !== 'custom') {
        swiper.emit('paginationRender', swiper.pagination.$el[0]);
      }
    },
    init: function init() {
      var swiper = this;
      var params = swiper.params.pagination;

      if (!params.el) {
        return;
      }

      var $el = $(params.el);

      if ($el.length === 0) {
        return;
      }

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
        $el = swiper.$el.find(params.el);
      }

      if (params.type === 'bullets' && params.clickable) {
        $el.addClass(params.clickableClass);
      }

      $el.addClass(params.modifierClass + params.type);

      if (params.type === 'bullets' && params.dynamicBullets) {
        $el.addClass("" + params.modifierClass + params.type + "-dynamic");
        swiper.pagination.dynamicBulletIndex = 0;

        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }

      if (params.type === 'progressbar' && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }

      if (params.clickable) {
        $el.on('click', "." + params.bulletClass, function onClick(e) {
          e.preventDefault();
          var index = $(this).index() * swiper.params.slidesPerGroup;

          if (swiper.params.loop) {
            index += swiper.loopedSlides;
          }

          swiper.slideTo(index);
        });
      }

      Utils.extend(swiper.pagination, {
        $el: $el,
        el: $el[0]
      });
    },
    destroy: function destroy() {
      var swiper = this;
      var params = swiper.params.pagination;

      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
        return;
      }

      var $el = swiper.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);

      if (swiper.pagination.bullets) {
        swiper.pagination.bullets.removeClass(params.bulletActiveClass);
      }

      if (params.clickable) {
        $el.off('click', "." + params.bulletClass);
      }
    }
  };
  var Pagination$1 = {
    name: 'pagination',
    params: {
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets',
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: function (number) {
          return number;
        },
        formatFractionTotal: function (number) {
          return number;
        },
        bulletClass: 'swiper-pagination-bullet',
        bulletActiveClass: 'swiper-pagination-bullet-active',
        modifierClass: 'swiper-pagination-',
        // NEW
        currentClass: 'swiper-pagination-current',
        totalClass: 'swiper-pagination-total',
        hiddenClass: 'swiper-pagination-hidden',
        progressbarFillClass: 'swiper-pagination-progressbar-fill',
        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
        clickableClass: 'swiper-pagination-clickable',
        // NEW
        lockClass: 'swiper-pagination-lock'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        pagination: {
          init: Pagination.init.bind(swiper),
          render: Pagination.render.bind(swiper),
          update: Pagination.update.bind(swiper),
          destroy: Pagination.destroy.bind(swiper),
          dynamicBulletIndex: 0
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.pagination.init();
        swiper.pagination.render();
        swiper.pagination.update();
      },
      activeIndexChange: function activeIndexChange() {
        var swiper = this;

        if (swiper.params.loop) {
          swiper.pagination.update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          swiper.pagination.update();
        }
      },
      snapIndexChange: function snapIndexChange() {
        var swiper = this;

        if (!swiper.params.loop) {
          swiper.pagination.update();
        }
      },
      slidesLengthChange: function slidesLengthChange() {
        var swiper = this;

        if (swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      snapGridLengthChange: function snapGridLengthChange() {
        var swiper = this;

        if (!swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.pagination.destroy();
      },
      click: function click(e) {
        var swiper = this;

        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(e.target).hasClass(swiper.params.pagination.bulletClass)) {
          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      }
    }
  };
  var Scrollbar = {
    setTranslate: function setTranslate() {
      var swiper = this;

      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var rtl = swiper.rtlTranslate;
      var progress = swiper.progress;
      var dragSize = scrollbar.dragSize;
      var trackSize = scrollbar.trackSize;
      var $dragEl = scrollbar.$dragEl;
      var $el = scrollbar.$el;
      var params = swiper.params.scrollbar;
      var newSize = dragSize;
      var newPos = (trackSize - dragSize) * progress;

      if (rtl) {
        newPos = -newPos;

        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }

      if (swiper.isHorizontal()) {
        if (Support.transforms3d) {
          $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
        } else {
          $dragEl.transform("translateX(" + newPos + "px)");
        }

        $dragEl[0].style.width = newSize + "px";
      } else {
        if (Support.transforms3d) {
          $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
        } else {
          $dragEl.transform("translateY(" + newPos + "px)");
        }

        $dragEl[0].style.height = newSize + "px";
      }

      if (params.hide) {
        clearTimeout(swiper.scrollbar.timeout);
        $el[0].style.opacity = 1;
        swiper.scrollbar.timeout = setTimeout(function () {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1000);
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;

      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
        return;
      }

      swiper.scrollbar.$dragEl.transition(duration);
    },
    updateSize: function updateSize() {
      var swiper = this;

      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var $dragEl = scrollbar.$dragEl;
      var $el = scrollbar.$el;
      $dragEl[0].style.width = '';
      $dragEl[0].style.height = '';
      var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
      var divider = swiper.size / swiper.virtualSize;
      var moveDivider = divider * (trackSize / swiper.size);
      var dragSize;

      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }

      if (swiper.isHorizontal()) {
        $dragEl[0].style.width = dragSize + "px";
      } else {
        $dragEl[0].style.height = dragSize + "px";
      }

      if (divider >= 1) {
        $el[0].style.display = 'none';
      } else {
        $el[0].style.display = '';
      }

      if (swiper.params.scrollbarHide) {
        $el[0].style.opacity = 0;
      }

      Utils.extend(scrollbar, {
        trackSize: trackSize,
        divider: divider,
        moveDivider: moveDivider,
        dragSize: dragSize
      });
      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    },
    setDragPosition: function setDragPosition(e) {
      var swiper = this;
      var scrollbar = swiper.scrollbar;
      var rtl = swiper.rtlTranslate;
      var $el = scrollbar.$el;
      var dragSize = scrollbar.dragSize;
      var trackSize = scrollbar.trackSize;
      var pointerPosition;

      if (swiper.isHorizontal()) {
        pointerPosition = e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX || e.clientX;
      } else {
        pointerPosition = e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY || e.clientY;
      }

      var positionRatio;
      positionRatio = (pointerPosition - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - dragSize / 2) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);

      if (rtl) {
        positionRatio = 1 - positionRatio;
      }

      var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    },
    onDragStart: function onDragStart(e) {
      var swiper = this;
      var params = swiper.params.scrollbar;
      var scrollbar = swiper.scrollbar;
      var $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el;
      var $dragEl = scrollbar.$dragEl;
      swiper.scrollbar.isTouched = true;
      e.preventDefault();
      e.stopPropagation();
      $wrapperEl.transition(100);
      $dragEl.transition(100);
      scrollbar.setDragPosition(e);
      clearTimeout(swiper.scrollbar.dragTimeout);
      $el.transition(0);

      if (params.hide) {
        $el.css('opacity', 1);
      }

      swiper.emit('scrollbarDragStart', e);
    },
    onDragMove: function onDragMove(e) {
      var swiper = this;
      var scrollbar = swiper.scrollbar;
      var $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el;
      var $dragEl = scrollbar.$dragEl;

      if (!swiper.scrollbar.isTouched) {
        return;
      }

      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }

      scrollbar.setDragPosition(e);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      swiper.emit('scrollbarDragMove', e);
    },
    onDragEnd: function onDragEnd(e) {
      var swiper = this;
      var params = swiper.params.scrollbar;
      var scrollbar = swiper.scrollbar;
      var $el = scrollbar.$el;

      if (!swiper.scrollbar.isTouched) {
        return;
      }

      swiper.scrollbar.isTouched = false;

      if (params.hide) {
        clearTimeout(swiper.scrollbar.dragTimeout);
        swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
          $el.css('opacity', 0);
          $el.transition(400);
        }, 1000);
      }

      swiper.emit('scrollbarDragEnd', e);

      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    },
    enableDraggable: function enableDraggable() {
      var swiper = this;

      if (!swiper.params.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var touchEventsTouch = swiper.touchEventsTouch;
      var touchEventsDesktop = swiper.touchEventsDesktop;
      var params = swiper.params;
      var $el = scrollbar.$el;
      var target = $el[0];
      var activeListener = Support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      var passiveListener = Support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (!Support.touch) {
        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    disableDraggable: function disableDraggable() {
      var swiper = this;

      if (!swiper.params.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var touchEventsTouch = swiper.touchEventsTouch;
      var touchEventsDesktop = swiper.touchEventsDesktop;
      var params = swiper.params;
      var $el = scrollbar.$el;
      var target = $el[0];
      var activeListener = Support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      var passiveListener = Support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (!Support.touch) {
        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    init: function init() {
      var swiper = this;

      if (!swiper.params.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var $swiperEl = swiper.$el;
      var params = swiper.params.scrollbar;
      var $el = $(params.el);

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }

      var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);

      if ($dragEl.length === 0) {
        $dragEl = $("<div class=\"" + swiper.params.scrollbar.dragClass + "\"></div>");
        $el.append($dragEl);
      }

      Utils.extend(scrollbar, {
        $el: $el,
        el: $el[0],
        $dragEl: $dragEl,
        dragEl: $dragEl[0]
      });

      if (params.draggable) {
        scrollbar.enableDraggable();
      }
    },
    destroy: function destroy() {
      var swiper = this;
      swiper.scrollbar.disableDraggable();
    }
  };
  var Scrollbar$1 = {
    name: 'scrollbar',
    params: {
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        scrollbar: {
          init: Scrollbar.init.bind(swiper),
          destroy: Scrollbar.destroy.bind(swiper),
          updateSize: Scrollbar.updateSize.bind(swiper),
          setTranslate: Scrollbar.setTranslate.bind(swiper),
          setTransition: Scrollbar.setTransition.bind(swiper),
          enableDraggable: Scrollbar.enableDraggable.bind(swiper),
          disableDraggable: Scrollbar.disableDraggable.bind(swiper),
          setDragPosition: Scrollbar.setDragPosition.bind(swiper),
          onDragStart: Scrollbar.onDragStart.bind(swiper),
          onDragMove: Scrollbar.onDragMove.bind(swiper),
          onDragEnd: Scrollbar.onDragEnd.bind(swiper),
          isTouched: false,
          timeout: null,
          dragTimeout: null
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.scrollbar.init();
        swiper.scrollbar.updateSize();
        swiper.scrollbar.setTranslate();
      },
      update: function update() {
        var swiper = this;
        swiper.scrollbar.updateSize();
      },
      resize: function resize() {
        var swiper = this;
        swiper.scrollbar.updateSize();
      },
      observerUpdate: function observerUpdate() {
        var swiper = this;
        swiper.scrollbar.updateSize();
      },
      setTranslate: function setTranslate() {
        var swiper = this;
        swiper.scrollbar.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;
        swiper.scrollbar.setTransition(duration);
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.scrollbar.destroy();
      }
    }
  };
  var Parallax = {
    setTransform: function setTransform(el, progress) {
      var swiper = this;
      var rtl = swiper.rtl;
      var $el = $(el);
      var rtlFactor = rtl ? -1 : 1;
      var p = $el.attr('data-swiper-parallax') || '0';
      var x = $el.attr('data-swiper-parallax-x');
      var y = $el.attr('data-swiper-parallax-y');
      var scale = $el.attr('data-swiper-parallax-scale');
      var opacity = $el.attr('data-swiper-parallax-opacity');

      if (x || y) {
        x = x || '0';
        y = y || '0';
      } else if (swiper.isHorizontal()) {
        x = p;
        y = '0';
      } else {
        y = p;
        x = '0';
      }

      if (x.indexOf('%') >= 0) {
        x = parseInt(x, 10) * progress * rtlFactor + "%";
      } else {
        x = x * progress * rtlFactor + "px";
      }

      if (y.indexOf('%') >= 0) {
        y = parseInt(y, 10) * progress + "%";
      } else {
        y = y * progress + "px";
      }

      if (typeof opacity !== 'undefined' && opacity !== null) {
        var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
        $el[0].style.opacity = currentOpacity;
      }

      if (typeof scale === 'undefined' || scale === null) {
        $el.transform("translate3d(" + x + ", " + y + ", 0px)");
      } else {
        var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
        $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
      }
    },
    setTranslate: function setTranslate() {
      var swiper = this;
      var $el = swiper.$el;
      var slides = swiper.slides;
      var progress = swiper.progress;
      var snapGrid = swiper.snapGrid;
      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function (index, el) {
        swiper.parallax.setTransform(el, progress);
      });
      slides.each(function (slideIndex, slideEl) {
        var slideProgress = slideEl.progress;

        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
        }

        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function (index, el) {
          swiper.parallax.setTransform(el, slideProgress);
        });
      });
    },
    setTransition: function setTransition(duration) {
      if (duration === void 0) duration = this.params.speed;
      var swiper = this;
      var $el = swiper.$el;
      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function (index, parallaxEl) {
        var $parallaxEl = $(parallaxEl);
        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;

        if (duration === 0) {
          parallaxDuration = 0;
        }

        $parallaxEl.transition(parallaxDuration);
      });
    }
  };
  var Parallax$1 = {
    name: 'parallax',
    params: {
      parallax: {
        enabled: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        parallax: {
          setTransform: Parallax.setTransform.bind(swiper),
          setTranslate: Parallax.setTranslate.bind(swiper),
          setTransition: Parallax.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (!swiper.params.parallax.enabled) {
          return;
        }

        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      init: function init() {
        var swiper = this;

        if (!swiper.params.parallax) {
          return;
        }

        swiper.parallax.setTranslate();
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (!swiper.params.parallax) {
          return;
        }

        swiper.parallax.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (!swiper.params.parallax) {
          return;
        }

        swiper.parallax.setTransition(duration);
      }
    }
  };
  var Zoom = {
    // Calc Scale From Multi-touches
    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
      if (e.targetTouches.length < 2) {
        return 1;
      }

      var x1 = e.targetTouches[0].pageX;
      var y1 = e.targetTouches[0].pageY;
      var x2 = e.targetTouches[1].pageX;
      var y2 = e.targetTouches[1].pageY;
      var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      return distance;
    },
    // Events
    onGestureStart: function onGestureStart(e) {
      var swiper = this;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;

      if (!Support.gestures) {
        if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
          return;
        }

        zoom.fakeGestureTouched = true;
        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
      }

      if (!gesture.$slideEl || !gesture.$slideEl.length) {
        gesture.$slideEl = $(e.target).closest('.swiper-slide');

        if (gesture.$slideEl.length === 0) {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

        if (gesture.$imageWrapEl.length === 0) {
          gesture.$imageEl = undefined;
          return;
        }
      }

      gesture.$imageEl.transition(0);
      swiper.zoom.isScaling = true;
    },
    onGestureChange: function onGestureChange(e) {
      var swiper = this;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (!Support.gestures) {
        if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
          return;
        }

        zoom.fakeGestureMoved = true;
        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      if (Support.gestures) {
        zoom.scale = e.scale * zoom.currentScale;
      } else {
        zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
      }

      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
      }

      if (zoom.scale < params.minRatio) {
        zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
      }

      gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    onGestureEnd: function onGestureEnd(e) {
      var swiper = this;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (!Support.gestures) {
        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
          return;
        }

        if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android) {
          return;
        }

        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
      zoom.currentScale = zoom.scale;
      zoom.isScaling = false;

      if (zoom.scale === 1) {
        gesture.$slideEl = undefined;
      }
    },
    onTouchStart: function onTouchStart(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      if (image.isTouched) {
        return;
      }

      if (Device.android) {
        e.preventDefault();
      }

      image.isTouched = true;
      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    },
    onTouchMove: function onTouchMove(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;
      var velocity = zoom.velocity;

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      swiper.allowClick = false;

      if (!image.isTouched || !gesture.$slideEl) {
        return;
      }

      if (!image.isMoved) {
        image.width = gesture.$imageEl[0].offsetWidth;
        image.height = gesture.$imageEl[0].offsetHeight;
        image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
        image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
        gesture.$imageWrapEl.transition(0);

        if (swiper.rtl) {
          image.startX = -image.startX;
          image.startY = -image.startY;
        }
      } // Define if we need image drag


      var scaledWidth = image.width * zoom.scale;
      var scaledHeight = image.height * zoom.scale;

      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {
        return;
      }

      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (!image.isMoved && !zoom.isScaling) {
        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
          image.isTouched = false;
          return;
        }

        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
          image.isTouched = false;
          return;
        }
      }

      e.preventDefault();
      e.stopPropagation();
      image.isMoved = true;
      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

      if (image.currentX < image.minX) {
        image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
      }

      if (image.currentX > image.maxX) {
        image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
      }

      if (image.currentY < image.minY) {
        image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
      }

      if (image.currentY > image.maxY) {
        image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
      } // Velocity


      if (!velocity.prevPositionX) {
        velocity.prevPositionX = image.touchesCurrent.x;
      }

      if (!velocity.prevPositionY) {
        velocity.prevPositionY = image.touchesCurrent.y;
      }

      if (!velocity.prevTime) {
        velocity.prevTime = Date.now();
      }

      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;

      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) {
        velocity.x = 0;
      }

      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) {
        velocity.y = 0;
      }

      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();
      gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTouchEnd: function onTouchEnd() {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;
      var velocity = zoom.velocity;

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }

      image.isTouched = false;
      image.isMoved = false;
      var momentumDurationX = 300;
      var momentumDurationY = 300;
      var momentumDistanceX = velocity.x * momentumDurationX;
      var newPositionX = image.currentX + momentumDistanceX;
      var momentumDistanceY = velocity.y * momentumDurationY;
      var newPositionY = image.currentY + momentumDistanceY; // Fix duration

      if (velocity.x !== 0) {
        momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      }

      if (velocity.y !== 0) {
        momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      }

      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
      image.currentX = newPositionX;
      image.currentY = newPositionY; // Define if we need image drag

      var scaledWidth = image.width * zoom.scale;
      var scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
      gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTransitionEnd: function onTransitionEnd() {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
        zoom.scale = 1;
        zoom.currentScale = 1;
        gesture.$slideEl = undefined;
        gesture.$imageEl = undefined;
        gesture.$imageWrapEl = undefined;
      }
    },
    // Toggle Zoom
    toggle: function toggle(e) {
      var swiper = this;
      var zoom = swiper.zoom;

      if (zoom.scale && zoom.scale !== 1) {
        // Zoom Out
        zoom.out();
      } else {
        // Zoom In
        zoom.in(e);
      }
    },
    in: function in$1(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var params = swiper.params.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;

      if (!gesture.$slideEl) {
        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      gesture.$slideEl.addClass("" + params.zoomedSlideClass);
      var touchX;
      var touchY;
      var offsetX;
      var offsetY;
      var diffX;
      var diffY;
      var translateX;
      var translateY;
      var imageWidth;
      var imageHeight;
      var scaledWidth;
      var scaledHeight;
      var translateMinX;
      var translateMinY;
      var translateMaxX;
      var translateMaxY;
      var slideWidth;
      var slideHeight;

      if (typeof image.touchesStart.x === 'undefined' && e) {
        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }

      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (e) {
        slideWidth = gesture.$slideEl[0].offsetWidth;
        slideHeight = gesture.$slideEl[0].offsetHeight;
        offsetX = gesture.$slideEl.offset().left;
        offsetY = gesture.$slideEl.offset().top;
        diffX = offsetX + slideWidth / 2 - touchX;
        diffY = offsetY + slideHeight / 2 - touchY;
        imageWidth = gesture.$imageEl[0].offsetWidth;
        imageHeight = gesture.$imageEl[0].offsetHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;
        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;
        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;

        if (translateX < translateMinX) {
          translateX = translateMinX;
        }

        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }

        if (translateY < translateMinY) {
          translateY = translateMinY;
        }

        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }

      gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
      gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    out: function out() {
      var swiper = this;
      var zoom = swiper.zoom;
      var params = swiper.params.zoom;
      var gesture = zoom.gesture;

      if (!gesture.$slideEl) {
        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      zoom.scale = 1;
      zoom.currentScale = 1;
      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
      gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
      gesture.$slideEl = undefined;
    },
    // Attach/Detach Events
    enable: function enable() {
      var swiper = this;
      var zoom = swiper.zoom;

      if (zoom.enabled) {
        return;
      }

      zoom.enabled = true;
      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false; // Scale image

      if (Support.gestures) {
        swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
      } // Move image


      swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove);
    },
    disable: function disable() {
      var swiper = this;
      var zoom = swiper.zoom;

      if (!zoom.enabled) {
        return;
      }

      swiper.zoom.enabled = false;
      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false; // Scale image

      if (Support.gestures) {
        swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
      } // Move image


      swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove);
    }
  };
  var Zoom$1 = {
    name: 'zoom',
    params: {
      zoom: {
        enabled: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: 'swiper-zoom-container',
        zoomedSlideClass: 'swiper-slide-zoomed'
      }
    },
    create: function create() {
      var swiper = this;
      var zoom = {
        enabled: false,
        scale: 1,
        currentScale: 1,
        isScaling: false,
        gesture: {
          $slideEl: undefined,
          slideWidth: undefined,
          slideHeight: undefined,
          $imageEl: undefined,
          $imageWrapEl: undefined,
          maxRatio: 3
        },
        image: {
          isTouched: undefined,
          isMoved: undefined,
          currentX: undefined,
          currentY: undefined,
          minX: undefined,
          minY: undefined,
          maxX: undefined,
          maxY: undefined,
          width: undefined,
          height: undefined,
          startX: undefined,
          startY: undefined,
          touchesStart: {},
          touchesCurrent: {}
        },
        velocity: {
          x: undefined,
          y: undefined,
          prevPositionX: undefined,
          prevPositionY: undefined,
          prevTime: undefined
        }
      };
      'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(function (methodName) {
        zoom[methodName] = Zoom[methodName].bind(swiper);
      });
      Utils.extend(swiper, {
        zoom: zoom
      });
      var scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get: function get() {
          return scale;
        },
        set: function set(value) {
          if (scale !== value) {
            var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
            var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
            swiper.emit('zoomChange', value, imageEl, slideEl);
          }

          scale = value;
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.zoom.enabled) {
          swiper.zoom.enable();
        }
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.zoom.disable();
      },
      touchStart: function touchStart(e) {
        var swiper = this;

        if (!swiper.zoom.enabled) {
          return;
        }

        swiper.zoom.onTouchStart(e);
      },
      touchEnd: function touchEnd(e) {
        var swiper = this;

        if (!swiper.zoom.enabled) {
          return;
        }

        swiper.zoom.onTouchEnd(e);
      },
      doubleTap: function doubleTap(e) {
        var swiper = this;

        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
          swiper.zoom.toggle(e);
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          swiper.zoom.onTransitionEnd();
        }
      }
    }
  };
  var Lazy = {
    loadInSlide: function loadInSlide(index, loadInDuplicate) {
      if (loadInDuplicate === void 0) loadInDuplicate = true;
      var swiper = this;
      var params = swiper.params.lazy;

      if (typeof index === 'undefined') {
        return;
      }

      if (swiper.slides.length === 0) {
        return;
      }

      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + index + "\"]") : swiper.slides.eq(index);
      var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");

      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images = $images.add($slideEl[0]);
      }

      if ($images.length === 0) {
        return;
      }

      $images.each(function (imageIndex, imageEl) {
        var $imageEl = $(imageEl);
        $imageEl.addClass(params.loadingClass);
        var background = $imageEl.attr('data-background');
        var src = $imageEl.attr('data-src');
        var srcset = $imageEl.attr('data-srcset');
        var sizes = $imageEl.attr('data-sizes');
        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
          if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) {
            return;
          }

          if (background) {
            $imageEl.css('background-image', "url(\"" + background + "\")");
            $imageEl.removeAttr('data-background');
          } else {
            if (srcset) {
              $imageEl.attr('srcset', srcset);
              $imageEl.removeAttr('data-srcset');
            }

            if (sizes) {
              $imageEl.attr('sizes', sizes);
              $imageEl.removeAttr('data-sizes');
            }

            if (src) {
              $imageEl.attr('src', src);
              $imageEl.removeAttr('data-src');
            }
          }

          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find("." + params.preloaderClass).remove();

          if (swiper.params.loop && loadInDuplicate) {
            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
              var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + swiper.params.slideDuplicateClass + ")");
              swiper.lazy.loadInSlide(originalSlide.index(), false);
            } else {
              var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]");
              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
            }
          }

          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
        });
        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
      });
    },
    load: function load() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl;
      var swiperParams = swiper.params;
      var slides = swiper.slides;
      var activeIndex = swiper.activeIndex;
      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
      var params = swiperParams.lazy;
      var slidesPerView = swiperParams.slidesPerView;

      if (slidesPerView === 'auto') {
        slidesPerView = 0;
      }

      function slideExist(index) {
        if (isVirtual) {
          if ($wrapperEl.children("." + swiperParams.slideClass + "[data-swiper-slide-index=\"" + index + "\"]").length) {
            return true;
          }
        } else if (slides[index]) {
          return true;
        }

        return false;
      }

      function slideIndex(slideEl) {
        if (isVirtual) {
          return $(slideEl).attr('data-swiper-slide-index');
        }

        return $(slideEl).index();
      }

      if (!swiper.lazy.initialImageLoaded) {
        swiper.lazy.initialImageLoaded = true;
      }

      if (swiper.params.watchSlidesVisibility) {
        $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (elIndex, slideEl) {
          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
          swiper.lazy.loadInSlide(index);
        });
      } else if (slidesPerView > 1) {
        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
          if (slideExist(i)) {
            swiper.lazy.loadInSlide(i);
          }
        }
      } else {
        swiper.lazy.loadInSlide(activeIndex);
      }

      if (params.loadPrevNext) {
        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
          var amount = params.loadPrevNextAmount;
          var spv = slidesPerView;
          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

          for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
            if (slideExist(i$1)) {
              swiper.lazy.loadInSlide(i$1);
            }
          } // Prev Slides


          for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
            if (slideExist(i$2)) {
              swiper.lazy.loadInSlide(i$2);
            }
          }
        } else {
          var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);

          if (nextSlide.length > 0) {
            swiper.lazy.loadInSlide(slideIndex(nextSlide));
          }

          var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);

          if (prevSlide.length > 0) {
            swiper.lazy.loadInSlide(slideIndex(prevSlide));
          }
        }
      }
    }
  };
  var Lazy$1 = {
    name: 'lazy',
    params: {
      lazy: {
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,
        elementClass: 'swiper-lazy',
        loadingClass: 'swiper-lazy-loading',
        loadedClass: 'swiper-lazy-loaded',
        preloaderClass: 'swiper-lazy-preloader'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        lazy: {
          initialImageLoaded: false,
          load: Lazy.load.bind(swiper),
          loadInSlide: Lazy.loadInSlide.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      },
      init: function init() {
        var swiper = this;

        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
          swiper.lazy.load();
        }
      },
      scroll: function scroll() {
        var swiper = this;

        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
          swiper.lazy.load();
        }
      },
      resize: function resize() {
        var swiper = this;

        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      scrollbarDragMove: function scrollbarDragMove() {
        var swiper = this;

        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      transitionStart: function transitionStart() {
        var swiper = this;

        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
            swiper.lazy.load();
          }
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          swiper.lazy.load();
        }
      }
    }
  };
  /* eslint no-bitwise: ["error", { "allow": [">>"] }] */

  var Controller = {
    LinearSpline: function LinearSpline(x, y) {
      var binarySearch = function search() {
        var maxIndex;
        var minIndex;
        var guess;
        return function (array, val) {
          minIndex = -1;
          maxIndex = array.length;

          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;

            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }

          return maxIndex;
        };
      }();

      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
      // (x1,y1) is the known point before given value,
      // (x3,y3) is the known point after given value.

      var i1;
      var i3;

      this.interpolate = function interpolate(x2) {
        if (!x2) {
          return 0;
        } // Get the indexes of x1 and x3 (the array indexes before and after given x2):


        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
      };

      return this;
    },
    // xxx: for now i will just save one spline function to to
    getInterpolateFunction: function getInterpolateFunction(c) {
      var swiper = this;

      if (!swiper.controller.spline) {
        swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
      }
    },
    setTranslate: function setTranslate(setTranslate$1, byController) {
      var swiper = this;
      var controlled = swiper.controller.control;
      var multiplier;
      var controlledTranslate;

      function setControlledTranslate(c) {
        // this will create an Interpolate function based on the snapGrids
        // x is the Grid of the scrolled scroller and y will be the controlled scroller
        // it makes sense to create this only once and recall it for the interpolation
        // the function does a lot of value caching for performance
        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

        if (swiper.params.controller.by === 'slide') {
          swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
          // but it did not work out

          controlledTranslate = -swiper.controller.spline.interpolate(-translate);
        }

        if (!controlledTranslate || swiper.params.controller.by === 'container') {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
        }

        if (swiper.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }

        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }

      if (Array.isArray(controlled)) {
        for (var i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    },
    setTransition: function setTransition(duration, byController) {
      var swiper = this;
      var controlled = swiper.controller.control;
      var i;

      function setControlledTransition(c) {
        c.setTransition(duration, swiper);

        if (duration !== 0) {
          c.transitionStart();

          if (c.params.autoHeight) {
            Utils.nextTick(function () {
              c.updateAutoHeight();
            });
          }

          c.$wrapperEl.transitionEnd(function () {
            if (!controlled) {
              return;
            }

            if (c.params.loop && swiper.params.controller.by === 'slide') {
              c.loopFix();
            }

            c.transitionEnd();
          });
        }
      }

      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTransition(controlled);
      }
    }
  };
  var Controller$1 = {
    name: 'controller',
    params: {
      controller: {
        control: undefined,
        inverse: false,
        by: 'slide' // or 'container'

      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        controller: {
          control: swiper.params.controller.control,
          getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
          setTranslate: Controller.setTranslate.bind(swiper),
          setTransition: Controller.setTransition.bind(swiper)
        }
      });
    },
    on: {
      update: function update() {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      resize: function resize() {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      observerUpdate: function observerUpdate() {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      setTranslate: function setTranslate(translate, byController) {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        swiper.controller.setTranslate(translate, byController);
      },
      setTransition: function setTransition(duration, byController) {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        swiper.controller.setTransition(duration, byController);
      }
    }
  };
  var a11y = {
    makeElFocusable: function makeElFocusable($el) {
      $el.attr('tabIndex', '0');
      return $el;
    },
    addElRole: function addElRole($el, role) {
      $el.attr('role', role);
      return $el;
    },
    addElLabel: function addElLabel($el, label) {
      $el.attr('aria-label', label);
      return $el;
    },
    disableEl: function disableEl($el) {
      $el.attr('aria-disabled', true);
      return $el;
    },
    enableEl: function enableEl($el) {
      $el.attr('aria-disabled', false);
      return $el;
    },
    onEnterKey: function onEnterKey(e) {
      var swiper = this;
      var params = swiper.params.a11y;

      if (e.keyCode !== 13) {
        return;
      }

      var $targetEl = $(e.target);

      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }

        if (swiper.isEnd) {
          swiper.a11y.notify(params.lastSlideMessage);
        } else {
          swiper.a11y.notify(params.nextSlideMessage);
        }
      }

      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }

        if (swiper.isBeginning) {
          swiper.a11y.notify(params.firstSlideMessage);
        } else {
          swiper.a11y.notify(params.prevSlideMessage);
        }
      }

      if (swiper.pagination && $targetEl.is("." + swiper.params.pagination.bulletClass)) {
        $targetEl[0].click();
      }
    },
    notify: function notify(message) {
      var swiper = this;
      var notification = swiper.a11y.liveRegion;

      if (notification.length === 0) {
        return;
      }

      notification.html('');
      notification.html(message);
    },
    updateNavigation: function updateNavigation() {
      var swiper = this;

      if (swiper.params.loop) {
        return;
      }

      var ref = swiper.navigation;
      var $nextEl = ref.$nextEl;
      var $prevEl = ref.$prevEl;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          swiper.a11y.disableEl($prevEl);
        } else {
          swiper.a11y.enableEl($prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          swiper.a11y.disableEl($nextEl);
        } else {
          swiper.a11y.enableEl($nextEl);
        }
      }
    },
    updatePagination: function updatePagination() {
      var swiper = this;
      var params = swiper.params.a11y;

      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
          var $bulletEl = $(bulletEl);
          swiper.a11y.makeElFocusable($bulletEl);
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
        });
      }
    },
    init: function init() {
      var swiper = this;
      swiper.$el.append(swiper.a11y.liveRegion); // Navigation

      var params = swiper.params.a11y;
      var $nextEl;
      var $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        swiper.a11y.makeElFocusable($nextEl);
        swiper.a11y.addElRole($nextEl, 'button');
        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
        $nextEl.on('keydown', swiper.a11y.onEnterKey);
      }

      if ($prevEl) {
        swiper.a11y.makeElFocusable($prevEl);
        swiper.a11y.addElRole($prevEl, 'button');
        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
        $prevEl.on('keydown', swiper.a11y.onEnterKey);
      } // Pagination


      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.on('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
      }
    },
    destroy: function destroy() {
      var swiper = this;

      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) {
        swiper.a11y.liveRegion.remove();
      }

      var $nextEl;
      var $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        $nextEl.off('keydown', swiper.a11y.onEnterKey);
      }

      if ($prevEl) {
        $prevEl.off('keydown', swiper.a11y.onEnterKey);
      } // Pagination


      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.off('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
      }
    }
  };
  var A11y = {
    name: 'a11y',
    params: {
      a11y: {
        enabled: true,
        notificationClass: 'swiper-notification',
        prevSlideMessage: 'Previous slide',
        nextSlideMessage: 'Next slide',
        firstSlideMessage: 'This is the first slide',
        lastSlideMessage: 'This is the last slide',
        paginationBulletMessage: 'Go to slide {{index}}'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        a11y: {
          liveRegion: $("<span class=\"" + swiper.params.a11y.notificationClass + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")
        }
      });
      Object.keys(a11y).forEach(function (methodName) {
        swiper.a11y[methodName] = a11y[methodName].bind(swiper);
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.init();
        swiper.a11y.updateNavigation();
      },
      toEdge: function toEdge() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.updateNavigation();
      },
      fromEdge: function fromEdge() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.updateNavigation();
      },
      paginationUpdate: function paginationUpdate() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.updatePagination();
      },
      destroy: function destroy() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.destroy();
      }
    }
  };
  var History = {
    init: function init() {
      var swiper = this;

      if (!swiper.params.history) {
        return;
      }

      if (!win.history || !win.history.pushState) {
        swiper.params.history.enabled = false;
        swiper.params.hashNavigation.enabled = true;
        return;
      }

      var history = swiper.history;
      history.initialized = true;
      history.paths = History.getPathValues();

      if (!history.paths.key && !history.paths.value) {
        return;
      }

      history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);

      if (!swiper.params.history.replaceState) {
        win.addEventListener('popstate', swiper.history.setHistoryPopState);
      }
    },
    destroy: function destroy() {
      var swiper = this;

      if (!swiper.params.history.replaceState) {
        win.removeEventListener('popstate', swiper.history.setHistoryPopState);
      }
    },
    setHistoryPopState: function setHistoryPopState() {
      var swiper = this;
      swiper.history.paths = History.getPathValues();
      swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
    },
    getPathValues: function getPathValues() {
      var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) {
        return part !== '';
      });
      var total = pathArray.length;
      var key = pathArray[total - 2];
      var value = pathArray[total - 1];
      return {
        key: key,
        value: value
      };
    },
    setHistory: function setHistory(key, index) {
      var swiper = this;

      if (!swiper.history.initialized || !swiper.params.history.enabled) {
        return;
      }

      var slide = swiper.slides.eq(index);
      var value = History.slugify(slide.attr('data-history'));

      if (!win.location.pathname.includes(key)) {
        value = key + "/" + value;
      }

      var currentState = win.history.state;

      if (currentState && currentState.value === value) {
        return;
      }

      if (swiper.params.history.replaceState) {
        win.history.replaceState({
          value: value
        }, null, value);
      } else {
        win.history.pushState({
          value: value
        }, null, value);
      }
    },
    slugify: function slugify(text) {
      return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    },
    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
      var swiper = this;

      if (value) {
        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
          var slide = swiper.slides.eq(i);
          var slideHistory = History.slugify(slide.attr('data-history'));

          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            var index = slide.index();
            swiper.slideTo(index, speed, runCallbacks);
          }
        }
      } else {
        swiper.slideTo(0, speed, runCallbacks);
      }
    }
  };
  var History$1 = {
    name: 'history',
    params: {
      history: {
        enabled: false,
        replaceState: false,
        key: 'slides'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        history: {
          init: History.init.bind(swiper),
          setHistory: History.setHistory.bind(swiper),
          setHistoryPopState: History.setHistoryPopState.bind(swiper),
          scrollToSlide: History.scrollToSlide.bind(swiper),
          destroy: History.destroy.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.history.enabled) {
          swiper.history.init();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.params.history.enabled) {
          swiper.history.destroy();
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.history.initialized) {
          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      }
    }
  };
  var HashNavigation = {
    onHashCange: function onHashCange() {
      var swiper = this;
      var newHash = doc.location.hash.replace('#', '');
      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

      if (newHash !== activeSlideHash) {
        var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-hash=\"" + newHash + "\"]").index();

        if (typeof newIndex === 'undefined') {
          return;
        }

        swiper.slideTo(newIndex);
      }
    },
    setHash: function setHash() {
      var swiper = this;

      if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) {
        return;
      }

      if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
        win.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr('data-hash') || '');
      } else {
        var slide = swiper.slides.eq(swiper.activeIndex);
        var hash = slide.attr('data-hash') || slide.attr('data-history');
        doc.location.hash = hash || '';
      }
    },
    init: function init() {
      var swiper = this;

      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) {
        return;
      }

      swiper.hashNavigation.initialized = true;
      var hash = doc.location.hash.replace('#', '');

      if (hash) {
        var speed = 0;

        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
          var slide = swiper.slides.eq(i);
          var slideHash = slide.attr('data-hash') || slide.attr('data-history');

          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            var index = slide.index();
            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
          }
        }
      }

      if (swiper.params.hashNavigation.watchState) {
        $(win).on('hashchange', swiper.hashNavigation.onHashCange);
      }
    },
    destroy: function destroy() {
      var swiper = this;

      if (swiper.params.hashNavigation.watchState) {
        $(win).off('hashchange', swiper.hashNavigation.onHashCange);
      }
    }
  };
  var HashNavigation$1 = {
    name: 'hash-navigation',
    params: {
      hashNavigation: {
        enabled: false,
        replaceState: false,
        watchState: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        hashNavigation: {
          initialized: false,
          init: HashNavigation.init.bind(swiper),
          destroy: HashNavigation.destroy.bind(swiper),
          setHash: HashNavigation.setHash.bind(swiper),
          onHashCange: HashNavigation.onHashCange.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.hashNavigation.enabled) {
          swiper.hashNavigation.init();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.params.hashNavigation.enabled) {
          swiper.hashNavigation.destroy();
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.hashNavigation.initialized) {
          swiper.hashNavigation.setHash();
        }
      }
    }
  };
  /* eslint no-underscore-dangle: "off" */

  var Autoplay = {
    run: function run() {
      var swiper = this;
      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
      var delay = swiper.params.autoplay.delay;

      if ($activeSlideEl.attr('data-swiper-autoplay')) {
        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
      }

      swiper.autoplay.timeout = Utils.nextTick(function () {
        if (swiper.params.autoplay.reverseDirection) {
          if (swiper.params.loop) {
            swiper.loopFix();
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.isBeginning) {
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else {
            swiper.autoplay.stop();
          }
        } else if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isEnd) {
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      }, delay);
    },
    start: function start() {
      var swiper = this;

      if (typeof swiper.autoplay.timeout !== 'undefined') {
        return false;
      }

      if (swiper.autoplay.running) {
        return false;
      }

      swiper.autoplay.running = true;
      swiper.emit('autoplayStart');
      swiper.autoplay.run();
      return true;
    },
    stop: function stop() {
      var swiper = this;

      if (!swiper.autoplay.running) {
        return false;
      }

      if (typeof swiper.autoplay.timeout === 'undefined') {
        return false;
      }

      if (swiper.autoplay.timeout) {
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = undefined;
      }

      swiper.autoplay.running = false;
      swiper.emit('autoplayStop');
      return true;
    },
    pause: function pause(speed) {
      var swiper = this;

      if (!swiper.autoplay.running) {
        return;
      }

      if (swiper.autoplay.paused) {
        return;
      }

      if (swiper.autoplay.timeout) {
        clearTimeout(swiper.autoplay.timeout);
      }

      swiper.autoplay.paused = true;

      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
        swiper.autoplay.paused = false;
        swiper.autoplay.run();
      } else {
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
      }
    }
  };
  var Autoplay$1 = {
    name: 'autoplay',
    params: {
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        autoplay: {
          running: false,
          paused: false,
          run: Autoplay.run.bind(swiper),
          start: Autoplay.start.bind(swiper),
          stop: Autoplay.stop.bind(swiper),
          pause: Autoplay.pause.bind(swiper),
          onTransitionEnd: function onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {
              return;
            }

            if (e.target !== this) {
              return;
            }

            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
            swiper.autoplay.paused = false;

            if (!swiper.autoplay.running) {
              swiper.autoplay.stop();
            } else {
              swiper.autoplay.run();
            }
          }
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.autoplay.enabled) {
          swiper.autoplay.start();
        }
      },
      beforeTransitionStart: function beforeTransitionStart(speed, internal) {
        var swiper = this;

        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            swiper.autoplay.stop();
          }
        }
      },
      sliderFirstMove: function sliderFirstMove() {
        var swiper = this;

        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.pause();
          }
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.autoplay.running) {
          swiper.autoplay.stop();
        }
      }
    }
  };
  var Fade = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = swiper.slides.eq(i);
        var offset = $slideEl[0].swiperSlideOffset;
        var tx = -offset;

        if (!swiper.params.virtualTranslate) {
          tx -= swiper.translate;
        }

        var ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }

        var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        $slideEl.css({
          opacity: slideOpacity
        }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var slides = swiper.slides;
      var $wrapperEl = swiper.$wrapperEl;
      slides.transition(duration);

      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false;
        slides.transitionEnd(function () {
          if (eventTriggered) {
            return;
          }

          if (!swiper || swiper.destroyed) {
            return;
          }

          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
  };
  var EffectFade = {
    name: 'effect-fade',
    params: {
      fadeEffect: {
        crossFade: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        fadeEffect: {
          setTranslate: Fade.setTranslate.bind(swiper),
          setTransition: Fade.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'fade') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "fade");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'fade') {
          return;
        }

        swiper.fadeEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'fade') {
          return;
        }

        swiper.fadeEffect.setTransition(duration);
      }
    }
  };
  var Cube = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var $el = swiper.$el;
      var $wrapperEl = swiper.$wrapperEl;
      var slides = swiper.slides;
      var swiperWidth = swiper.width;
      var swiperHeight = swiper.height;
      var rtl = swiper.rtlTranslate;
      var swiperSize = swiper.size;
      var params = swiper.params.cubeEffect;
      var isHorizontal = swiper.isHorizontal();
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var wrapperRotate = 0;
      var $cubeShadowEl;

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $wrapperEl.append($cubeShadowEl);
          }

          $cubeShadowEl.css({
            height: swiperWidth + "px"
          });
        } else {
          $cubeShadowEl = $el.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $el.append($cubeShadowEl);
          }
        }
      }

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = slides.eq(i);
        var slideIndex = i;

        if (isVirtual) {
          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
        }

        var slideAngle = slideIndex * 90;
        var round = Math.floor(slideAngle / 360);

        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }

        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        var tx = 0;
        var ty = 0;
        var tz = 0;

        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + round * 4 * swiperSize;
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = 3 * swiperSize + swiperSize * 4 * round;
        }

        if (rtl) {
          tx = -tx;
        }

        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }

        var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";

        if (progress <= 1 && progress > -1) {
          wrapperRotate = slideIndex * 90 + progress * 90;

          if (rtl) {
            wrapperRotate = -slideIndex * 90 - progress * 90;
          }
        }

        $slideEl.transform(transform);

        if (params.slideShadows) {
          // Set shadows
          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) {
            shadowBefore[0].style.opacity = Math.max(-progress, 0);
          }

          if (shadowAfter.length) {
            shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }
      }

      $wrapperEl.css({
        '-webkit-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        '-moz-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        '-ms-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        'transform-origin': "50% 50% -" + swiperSize / 2 + "px"
      });

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
        } else {
          var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
          var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
          var scale1 = params.shadowScale;
          var scale2 = params.shadowScale / multiplier;
          var offset = params.shadowOffset;
          $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
        }
      }

      var zFactor = Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
      $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var $el = swiper.$el;
      var slides = swiper.slides;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
        $el.find('.swiper-cube-shadow').transition(duration);
      }
    }
  };
  var EffectCube = {
    name: 'effect-cube',
    params: {
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        cubeEffect: {
          setTranslate: Cube.setTranslate.bind(swiper),
          setTransition: Cube.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'cube') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "cube");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          resistanceRatio: 0,
          spaceBetween: 0,
          centeredSlides: false,
          virtualTranslate: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'cube') {
          return;
        }

        swiper.cubeEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'cube') {
          return;
        }

        swiper.cubeEffect.setTransition(duration);
      }
    }
  };
  var Flip = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var slides = swiper.slides;
      var rtl = swiper.rtlTranslate;

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = slides.eq(i);
        var progress = $slideEl[0].progress;

        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        }

        var offset = $slideEl[0].swiperSlideOffset;
        var rotate = -180 * progress;
        var rotateY = rotate;
        var rotateX = 0;
        var tx = -offset;
        var ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }

        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

        if (swiper.params.flipEffect.slideShadows) {
          // Set shadows
          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>");
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) {
            shadowBefore[0].style.opacity = Math.max(-progress, 0);
          }

          if (shadowAfter.length) {
            shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }

        $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var slides = swiper.slides;
      var activeIndex = swiper.activeIndex;
      var $wrapperEl = swiper.$wrapperEl;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false; // eslint-disable-next-line

        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
          if (eventTriggered) {
            return;
          }

          if (!swiper || swiper.destroyed) {
            return;
          } // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;


          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
  };
  var EffectFlip = {
    name: 'effect-flip',
    params: {
      flipEffect: {
        slideShadows: true,
        limitRotation: true
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        flipEffect: {
          setTranslate: Flip.setTranslate.bind(swiper),
          setTransition: Flip.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'flip') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "flip");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'flip') {
          return;
        }

        swiper.flipEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'flip') {
          return;
        }

        swiper.flipEffect.setTransition(duration);
      }
    }
  };
  var Coverflow = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var swiperWidth = swiper.width;
      var swiperHeight = swiper.height;
      var slides = swiper.slides;
      var $wrapperEl = swiper.$wrapperEl;
      var slidesSizesGrid = swiper.slidesSizesGrid;
      var params = swiper.params.coverflowEffect;
      var isHorizontal = swiper.isHorizontal();
      var transform = swiper.translate;
      var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
      var rotate = isHorizontal ? params.rotate : -params.rotate;
      var translate = params.depth; // Each slide offset from center

      for (var i = 0, length = slides.length; i < length; i += 1) {
        var $slideEl = slides.eq(i);
        var slideSize = slidesSizesGrid[i];
        var slideOffset = $slideEl[0].swiperSlideOffset;
        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

        var translateZ = -translate * Math.abs(offsetMultiplier);
        var translateY = isHorizontal ? 0 : params.stretch * offsetMultiplier;
        var translateX = isHorizontal ? params.stretch * offsetMultiplier : 0; // Fix for ultra small values

        if (Math.abs(translateX) < 0.001) {
          translateX = 0;
        }

        if (Math.abs(translateY) < 0.001) {
          translateY = 0;
        }

        if (Math.abs(translateZ) < 0.001) {
          translateZ = 0;
        }

        if (Math.abs(rotateY) < 0.001) {
          rotateY = 0;
        }

        if (Math.abs(rotateX) < 0.001) {
          rotateX = 0;
        }

        var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
        $slideEl.transform(slideTransform);
        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

        if (params.slideShadows) {
          // Set shadows
          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if ($shadowBeforeEl.length === 0) {
            $shadowBeforeEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
            $slideEl.append($shadowBeforeEl);
          }

          if ($shadowAfterEl.length === 0) {
            $shadowAfterEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append($shadowAfterEl);
          }

          if ($shadowBeforeEl.length) {
            $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          }

          if ($shadowAfterEl.length) {
            $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
          }
        }
      } // Set correct perspective for IE10


      if (Support.pointerEvents || Support.prefixedPointerEvents) {
        var ws = $wrapperEl[0].style;
        ws.perspectiveOrigin = center + "px 50%";
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
    }
  };
  var EffectCoverflow = {
    name: 'effect-coverflow',
    params: {
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        modifier: 1,
        slideShadows: true
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        coverflowEffect: {
          setTranslate: Coverflow.setTranslate.bind(swiper),
          setTransition: Coverflow.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'coverflow') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'coverflow') {
          return;
        }

        swiper.coverflowEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'coverflow') {
          return;
        }

        swiper.coverflowEffect.setTransition(duration);
      }
    }
  };
  var Thumbs = {
    init: function init() {
      var swiper = this;
      var ref = swiper.params;
      var thumbsParams = ref.thumbs;
      var SwiperClass = swiper.constructor;

      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper.thumbs.swiper = thumbsParams.swiper;
        Utils.extend(swiper.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        Utils.extend(swiper.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
      } else if (Utils.isObject(thumbsParams.swiper)) {
        swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
          watchSlidesVisibility: true,
          watchSlidesProgress: true,
          slideToClickedSlide: false
        }));
        swiper.thumbs.swiperCreated = true;
      }

      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
    },
    onThumbClick: function onThumbClick() {
      var swiper = this;
      var thumbsSwiper = swiper.thumbs.swiper;

      if (!thumbsSwiper) {
        return;
      }

      var clickedIndex = thumbsSwiper.clickedIndex;
      var clickedSlide = thumbsSwiper.clickedSlide;

      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) {
        return;
      }

      if (typeof clickedIndex === 'undefined' || clickedIndex === null) {
        return;
      }

      var slideToIndex;

      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
      } else {
        slideToIndex = clickedIndex;
      }

      if (swiper.params.loop) {
        var currentIndex = swiper.activeIndex;

        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          currentIndex = swiper.activeIndex;
        }

        var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
        var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();

        if (typeof prevIndex === 'undefined') {
          slideToIndex = nextIndex;
        } else if (typeof nextIndex === 'undefined') {
          slideToIndex = prevIndex;
        } else if (nextIndex - currentIndex < currentIndex - prevIndex) {
          slideToIndex = nextIndex;
        } else {
          slideToIndex = prevIndex;
        }
      }

      swiper.slideTo(slideToIndex);
    },
    update: function update(initial) {
      var swiper = this;
      var thumbsSwiper = swiper.thumbs.swiper;

      if (!thumbsSwiper) {
        return;
      }

      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

      if (swiper.realIndex !== thumbsSwiper.realIndex) {
        var currentThumbsIndex = thumbsSwiper.activeIndex;
        var newThumbsIndex;

        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix(); // eslint-disable-next-line

            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          } // Find actual thumbs index to slide to


          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();

          if (typeof prevThumbsIndex === 'undefined') {
            newThumbsIndex = nextThumbsIndex;
          } else if (typeof nextThumbsIndex === 'undefined') {
            newThumbsIndex = prevThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = currentThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = nextThumbsIndex;
          } else {
            newThumbsIndex = prevThumbsIndex;
          }
        } else {
          newThumbsIndex = swiper.realIndex;
        }

        if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - slidesPerView + 1;
          }

          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
        }
      } // Activate thumbs


      var thumbsToActivate = 1;
      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
        thumbsToActivate = swiper.params.slidesPerView;
      }

      thumbsSwiper.slides.removeClass(thumbActiveClass);

      if (thumbsSwiper.params.loop) {
        for (var i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]").addClass(thumbActiveClass);
        }
      } else {
        for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
          thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
        }
      }
    }
  };
  var Thumbs$1 = {
    name: 'thumbs',
    params: {
      thumbs: {
        swiper: null,
        slideThumbActiveClass: 'swiper-slide-thumb-active',
        thumbsContainerClass: 'swiper-container-thumbs'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        thumbs: {
          swiper: null,
          init: Thumbs.init.bind(swiper),
          update: Thumbs.update.bind(swiper),
          onThumbClick: Thumbs.onThumbClick.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;
        var ref = swiper.params;
        var thumbs = ref.thumbs;

        if (!thumbs || !thumbs.swiper) {
          return;
        }

        swiper.thumbs.init();
        swiper.thumbs.update(true);
      },
      slideChange: function slideChange() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      update: function update() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      resize: function resize() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      observerUpdate: function observerUpdate() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;

        if (!thumbsSwiper) {
          return;
        }

        thumbsSwiper.setTransition(duration);
      },
      beforeDestroy: function beforeDestroy() {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;

        if (!thumbsSwiper) {
          return;
        }

        if (swiper.thumbs.swiperCreated && thumbsSwiper) {
          thumbsSwiper.destroy();
        }
      }
    }
  }; // Swiper Class

  var components = [Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow, Thumbs$1];

  if (typeof Swiper.use === 'undefined') {
    Swiper.use = Swiper.Class.use;
    Swiper.installModule = Swiper.Class.installModule;
  }

  Swiper.use(components);
  return Swiper;
});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(266);


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_polyfill__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_polyfill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_polyfill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_object_fit_images__ = __webpack_require__(433);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_object_fit_images___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_object_fit_images__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_picturefill__ = __webpack_require__(434);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_picturefill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__components_picturefill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_autocomplete__ = __webpack_require__(435);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_preloader__ = __webpack_require__(438);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_dropdown__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_megamenu__ = __webpack_require__(439);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_responsive_event__ = __webpack_require__(440);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_fixed_header__ = __webpack_require__(441);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_cookies__ = __webpack_require__(442);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_new_window__ = __webpack_require__(443);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__components_accesstooltip__ = __webpack_require__(444);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__components_stratis_datepicker__ = __webpack_require__(445);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__components_galleries__ = __webpack_require__(448);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__components_go_to_top_go_to_top__ = __webpack_require__(450);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__components_flash_info_flash_info__ = __webpack_require__(451);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__components_page_image_page_image__ = __webpack_require__(452);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__components_stratis_menu_stratis_menu__ = __webpack_require__(453);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__components_chart__ = __webpack_require__(454);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__components_slideToggler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__components_tabsCordion__ = __webpack_require__(499);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__components_categories__ = __webpack_require__(500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__components_carousel__ = __webpack_require__(501);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__components_multiselect_multiselect__ = __webpack_require__(502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__components_formsHandler__ = __webpack_require__(503);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__components_buttons_state_toggle__ = __webpack_require__(504);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__components_projects_projects__ = __webpack_require__(505);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__components_geocode__ = __webpack_require__(506);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__components_tarteaucitron_stratis__ = __webpack_require__(507);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__components_search_content__ = __webpack_require__(508);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__components_publications_publication__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__components_interactive_map__ = __webpack_require__(510);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

































 // import Readspeaker from '../components/read-speaker/read-speaker';

document.addEventListener('DOMContentLoaded', function () {
  window.addEventListener('responsive', function () {
    console.log('current breakpoint: ', window.responsive);
  });
  var event = new __WEBPACK_IMPORTED_MODULE_8__components_responsive_event__["a" /* default */]();
  Object(__WEBPACK_IMPORTED_MODULE_23__components_carousel__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_18__components_stratis_menu_stratis_menu__["a" /* default */])();
  __WEBPACK_IMPORTED_MODULE_1_object_fit_images___default()('img');
  Object(__WEBPACK_IMPORTED_MODULE_15__components_go_to_top_go_to_top__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_10__components_cookies__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_11__components_new_window__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_16__components_flash_info_flash_info__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_4__components_autocomplete__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_13__components_stratis_datepicker__["a" /* enableDatePicker */])();
  Object(__WEBPACK_IMPORTED_MODULE_13__components_stratis_datepicker__["b" /* enableTimePicker */])();
  Object(__WEBPACK_IMPORTED_MODULE_17__components_page_image_page_image__["a" /* default */])(); // initFixedHeader('.header:not(.-map) .header-bar');

  Object(__WEBPACK_IMPORTED_MODULE_31__components_publications_publication__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_14__components_galleries__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_19__components_chart__["a" /* default */])('.chart');
  Object(__WEBPACK_IMPORTED_MODULE_32__components_interactive_map__["a" /* default */])();
  var tooltipSettings = {
    objs: '.js-tooltip',
    tooltipClassName: 'access-tooltip',
    toolTipBetween: 15,
    toolTipUp: false,
    mouse: true,
    tempDelay: 6000,
    useAriaDP: false,
    useEscClose: true
  };
  Object(__WEBPACK_IMPORTED_MODULE_12__components_accesstooltip__["a" /* default */])(tooltipSettings);
  Object(__WEBPACK_IMPORTED_MODULE_22__components_categories__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_24__components_multiselect_multiselect__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_25__components_formsHandler__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_26__components_buttons_state_toggle__["a" /* default */])();
  Object(__WEBPACK_IMPORTED_MODULE_27__components_projects_projects__["a" /* default */])();
  var geo = new __WEBPACK_IMPORTED_MODULE_28__components_geocode__["a" /* default */]();
  var electedName = new __WEBPACK_IMPORTED_MODULE_30__components_search_content__["a" /* default */]('.contact-elected', {
    search: ['#keyword1', '#select1'],
    searchButton: '.filters__buttons .filters__button.-submit',
    item: '.contact__item'
  }); // Comply to the european cookie law

  var cookies = new __WEBPACK_IMPORTED_MODULE_29__components_tarteaucitron_stratis__["a" /* default */]({
    language: 'fr',
    customText: {
      alertBigClick: '',
      alertBig: l10n.cookieMessage,
      alertBigPrivacy: 'Afin de vous proposer des vidéos, des boutons de partage, des contenus remontés des réseaux sociaux et d\'élaborer des statistiques de fréquentation, nous sommes susceptibles de déposer des cookies tiers sur votre machine. Cela ne peut se faire qu\'en obtenant, au préalable, votre consentement pour chacun de ce cookies'
    },
    config: {
      cookieName: 'tartaucitron',
      hashtag: '#tarteaucitron',

      /* Ouverture automatique du panel avec le hashtag */
      highPrivacy: true,

      /* désactiver le consentement implicite (en naviguant) ? */
      orientation: 'bottom',

      /* le bandeau doit être en haut (top) ou en bas (bottom) ? */
      adblocker: false,

      /* Afficher un message si un adblocker est détecté */
      showAlertSmall: false,

      /* afficher le petit bandeau en bas à droite ? */
      cookieslist: false,

      /* Afficher la liste des cookies installés ? */
      removeCredit: true,

      /* supprimer le lien vers la source ? */
      handleBrowserDNTRequest: false,
      AcceptAllCta: true,
      moreInfoLink: true // cookieDomain: '.example.com' /* Nom de domaine sur lequel sera posé le cookie pour les sous-domaines */

    }
  }); // Add services to cookies manager

  cookies.addServices('youtube, vimeo, dailymotion'); //Initializing click roll in the sidebar of map

  window.addEventListener('openPopup', function () {
    var clickRoll = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.click-roll', {
      wrapperClass: 'click-roll',
      dropdownClass: 'click-roll__block',
      btnClass: 'click-roll__toggle',
      closeOnOutsideClick: false,
      openTypeSlide: true,
      isWrapContent: true
    });
  });
  document.createElement('picture');
  var drop = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */](); // Create DefaultMenu with settings

  var menu = new __WEBPACK_IMPORTED_MODULE_7__components_megamenu__["a" /* default */]('.mnv-menu', {
    menu: {
      type: 'aside'
    }
  });
  var filter = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.filters__container', {
    wrapperClass: 'filters__container',
    dropdownClass: 'filters__dropdown',
    outsideToggle: true,
    outsideToggleId: 'filter-dropdown-toggle',
    closeOnOutsideClick: false,
    opened: ['desktop', 'tablet']
  });
  var menuFloating = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.menu-floating', {
    wrapperClass: 'menu-floating',
    dropdownClass: 'menu-floating__list',
    closeOnOutsideClick: false,
    btnClass: 'menu-floating__btn',
    opened: ['desktop']
  });
  var headerSearchForm = document.querySelector('.header-search__form');

  if (headerSearchForm !== null) {
    var searchDropdown = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.header-search', {
      wrapperClass: 'header-search',
      dropdownClass: 'header-search__form',
      btnClass: 'header-search__toggle',
      closeOnOutsideClick: true
    });
  }

  var sameCategory = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.same-category__wrapper', {
    wrapperClass: 'same-category__wrapper',
    dropdownClass: 'same-category__list',
    btnClass: 'same-category__toggle',
    opened: ['desktop']
  });
  var checkboxDropdown = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.checkbox-dropdown', {
    wrapperClass: 'checkbox-dropdown',
    dropdownClass: 'checkbox-dropdown__block',
    btnClass: 'checkbox-dropdown__toggle',
    closeOnOutsideClick: false
  });
  var oneClick = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.one-click-panel', {
    wrapperClass: 'one-click-panel',
    dropdownClass: 'one-click-panel__section',
    closeBtn: true,
    closeBtnClass: 'one-click-panel__close',
    outsideToggle: true,
    outsideToggleId: 'js-one-click-toggle',
    focusTrap: ['desktop'],
    beforeOpen: function beforeOpen() {
      if (window.responsive === 'desktop') {
        __WEBPACK_IMPORTED_MODULE_3__helpers__["a" /* addClass */](document.body, '-overflow-hidden');
      }
    },
    afterClose: function afterClose() {
      if (window.responsive === 'desktop') {
        __WEBPACK_IMPORTED_MODULE_3__helpers__["w" /* removeClass */](document.body, '-overflow-hidden');
      }
    }
  }); // Turn on slideToggle

  var toggleItems = [].slice.call(document.querySelectorAll('[data-sd-content]'));
  toggleItems.forEach(function (toggleItem) {
    var toggleItemName = toggleItem.dataset.sdContent;
    var toggleTriggers = document.querySelectorAll("[data-sd-trigger=\"".concat(toggleItemName, "\"]"));
    var item = toggleTriggers.length > 0 && new __WEBPACK_IMPORTED_MODULE_20__components_slideToggler__["a" /* default */](toggleItem);

    if (item) {
      toggleTriggers.forEach(function (toggleTrigger) {
        var action = toggleTrigger.getAttribute('data-sd-action') || 'toggle';
        toggleTrigger.addEventListener('click', function () {
          return __WEBPACK_IMPORTED_MODULE_3__helpers__["e" /* executeIfFunction */](item[action].bind(item));
        });
      });
    }
  }); // Add class to ancestor
  // Find ancestor and add to it a class
  // Just add to element data attribute with selector and class: data-add-ancestor="container-wrapper,-dark"

  var addClassToAncestors = [].slice.call(document.querySelectorAll('[data-add-ancestor]'));
  addClassToAncestors.forEach(function (child) {
    var _child$getAttribute$s = child.getAttribute('data-add-ancestor').split(',', 2),
        _child$getAttribute$s2 = _slicedToArray(_child$getAttribute$s, 2),
        selector = _child$getAttribute$s2[0],
        cls = _child$getAttribute$s2[1];

    var ancestor = __WEBPACK_IMPORTED_MODULE_3__helpers__["g" /* findAncestor */](child, selector);

    if (ancestor) {
      __WEBPACK_IMPORTED_MODULE_3__helpers__["a" /* addClass */](ancestor, cls);
    }
  }); // Add this block with class <span class="ghost" data-remove-section="class"></span>

  var removeEmptySection = [].slice.call(document.querySelectorAll('[data-remove-section]'));
  removeEmptySection.forEach(function (child) {
    var el = child.getAttribute('data-remove-section');
    var ancestor = __WEBPACK_IMPORTED_MODULE_3__helpers__["g" /* findAncestor */](child, el);

    if (ancestor) {
      ancestor.parentNode.removeChild(ancestor);
    }
  });
  var tabs = new __WEBPACK_IMPORTED_MODULE_21__components_tabsCordion__["a" /* default */]('.tabs', {
    onlyState: 'tabs',
    titleSelector: '.tabs__title',
    afterInit: function afterInit() {
      Object(__WEBPACK_IMPORTED_MODULE_12__components_accesstooltip__["a" /* default */])(Object.assign(tooltipSettings, {
        objs: '.tabs .js-tooltip'
      }));
    }
  }); // Readpseaker - See doc in read-speaker.js

  /*
  const initRS = new Readspeaker('article.container-wrapper .heading', {
      insertPosition: 'beforebegin',
      customerId: '10375',
      readId: null,
      readClass: 'heading__content,site-content',
      config: {
          general: {
              usePost: true,
          },
          ui: {
              disableDetachment: true,
              displayDownload: true,
              tools: {
                  translation: true,
              },
          },
      },
      preserveScript: '.click-roll, .localiser',
      ignoreContent: '.gallery, .media-element__wrapper, .localiser, .pager',
  });
  */
});
window.addEventListener('load', function () {
  Object(__WEBPACK_IMPORTED_MODULE_5__components_preloader__["a" /* default */])();
  var siteImages = [].slice.call(document.getElementsByTagName('img')); // Edge fix

  siteImages.filter(function (img) {
    return !img.hasAttribute('data-ofi-src');
  }) // Exclude object-fit images
  .filter(function (img) {
    return img.src.indexOf('.svg') === -1;
  }) // Exclude svg since they can return 0 sometimes
  .forEach(function (img) {
    if (!img.naturalHeight) {
      __WEBPACK_IMPORTED_MODULE_3__helpers__["a" /* addClass */](img, '-broken-img');
      img.setAttribute('height', 0);
    }
  });
  var clickRoll = new __WEBPACK_IMPORTED_MODULE_6__components_dropdown__["a" /* default */]('.click-roll', {
    wrapperClass: 'click-roll',
    dropdownClass: 'click-roll__block',
    btnClass: 'click-roll__toggle',
    closeOnOutsideClick: false,
    openTypeSlide: true,
    isWrapContent: true
  });
});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(268);

__webpack_require__(411);

__webpack_require__(413);

__webpack_require__(415);

__webpack_require__(417);

__webpack_require__(419);

__webpack_require__(421);

__webpack_require__(423);

__webpack_require__(425);

__webpack_require__(427);

__webpack_require__(431);

if (global._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

global._babelPolyfill = true;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(70)))

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(269);

__webpack_require__(271);

__webpack_require__(272);

__webpack_require__(273);

__webpack_require__(274);

__webpack_require__(275);

__webpack_require__(276);

__webpack_require__(277);

__webpack_require__(278);

__webpack_require__(279);

__webpack_require__(280);

__webpack_require__(281);

__webpack_require__(282);

__webpack_require__(283);

__webpack_require__(284);

__webpack_require__(285);

__webpack_require__(286);

__webpack_require__(287);

__webpack_require__(288);

__webpack_require__(289);

__webpack_require__(290);

__webpack_require__(291);

__webpack_require__(292);

__webpack_require__(293);

__webpack_require__(294);

__webpack_require__(295);

__webpack_require__(296);

__webpack_require__(297);

__webpack_require__(298);

__webpack_require__(299);

__webpack_require__(300);

__webpack_require__(301);

__webpack_require__(302);

__webpack_require__(303);

__webpack_require__(304);

__webpack_require__(305);

__webpack_require__(306);

__webpack_require__(307);

__webpack_require__(308);

__webpack_require__(309);

__webpack_require__(310);

__webpack_require__(311);

__webpack_require__(312);

__webpack_require__(314);

__webpack_require__(315);

__webpack_require__(316);

__webpack_require__(317);

__webpack_require__(318);

__webpack_require__(319);

__webpack_require__(320);

__webpack_require__(321);

__webpack_require__(322);

__webpack_require__(323);

__webpack_require__(324);

__webpack_require__(325);

__webpack_require__(326);

__webpack_require__(327);

__webpack_require__(328);

__webpack_require__(329);

__webpack_require__(330);

__webpack_require__(331);

__webpack_require__(332);

__webpack_require__(333);

__webpack_require__(334);

__webpack_require__(335);

__webpack_require__(336);

__webpack_require__(337);

__webpack_require__(338);

__webpack_require__(339);

__webpack_require__(340);

__webpack_require__(341);

__webpack_require__(342);

__webpack_require__(343);

__webpack_require__(344);

__webpack_require__(345);

__webpack_require__(346);

__webpack_require__(347);

__webpack_require__(349);

__webpack_require__(350);

__webpack_require__(352);

__webpack_require__(353);

__webpack_require__(354);

__webpack_require__(355);

__webpack_require__(356);

__webpack_require__(357);

__webpack_require__(358);

__webpack_require__(361);

__webpack_require__(362);

__webpack_require__(363);

__webpack_require__(364);

__webpack_require__(365);

__webpack_require__(366);

__webpack_require__(367);

__webpack_require__(368);

__webpack_require__(369);

__webpack_require__(370);

__webpack_require__(371);

__webpack_require__(372);

__webpack_require__(373);

__webpack_require__(93);

__webpack_require__(374);

__webpack_require__(119);

__webpack_require__(375);

__webpack_require__(120);

__webpack_require__(376);

__webpack_require__(377);

__webpack_require__(378);

__webpack_require__(379);

__webpack_require__(121);

__webpack_require__(382);

__webpack_require__(383);

__webpack_require__(384);

__webpack_require__(385);

__webpack_require__(386);

__webpack_require__(387);

__webpack_require__(388);

__webpack_require__(389);

__webpack_require__(390);

__webpack_require__(391);

__webpack_require__(392);

__webpack_require__(393);

__webpack_require__(394);

__webpack_require__(395);

__webpack_require__(396);

__webpack_require__(397);

__webpack_require__(398);

__webpack_require__(399);

__webpack_require__(400);

__webpack_require__(401);

__webpack_require__(402);

__webpack_require__(403);

__webpack_require__(404);

__webpack_require__(405);

__webpack_require__(406);

__webpack_require__(407);

__webpack_require__(408);

__webpack_require__(409);

__webpack_require__(410);

module.exports = __webpack_require__(13);

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

var global = __webpack_require__(5);

var has = __webpack_require__(17);

var DESCRIPTORS = __webpack_require__(12);

var $export = __webpack_require__(1);

var redefine = __webpack_require__(14);

var META = __webpack_require__(32).KEY;

var $fails = __webpack_require__(3);

var shared = __webpack_require__(72);

var setToStringTag = __webpack_require__(44);

var uid = __webpack_require__(37);

var wks = __webpack_require__(9);

var wksExt = __webpack_require__(73);

var wksDefine = __webpack_require__(101);

var enumKeys = __webpack_require__(270);

var isArray = __webpack_require__(76);

var anObject = __webpack_require__(4);

var isObject = __webpack_require__(6);

var toIObject = __webpack_require__(19);

var toPrimitive = __webpack_require__(31);

var createDesc = __webpack_require__(36);

var _create = __webpack_require__(41);

var gOPNExt = __webpack_require__(104);

var $GOPD = __webpack_require__(22);

var $DP = __webpack_require__(11);

var $keys = __webpack_require__(39);

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) $defineProperty(it, key = keys[i++], P[key]);

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(42).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(52).f = $propertyIsEnumerable;
  __webpack_require__(59).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(38)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) args.push(arguments[i++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(39);

var gOPS = __webpack_require__(59);

var pIE = __webpack_require__(52);

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }

  return result;
};

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(41)
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(12), 'Object', {
  defineProperty: __webpack_require__(11).f
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(12), 'Object', {
  defineProperties: __webpack_require__(103)
});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(19);

var $getOwnPropertyDescriptor = __webpack_require__(22).f;

__webpack_require__(23)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(15);

var $getPrototypeOf = __webpack_require__(43);

__webpack_require__(23)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(15);

var $keys = __webpack_require__(39);

__webpack_require__(23)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(23)('getOwnPropertyNames', function () {
  return __webpack_require__(104).f;
});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(6);

var meta = __webpack_require__(32).onFreeze;

__webpack_require__(23)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(6);

var meta = __webpack_require__(32).onFreeze;

__webpack_require__(23)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(6);

var meta = __webpack_require__(32).onFreeze;

__webpack_require__(23)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(6);

__webpack_require__(23)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(6);

__webpack_require__(23)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(6);

__webpack_require__(23)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(1);

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(105)
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(1);

$export($export.S, 'Object', {
  is: __webpack_require__(106)
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(1);

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(78).set
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(53);

var test = {};
test[__webpack_require__(9)('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(14)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(1);

$export($export.P, 'Function', {
  bind: __webpack_require__(107)
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(11).f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(12) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(6);

var getPrototypeOf = __webpack_require__(43);

var HAS_INSTANCE = __webpack_require__(9)('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(11).f(FunctionProto, HAS_INSTANCE, {
  value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

    return false;
  }
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var $parseInt = __webpack_require__(109); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var $parseFloat = __webpack_require__(110); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);

var has = __webpack_require__(17);

var cof = __webpack_require__(28);

var inheritIfRequired = __webpack_require__(80);

var toPrimitive = __webpack_require__(31);

var fails = __webpack_require__(3);

var gOPN = __webpack_require__(42).f;

var gOPD = __webpack_require__(22).f;

var dP = __webpack_require__(11).f;

var $trim = __webpack_require__(60).trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(41)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(12) ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(14)(global, NUMBER, $Number);
}

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var toInteger = __webpack_require__(21);

var aNumberValue = __webpack_require__(111);

var repeat = __webpack_require__(81);

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $fails = __webpack_require__(3);

var aNumberValue = __webpack_require__(111);

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(1);

var _isFinite = __webpack_require__(5).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  isInteger: __webpack_require__(112)
});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(1);

var isInteger = __webpack_require__(112);

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var $parseFloat = __webpack_require__(110); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var $parseInt = __webpack_require__(109); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(1);

var log1p = __webpack_require__(113);

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(1);

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(1);

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(1);

var sign = __webpack_require__(82);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(1);

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(1);

var $expm1 = __webpack_require__(83);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  fround: __webpack_require__(313)
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(82);

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(1);

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(1);

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log1p: __webpack_require__(113)
});

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  sign: __webpack_require__(82)
});

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(1);

var expm1 = __webpack_require__(83);

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(1);

var expm1 = __webpack_require__(83);

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var toAbsoluteIndex = __webpack_require__(40);

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var toIObject = __webpack_require__(19);

var toLength = __webpack_require__(10);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(60)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(84)(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(85)(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $at = __webpack_require__(84)(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(1);

var toLength = __webpack_require__(10);

var context = __webpack_require__(86);

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(88)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(1);

var context = __webpack_require__(86);

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(88)(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(81)
});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(1);

var toLength = __webpack_require__(10);

var context = __webpack_require__(86);

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(88)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(16)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(16)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(16)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(16)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(16)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(16)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(16)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(16)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(16)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(16)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(16)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(16)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(16)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(1);

$export($export.S, 'Date', {
  now: function () {
    return new Date().getTime();
  }
});

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var toObject = __webpack_require__(15);

var toPrimitive = __webpack_require__(31);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function () {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(1);

var toISOString = __webpack_require__(348); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(3);

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(14)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(9)('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(18)(proto, TO_PRIMITIVE, __webpack_require__(351));

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);

var toPrimitive = __webpack_require__(31);

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(1);

$export($export.S, 'Array', {
  isArray: __webpack_require__(76)
});

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(26);

var $export = __webpack_require__(1);

var toObject = __webpack_require__(15);

var call = __webpack_require__(115);

var isArrayIter = __webpack_require__(89);

var toLength = __webpack_require__(10);

var createProperty = __webpack_require__(90);

var getIterFn = __webpack_require__(91);

$export($export.S + $export.F * !__webpack_require__(61)(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var createProperty = __webpack_require__(90); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) createProperty(result, index, arguments[index++]);

    result.length = aLen;
    return result;
  }
});

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(1);

var toIObject = __webpack_require__(19);

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(51) != Object || !__webpack_require__(20)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var html = __webpack_require__(77);

var cof = __webpack_require__(28);

var toAbsoluteIndex = __webpack_require__(40);

var toLength = __webpack_require__(10);

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];

    return cloned;
  }
});

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var aFunction = __webpack_require__(27);

var toObject = __webpack_require__(15);

var fails = __webpack_require__(3);

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(20)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $forEach = __webpack_require__(24)(0);

var STRICT = __webpack_require__(20)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(360);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6);

var isArray = __webpack_require__(76);

var SPECIES = __webpack_require__(9)('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $map = __webpack_require__(24)(1);

$export($export.P + $export.F * !__webpack_require__(20)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $filter = __webpack_require__(24)(2);

$export($export.P + $export.F * !__webpack_require__(20)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $some = __webpack_require__(24)(3);

$export($export.P + $export.F * !__webpack_require__(20)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $every = __webpack_require__(24)(4);

$export($export.P + $export.F * !__webpack_require__(20)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $reduce = __webpack_require__(116);

$export($export.P + $export.F * !__webpack_require__(20)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $reduce = __webpack_require__(116);

$export($export.P + $export.F * !__webpack_require__(20)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $indexOf = __webpack_require__(58)(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(20)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var toIObject = __webpack_require__(19);

var toInteger = __webpack_require__(21);

var toLength = __webpack_require__(10);

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(20)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;

    return -1;
  }
});

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(1);

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(117)
});

__webpack_require__(46)('copyWithin');

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(1);

$export($export.P, 'Array', {
  fill: __webpack_require__(92)
});

__webpack_require__(46)('fill');

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(1);

var $find = __webpack_require__(24)(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(46)(KEY);

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(1);

var $find = __webpack_require__(24)(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(46)(KEY);

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(47)('Array');

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var inheritIfRequired = __webpack_require__(80);

var dP = __webpack_require__(11).f;

var gOPN = __webpack_require__(42).f;

var isRegExp = __webpack_require__(87);

var $flags = __webpack_require__(62);

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(12) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(9)('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () {
        return Base[key];
      },
      set: function (it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(14)(global, 'RegExp', $RegExp);
}

__webpack_require__(47)('RegExp');

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(120);

var anObject = __webpack_require__(4);

var $flags = __webpack_require__(62);

var DESCRIPTORS = __webpack_require__(12);

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(14)(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(3)(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);

var toLength = __webpack_require__(10);

var advanceStringIndex = __webpack_require__(95);

var regExpExec = __webpack_require__(63); // @@match logic


__webpack_require__(64)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);

var toObject = __webpack_require__(15);

var toLength = __webpack_require__(10);

var toInteger = __webpack_require__(21);

var advanceStringIndex = __webpack_require__(95);

var regExpExec = __webpack_require__(63);

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(64)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return ch;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return ch;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return ch;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);

var sameValue = __webpack_require__(106);

var regExpExec = __webpack_require__(63); // @@search logic


__webpack_require__(64)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(87);

var anObject = __webpack_require__(4);

var speciesConstructor = __webpack_require__(54);

var advanceStringIndex = __webpack_require__(95);

var toLength = __webpack_require__(10);

var callRegExpExec = __webpack_require__(63);

var regexpExec = __webpack_require__(94);

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex'; // eslint-disable-next-line no-empty

var SUPPORTS_Y = !!function () {
  try {
    return new RegExp('x', 'y');
  } catch (e) {}
}(); // @@split logic

__webpack_require__(64)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? 0xffffffff : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);

var macrotask = __webpack_require__(96).set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(28)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function () {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),
/* 381 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(124);

var validate = __webpack_require__(50);

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(67)(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(124);

var validate = __webpack_require__(50);

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(67)(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var each = __webpack_require__(24)(0);

var redefine = __webpack_require__(14);

var meta = __webpack_require__(32);

var assign = __webpack_require__(105);

var weak = __webpack_require__(125);

var isObject = __webpack_require__(6);

var fails = __webpack_require__(3);

var validate = __webpack_require__(50);

var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(67)(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(125);

var validate = __webpack_require__(50);

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(67)(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

var $typed = __webpack_require__(68);

var buffer = __webpack_require__(97);

var anObject = __webpack_require__(4);

var toAbsoluteIndex = __webpack_require__(40);

var toLength = __webpack_require__(10);

var isObject = __webpack_require__(6);

var ArrayBuffer = __webpack_require__(5).ArrayBuffer;

var speciesConstructor = __webpack_require__(54);

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(47)(ARRAY_BUFFER);

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

$export($export.G + $export.W + $export.F * !__webpack_require__(68).ABV, {
  DataView: __webpack_require__(97).DataView
});

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(1);

var aFunction = __webpack_require__(27);

var anObject = __webpack_require__(4);

var rApply = (__webpack_require__(5).Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(1);

var create = __webpack_require__(41);

var aFunction = __webpack_require__(27);

var anObject = __webpack_require__(4);

var isObject = __webpack_require__(6);

var fails = __webpack_require__(3);

var bind = __webpack_require__(107);

var rConstruct = (__webpack_require__(5).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(11);

var $export = __webpack_require__(1);

var anObject = __webpack_require__(4);

var toPrimitive = __webpack_require__(31); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(1);

var gOPD = __webpack_require__(22).f;

var anObject = __webpack_require__(4);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(1);

var anObject = __webpack_require__(4);

var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) keys.push(key);
};

__webpack_require__(114)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(22);

var getPrototypeOf = __webpack_require__(43);

var has = __webpack_require__(17);

var $export = __webpack_require__(1);

var isObject = __webpack_require__(6);

var anObject = __webpack_require__(4);

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(22);

var $export = __webpack_require__(1);

var anObject = __webpack_require__(4);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(1);

var getProto = __webpack_require__(43);

var anObject = __webpack_require__(4);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(1);

var anObject = __webpack_require__(4);

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(127)
});

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(1);

var anObject = __webpack_require__(4);

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(11);

var gOPD = __webpack_require__(22);

var getPrototypeOf = __webpack_require__(43);

var has = __webpack_require__(17);

var $export = __webpack_require__(1);

var createDesc = __webpack_require__(36);

var anObject = __webpack_require__(4);

var isObject = __webpack_require__(6);

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(1);

var setProto = __webpack_require__(78);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(412);

module.exports = __webpack_require__(13).Array.includes;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(1);

var $includes = __webpack_require__(58)(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(46)('includes');

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(414);

module.exports = __webpack_require__(13).String.padStart;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(1);

var $pad = __webpack_require__(128);

var userAgent = __webpack_require__(66); // https://github.com/zloirock/core-js/issues/280


$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(416);

module.exports = __webpack_require__(13).String.padEnd;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(1);

var $pad = __webpack_require__(128);

var userAgent = __webpack_require__(66); // https://github.com/zloirock/core-js/issues/280


$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(418);

module.exports = __webpack_require__(73).f('asyncIterator');

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(101)('asyncIterator');

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(420);

module.exports = __webpack_require__(13).Object.getOwnPropertyDescriptors;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(1);

var ownKeys = __webpack_require__(127);

var toIObject = __webpack_require__(19);

var gOPD = __webpack_require__(22);

var createProperty = __webpack_require__(90);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(422);

module.exports = __webpack_require__(13).Object.values;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(1);

var $values = __webpack_require__(129)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(424);

module.exports = __webpack_require__(13).Object.entries;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(1);

var $entries = __webpack_require__(129)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(121);

__webpack_require__(426);

module.exports = __webpack_require__(13).Promise['finally'];

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(1);

var core = __webpack_require__(13);

var global = __webpack_require__(5);

var speciesConstructor = __webpack_require__(54);

var promiseResolve = __webpack_require__(123);

$export($export.P + $export.R, 'Promise', {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(428);

__webpack_require__(429);

__webpack_require__(430);

module.exports = __webpack_require__(13);

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(5);

var $export = __webpack_require__(1);

var userAgent = __webpack_require__(66);

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

var $task = __webpack_require__(96);

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(93);

var getKeys = __webpack_require__(39);

var redefine = __webpack_require__(14);

var global = __webpack_require__(5);

var hide = __webpack_require__(18);

var Iterators = __webpack_require__(45);

var wks = __webpack_require__(9);

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Promise) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this || typeof self === "object" && self;
}() || Function("return this")());
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 432 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! npm.im/object-fit-images 3.2.4 */


var OFI = 'bfred-it:object-fit-images';
var propRegex = /(object-fit|object-position)\s*:\s*([-.\w\s%]+)/g;
var testImg = typeof Image === 'undefined' ? {
  style: {
    'object-position': 1
  }
} : new Image();
var supportsObjectFit = 'object-fit' in testImg.style;
var supportsObjectPosition = 'object-position' in testImg.style;
var supportsOFI = 'background-size' in testImg.style;
var supportsCurrentSrc = typeof testImg.currentSrc === 'string';
var nativeGetAttribute = testImg.getAttribute;
var nativeSetAttribute = testImg.setAttribute;
var autoModeEnabled = false;

function createPlaceholder(w, h) {
  return "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='" + w + "' height='" + h + "'%3E%3C/svg%3E";
}

function polyfillCurrentSrc(el) {
  if (el.srcset && !supportsCurrentSrc && window.picturefill) {
    var pf = window.picturefill._; // parse srcset with picturefill where currentSrc isn't available

    if (!el[pf.ns] || !el[pf.ns].evaled) {
      // force synchronous srcset parsing
      pf.fillImg(el, {
        reselect: true
      });
    }

    if (!el[pf.ns].curSrc) {
      // force picturefill to parse srcset
      el[pf.ns].supported = false;
      pf.fillImg(el, {
        reselect: true
      });
    } // retrieve parsed currentSrc, if any


    el.currentSrc = el[pf.ns].curSrc || el.src;
  }
}

function getStyle(el) {
  var style = getComputedStyle(el).fontFamily;
  var parsed;
  var props = {};

  while ((parsed = propRegex.exec(style)) !== null) {
    props[parsed[1]] = parsed[2];
  }

  return props;
}

function setPlaceholder(img, width, height) {
  // Default: fill width, no height
  var placeholder = createPlaceholder(width || 1, height || 0); // Only set placeholder if it's different

  if (nativeGetAttribute.call(img, 'src') !== placeholder) {
    nativeSetAttribute.call(img, 'src', placeholder);
  }
}

function onImageReady(img, callback) {
  // naturalWidth is only available when the image headers are loaded,
  // this loop will poll it every 100ms.
  if (img.naturalWidth) {
    callback(img);
  } else {
    setTimeout(onImageReady, 100, img, callback);
  }
}

function fixOne(el) {
  var style = getStyle(el);
  var ofi = el[OFI];
  style['object-fit'] = style['object-fit'] || 'fill'; // default value
  // Avoid running where unnecessary, unless OFI had already done its deed

  if (!ofi.img) {
    // fill is the default behavior so no action is necessary
    if (style['object-fit'] === 'fill') {
      return;
    } // Where object-fit is supported and object-position isn't (Safari < 10)


    if (!ofi.skipTest && // unless user wants to apply regardless of browser support
    supportsObjectFit && // if browser already supports object-fit
    !style['object-position'] // unless object-position is used
    ) {
        return;
      }
  } // keep a clone in memory while resetting the original to a blank


  if (!ofi.img) {
    ofi.img = new Image(el.width, el.height);
    ofi.img.srcset = nativeGetAttribute.call(el, "data-ofi-srcset") || el.srcset;
    ofi.img.src = nativeGetAttribute.call(el, "data-ofi-src") || el.src; // preserve for any future cloneNode calls
    // https://github.com/bfred-it/object-fit-images/issues/53

    nativeSetAttribute.call(el, "data-ofi-src", el.src);

    if (el.srcset) {
      nativeSetAttribute.call(el, "data-ofi-srcset", el.srcset);
    }

    setPlaceholder(el, el.naturalWidth || el.width, el.naturalHeight || el.height); // remove srcset because it overrides src

    if (el.srcset) {
      el.srcset = '';
    }

    try {
      keepSrcUsable(el);
    } catch (err) {
      if (window.console) {
        console.warn('https://bit.ly/ofi-old-browser');
      }
    }
  }

  polyfillCurrentSrc(ofi.img);
  el.style.backgroundImage = "url(\"" + (ofi.img.currentSrc || ofi.img.src).replace(/"/g, '\\"') + "\")";
  el.style.backgroundPosition = style['object-position'] || 'center';
  el.style.backgroundRepeat = 'no-repeat';
  el.style.backgroundOrigin = 'content-box';

  if (/scale-down/.test(style['object-fit'])) {
    onImageReady(ofi.img, function () {
      if (ofi.img.naturalWidth > el.width || ofi.img.naturalHeight > el.height) {
        el.style.backgroundSize = 'contain';
      } else {
        el.style.backgroundSize = 'auto';
      }
    });
  } else {
    el.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');
  }

  onImageReady(ofi.img, function (img) {
    setPlaceholder(el, img.naturalWidth, img.naturalHeight);
  });
}

function keepSrcUsable(el) {
  var descriptors = {
    get: function get(prop) {
      return el[OFI].img[prop ? prop : 'src'];
    },
    set: function set(value, prop) {
      el[OFI].img[prop ? prop : 'src'] = value;
      nativeSetAttribute.call(el, "data-ofi-" + prop, value); // preserve for any future cloneNode

      fixOne(el);
      return value;
    }
  };
  Object.defineProperty(el, 'src', descriptors);
  Object.defineProperty(el, 'currentSrc', {
    get: function () {
      return descriptors.get('currentSrc');
    }
  });
  Object.defineProperty(el, 'srcset', {
    get: function () {
      return descriptors.get('srcset');
    },
    set: function (ss) {
      return descriptors.set(ss, 'srcset');
    }
  });
}

function hijackAttributes() {
  function getOfiImageMaybe(el, name) {
    return el[OFI] && el[OFI].img && (name === 'src' || name === 'srcset') ? el[OFI].img : el;
  }

  if (!supportsObjectPosition) {
    HTMLImageElement.prototype.getAttribute = function (name) {
      return nativeGetAttribute.call(getOfiImageMaybe(this, name), name);
    };

    HTMLImageElement.prototype.setAttribute = function (name, value) {
      return nativeSetAttribute.call(getOfiImageMaybe(this, name), name, String(value));
    };
  }
}

function fix(imgs, opts) {
  var startAutoMode = !autoModeEnabled && !imgs;
  opts = opts || {};
  imgs = imgs || 'img';

  if (supportsObjectPosition && !opts.skipTest || !supportsOFI) {
    return false;
  } // use imgs as a selector or just select all images


  if (imgs === 'img') {
    imgs = document.getElementsByTagName('img');
  } else if (typeof imgs === 'string') {
    imgs = document.querySelectorAll(imgs);
  } else if (!('length' in imgs)) {
    imgs = [imgs];
  } // apply fix to all


  for (var i = 0; i < imgs.length; i++) {
    imgs[i][OFI] = imgs[i][OFI] || {
      skipTest: opts.skipTest
    };
    fixOne(imgs[i]);
  }

  if (startAutoMode) {
    document.body.addEventListener('load', function (e) {
      if (e.target.tagName === 'IMG') {
        fix(e.target, {
          skipTest: opts.skipTest
        });
      }
    }, true);
    autoModeEnabled = true;
    imgs = 'img'; // reset to a generic selector for watchMQ
  } // if requested, watch media queries for object-fit change


  if (opts.watchMQ) {
    window.addEventListener('resize', fix.bind(null, imgs, {
      skipTest: opts.skipTest
    }));
  }
}

fix.supportsObjectFit = supportsObjectFit;
fix.supportsObjectPosition = supportsObjectPosition;
hijackAttributes();
module.exports = fix;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! Picturefill - v2.3.1 - 2015-04-09
* http://scottjehl.github.io/picturefill
* Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */

/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */
window.matchMedia || (window.matchMedia = function () {
  "use strict"; // For browsers that support matchMedium api such as IE 9 and webkit

  var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium

  if (!styleMedia) {
    var style = document.createElement('style'),
        script = document.getElementsByTagName('script')[0],
        info = null;
    style.type = 'text/css';
    style.id = 'matchmediajs-test';
    script.parentNode.insertBefore(style, script); // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers

    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;
    styleMedia = {
      matchMedium: function matchMedium(media) {
        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }'; // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers

        if (style.styleSheet) {
          style.styleSheet.cssText = text;
        } else {
          style.textContent = text;
        } // Test if media query is true or false


        return info.width === '1px';
      }
    };
  }

  return function (media) {
    return {
      matches: styleMedia.matchMedium(media || 'all'),
      media: media || 'all'
    };
  };
}());
/*! Picturefill - Responsive Images that work today.
*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
*  License: MIT/GPLv2
*  Spec: http://picture.responsiveimages.org/
*/

(function (w, doc, image) {
  // Enable strict mode
  "use strict";

  function expose(picturefill) {
    /* expose picturefill */
    if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
      // CommonJS, just export
      module.exports = picturefill;
    } else if (true) {
      // AMD support
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return picturefill;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }

    if (_typeof(w) === "object") {
      // If no AMD and we are in the browser, attach to window
      w.picturefill = picturefill;
    }
  } // If picture is supported, well, that's awesome. Let's get outta here...


  if (w.HTMLPictureElement) {
    expose(function () {});
    return;
  } // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)


  doc.createElement("picture"); // local object for method references and testing exposure

  var pf = w.picturefill || {};
  var regWDesc = /\s+\+?\d+(e\d+)?w/; // namespace

  pf.ns = "picturefill"; // srcset support test

  (function () {
    pf.srcsetSupported = "srcset" in image;
    pf.sizesSupported = "sizes" in image;
    pf.curSrcSupported = "currentSrc" in image;
  })(); // just a string trim workaround


  pf.trim = function (str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  };
  /**
   * Gets a string and returns the absolute URL
   * @param src
   * @returns {String} absolute URL
   */


  pf.makeUrl = function () {
    var anchor = doc.createElement("a");
    return function (src) {
      anchor.href = src;
      return anchor.href;
    };
  }();
  /**
   * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
   */


  pf.restrictsMixedContent = function () {
    return w.location.protocol === "https:";
  };
  /**
   * Shortcut method for matchMedia ( for easy overriding in tests )
   */


  pf.matchesMedia = function (media) {
    return w.matchMedia && w.matchMedia(media).matches;
  }; // Shortcut method for `devicePixelRatio` ( for easy overriding in tests )


  pf.getDpr = function () {
    return w.devicePixelRatio || 1;
  };
  /**
   * Get width in css pixel value from a "length" value
   * http://dev.w3.org/csswg/css-values-3/#length-value
   */


  pf.getWidthFromLength = function (length) {
    var cssValue; // If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, abort.

    if (!(length && length.indexOf("%") > -1 === false && (parseFloat(length) > 0 || length.indexOf("calc(") > -1))) {
      return false;
    }
    /**
     * If length is specified in  `vw` units, use `%` instead since the div we’re measuring
     * is injected at the top of the document.
     *
     * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %
     */


    length = length.replace("vw", "%"); // Create a cached element for getting length value widths

    if (!pf.lengthEl) {
      pf.lengthEl = doc.createElement("div"); // Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.

      pf.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden"; // Add a class, so that everyone knows where this element comes from

      pf.lengthEl.className = "helper-from-picturefill-js";
    }

    pf.lengthEl.style.width = "0px";

    try {
      pf.lengthEl.style.width = length;
    } catch (e) {}

    doc.body.appendChild(pf.lengthEl);
    cssValue = pf.lengthEl.offsetWidth;

    if (cssValue <= 0) {
      cssValue = false;
    }

    doc.body.removeChild(pf.lengthEl);
    return cssValue;
  };

  pf.detectTypeSupport = function (type, typeUri) {
    // based on Modernizr's lossless img-webp test
    // note: asynchronous
    var image = new w.Image();

    image.onerror = function () {
      pf.types[type] = false;
      picturefill();
    };

    image.onload = function () {
      pf.types[type] = image.width === 1;
      picturefill();
    };

    image.src = typeUri;
    return "pending";
  }; // container of supported mime types that one might need to qualify before using


  pf.types = pf.types || {};

  pf.initTypeDetects = function () {
    // Add support for standard mime types
    pf.types["image/jpeg"] = true;
    pf.types["image/gif"] = true;
    pf.types["image/png"] = true;
    pf.types["image/svg+xml"] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
    pf.types["image/webp"] = pf.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");
  };

  pf.verifyTypeSupport = function (source) {
    var type = source.getAttribute("type"); // if type attribute exists, return test result, otherwise return true

    if (type === null || type === "") {
      return true;
    } else {
      var pfType = pf.types[type]; // if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.

      if (typeof pfType === "string" && pfType !== "pending") {
        pf.types[type] = pf.detectTypeSupport(type, pfType);
        return "pending";
      } else if (typeof pfType === "function") {
        pfType();
        return "pending";
      } else {
        return pfType;
      }
    }
  }; // Parses an individual `size` and returns the length, and optional media query


  pf.parseSize = function (sourceSizeStr) {
    var match = /(\([^)]+\))?\s*(.+)/g.exec(sourceSizeStr);
    return {
      media: match && match[1],
      length: match && match[2]
    };
  }; // Takes a string of sizes and returns the width in pixels as a number


  pf.findWidthFromSourceSize = function (sourceSizeListStr) {
    // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
    //                            or (min-width:30em) calc(30% - 15px)
    var sourceSizeList = pf.trim(sourceSizeListStr).split(/\s*,\s*/),
        winningLength;

    for (var i = 0, len = sourceSizeList.length; i < len; i++) {
      // Match <media-condition>? length, ie ( min-width: 50em ) 100%
      var sourceSize = sourceSizeList[i],
          // Split "( min-width: 50em ) 100%" into separate strings
      parsedSize = pf.parseSize(sourceSize),
          length = parsedSize.length,
          media = parsedSize.media;

      if (!length) {
        continue;
      } // if there is no media query or it matches, choose this as our winning length


      if ((!media || pf.matchesMedia(media)) && ( // pass the length to a method that can properly determine length
      // in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
      winningLength = pf.getWidthFromLength(length))) {
        break;
      }
    } //if we have no winningLength fallback to 100vw


    return winningLength || Math.max(w.innerWidth || 0, doc.documentElement.clientWidth);
  };

  pf.parseSrcset = function (srcset) {
    /**
     * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
     * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
     *
     * 1. Let input (`srcset`) be the value passed to this algorithm.
     * 2. Let position be a pointer into input, initially pointing at the start of the string.
     * 3. Let raw candidates be an initially empty ordered list of URLs with associated
     *    unparsed descriptors. The order of entries in the list is the order in which entries
     *    are added to the list.
     */
    var candidates = [];

    while (srcset !== "") {
      srcset = srcset.replace(/^\s+/g, ""); // 5. Collect a sequence of characters that are not space characters, and let that be url.

      var pos = srcset.search(/\s/g),
          url,
          descriptor = null;

      if (pos !== -1) {
        url = srcset.slice(0, pos);
        var last = url.slice(-1); // 6. If url ends with a U+002C COMMA character (,), remove that character from url
        // and let descriptors be the empty string. Otherwise, follow these substeps
        // 6.1. If url is empty, then jump to the step labeled descriptor parser.

        if (last === "," || url === "") {
          url = url.replace(/,+$/, "");
          descriptor = "";
        }

        srcset = srcset.slice(pos + 1); // 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and
        // let that be descriptors.

        if (descriptor === null) {
          var descpos = srcset.indexOf(",");

          if (descpos !== -1) {
            descriptor = srcset.slice(0, descpos);
            srcset = srcset.slice(descpos + 1);
          } else {
            descriptor = srcset;
            srcset = "";
          }
        }
      } else {
        url = srcset;
        srcset = "";
      } // 7. Add url to raw candidates, associated with descriptors.


      if (url || descriptor) {
        candidates.push({
          url: url,
          descriptor: descriptor
        });
      }
    }

    return candidates;
  };

  pf.parseDescriptor = function (descriptor, sizesattr) {
    // 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list
    // is the order in which entries are added to the list.
    var sizes = sizesattr || "100vw",
        sizeDescriptor = descriptor && descriptor.replace(/(^\s+|\s+$)/g, ""),
        widthInCssPixels = pf.findWidthFromSourceSize(sizes),
        resCandidate;

    if (sizeDescriptor) {
      var splitDescriptor = sizeDescriptor.split(" ");

      for (var i = splitDescriptor.length - 1; i >= 0; i--) {
        var curr = splitDescriptor[i],
            lastchar = curr && curr.slice(curr.length - 1);

        if ((lastchar === "h" || lastchar === "w") && !pf.sizesSupported) {
          resCandidate = parseFloat(parseInt(curr, 10) / widthInCssPixels);
        } else if (lastchar === "x") {
          var res = curr && parseFloat(curr, 10);
          resCandidate = res && !isNaN(res) ? res : 1;
        }
      }
    }

    return resCandidate || 1;
  };
  /**
   * Takes a srcset in the form of url/
   * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
   *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
   *     "images/pic-small.png"
   * Get an array of image candidates in the form of
   *      {url: "/foo/bar.png", resolution: 1}
   * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
   * If sizes is specified, resolution is calculated
   */


  pf.getCandidatesFromSourceSet = function (srcset, sizes) {
    var candidates = pf.parseSrcset(srcset),
        formattedCandidates = [];

    for (var i = 0, len = candidates.length; i < len; i++) {
      var candidate = candidates[i];
      formattedCandidates.push({
        url: candidate.url,
        resolution: pf.parseDescriptor(candidate.descriptor, sizes)
      });
    }

    return formattedCandidates;
  };
  /**
   * if it's an img element and it has a srcset property,
   * we need to remove the attribute so we can manipulate src
   * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
   * this moves srcset's value to memory for later use and removes the attr
   */


  pf.dodgeSrcset = function (img) {
    if (img.srcset) {
      img[pf.ns].srcset = img.srcset;
      img.srcset = "";
      img.setAttribute("data-pfsrcset", img[pf.ns].srcset);
    }
  }; // Accept a source or img element and process its srcset and sizes attrs


  pf.processSourceSet = function (el) {
    var srcset = el.getAttribute("srcset"),
        sizes = el.getAttribute("sizes"),
        candidates = []; // if it's an img element, use the cached srcset property (defined or not)

    if (el.nodeName.toUpperCase() === "IMG" && el[pf.ns] && el[pf.ns].srcset) {
      srcset = el[pf.ns].srcset;
    }

    if (srcset) {
      candidates = pf.getCandidatesFromSourceSet(srcset, sizes);
    }

    return candidates;
  };

  pf.backfaceVisibilityFix = function (picImg) {
    // See: https://github.com/scottjehl/picturefill/issues/332
    var style = picImg.style || {},
        WebkitBackfaceVisibility = "webkitBackfaceVisibility" in style,
        currentZoom = style.zoom;

    if (WebkitBackfaceVisibility) {
      style.zoom = ".999";
      WebkitBackfaceVisibility = picImg.offsetWidth;
      style.zoom = currentZoom;
    }
  };

  pf.setIntrinsicSize = function () {
    var urlCache = {};

    var setSize = function setSize(picImg, width, res) {
      if (width) {
        picImg.setAttribute("width", parseInt(width / res, 10));
      }
    };

    return function (picImg, bestCandidate) {
      var img;

      if (!picImg[pf.ns] || w.pfStopIntrinsicSize) {
        return;
      }

      if (picImg[pf.ns].dims === undefined) {
        picImg[pf.ns].dims = picImg.getAttribute("width") || picImg.getAttribute("height");
      }

      if (picImg[pf.ns].dims) {
        return;
      }

      if (bestCandidate.url in urlCache) {
        setSize(picImg, urlCache[bestCandidate.url], bestCandidate.resolution);
      } else {
        img = doc.createElement("img");

        img.onload = function () {
          urlCache[bestCandidate.url] = img.width; //IE 10/11 don't calculate width for svg outside document

          if (!urlCache[bestCandidate.url]) {
            try {
              doc.body.appendChild(img);
              urlCache[bestCandidate.url] = img.width || img.offsetWidth;
              doc.body.removeChild(img);
            } catch (e) {}
          }

          if (picImg.src === bestCandidate.url) {
            setSize(picImg, urlCache[bestCandidate.url], bestCandidate.resolution);
          }

          picImg = null;
          img.onload = null;
          img = null;
        };

        img.src = bestCandidate.url;
      }
    };
  }();

  pf.applyBestCandidate = function (candidates, picImg) {
    var candidate, length, bestCandidate;
    candidates.sort(pf.ascendingSort);
    length = candidates.length;
    bestCandidate = candidates[length - 1];

    for (var i = 0; i < length; i++) {
      candidate = candidates[i];

      if (candidate.resolution >= pf.getDpr()) {
        bestCandidate = candidate;
        break;
      }
    }

    if (bestCandidate) {
      bestCandidate.url = pf.makeUrl(bestCandidate.url);

      if (picImg.src !== bestCandidate.url) {
        if (pf.restrictsMixedContent() && bestCandidate.url.substr(0, "http:".length).toLowerCase() === "http:") {
          if (window.console !== undefined) {
            console.warn("Blocked mixed content image " + bestCandidate.url);
          }
        } else {
          picImg.src = bestCandidate.url; // currentSrc attribute and property to match
          // http://picture.responsiveimages.org/#the-img-element

          if (!pf.curSrcSupported) {
            picImg.currentSrc = picImg.src;
          }

          pf.backfaceVisibilityFix(picImg);
        }
      }

      pf.setIntrinsicSize(picImg, bestCandidate);
    }
  };

  pf.ascendingSort = function (a, b) {
    return a.resolution - b.resolution;
  };
  /**
   * In IE9, <source> elements get removed if they aren't children of
   * video elements. Thus, we conditionally wrap source elements
   * using <!--[if IE 9]><video style="display: none;"><![endif]-->
   * and must account for that here by moving those source elements
   * back into the picture element.
   */


  pf.removeVideoShim = function (picture) {
    var videos = picture.getElementsByTagName("video");

    if (videos.length) {
      var video = videos[0],
          vsources = video.getElementsByTagName("source");

      while (vsources.length) {
        picture.insertBefore(vsources[0], video);
      } // Remove the video element once we're finished removing its children


      video.parentNode.removeChild(video);
    }
  };
  /**
   * Find all `img` elements, and add them to the candidate list if they have
   * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
   * a `srcset` attribute at all, and they haven’t been evaluated already.
   */


  pf.getAllElements = function () {
    var elems = [],
        imgs = doc.getElementsByTagName("img");

    for (var h = 0, len = imgs.length; h < len; h++) {
      var currImg = imgs[h];

      if (currImg.parentNode.nodeName.toUpperCase() === "PICTURE" || currImg.getAttribute("srcset") !== null || currImg[pf.ns] && currImg[pf.ns].srcset !== null) {
        elems.push(currImg);
      }
    }

    return elems;
  };

  pf.getMatch = function (img, picture) {
    var sources = picture.childNodes,
        match; // Go through each child, and if they have media queries, evaluate them

    for (var j = 0, slen = sources.length; j < slen; j++) {
      var source = sources[j]; // ignore non-element nodes

      if (source.nodeType !== 1) {
        continue;
      } // Hitting the `img` element that started everything stops the search for `sources`.
      // If no previous `source` matches, the `img` itself is evaluated later.


      if (source === img) {
        return match;
      } // ignore non-`source` nodes


      if (source.nodeName.toUpperCase() !== "SOURCE") {
        continue;
      } // if it's a source element that has the `src` property set, throw a warning in the console


      if (source.getAttribute("src") !== null && (typeof console === "undefined" ? "undefined" : _typeof(console)) !== undefined) {
        console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
      }

      var media = source.getAttribute("media"); // if source does not have a srcset attribute, skip

      if (!source.getAttribute("srcset")) {
        continue;
      } // if there's no media specified, OR w.matchMedia is supported


      if (!media || pf.matchesMedia(media)) {
        var typeSupported = pf.verifyTypeSupport(source);

        if (typeSupported === true) {
          match = source;
          break;
        } else if (typeSupported === "pending") {
          return false;
        }
      }
    }

    return match;
  };

  function picturefill(opt) {
    var elements,
        element,
        parent,
        firstMatch,
        candidates,
        options = opt || {};
    elements = options.elements || pf.getAllElements(); // Loop through all elements

    for (var i = 0, plen = elements.length; i < plen; i++) {
      element = elements[i];
      parent = element.parentNode;
      firstMatch = undefined;
      candidates = undefined; // immediately skip non-`img` nodes

      if (element.nodeName.toUpperCase() !== "IMG") {
        continue;
      } // expando for caching data on the img


      if (!element[pf.ns]) {
        element[pf.ns] = {};
      } // if the element has already been evaluated, skip it unless
      // `options.reevaluate` is set to true ( this, for example,
      // is set to true when running `picturefill` on `resize` ).


      if (!options.reevaluate && element[pf.ns].evaluated) {
        continue;
      } // if `img` is in a `picture` element


      if (parent && parent.nodeName.toUpperCase() === "PICTURE") {
        // IE9 video workaround
        pf.removeVideoShim(parent); // return the first match which might undefined
        // returns false if there is a pending source
        // TODO the return type here is brutal, cleanup

        firstMatch = pf.getMatch(element, parent); // if any sources are pending in this picture due to async type test(s)
        // remove the evaluated attr and skip for now ( the pending test will
        // rerun picturefill on this element when complete)

        if (firstMatch === false) {
          continue;
        }
      } else {
        firstMatch = undefined;
      } // Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.


      if (parent && parent.nodeName.toUpperCase() === "PICTURE" || !pf.sizesSupported && element.srcset && regWDesc.test(element.srcset)) {
        pf.dodgeSrcset(element);
      }

      if (firstMatch) {
        candidates = pf.processSourceSet(firstMatch);
        pf.applyBestCandidate(candidates, element);
      } else {
        // No sources matched, so we’re down to processing the inner `img` as a source.
        candidates = pf.processSourceSet(element);

        if (element.srcset === undefined || element[pf.ns].srcset) {
          // Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
          pf.applyBestCandidate(candidates, element);
        } // Else, resolution-only `srcset` is supported natively.

      } // set evaluated to true to avoid unnecessary reparsing


      element[pf.ns].evaluated = true;
    }
  }
  /**
   * Sets up picture polyfill by polling the document and running
   * the polyfill every 250ms until the document is ready.
   * Also attaches picturefill on resize
   */


  function runPicturefill() {
    pf.initTypeDetects();
    picturefill();
    var intervalId = setInterval(function () {
      // When the document has finished loading, stop checking for new images
      // https://github.com/ded/domready/blob/master/ready.js#L15
      picturefill();

      if (/^loaded|^i|^c/.test(doc.readyState)) {
        clearInterval(intervalId);
        return;
      }
    }, 250);
    var resizeTimer;

    var handleResize = function handleResize() {
      picturefill({
        reevaluate: true
      });
    };

    function checkResize() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(handleResize, 60);
    }

    if (w.addEventListener) {
      w.addEventListener("resize", checkResize, false);
    } else if (w.attachEvent) {
      w.attachEvent("onresize", checkResize);
    }
  }

  runPicturefill();
  /* expose methods for testing */

  picturefill._ = pf;
  expose(picturefill);
})(window, window.document, new window.Image());
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)(module)))

/***/ }),
/* 435 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = autocomplete;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_jquery_accessible_autocomplete_list_aria__ = __webpack_require__(436);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_jquery_json_to_datalist__ = __webpack_require__(437);



function autocomplete() {
  __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document).ready(function () {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.js-combobox-1').accessibleCombobox();
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.js-combobox-2').jsonToDatalist({
      callback: function callback(obj) {
        obj.accessibleCombobox({
          comboboxPrefixClass: 'combobox',
          comboboxHelpText: 'Utilisez les touches de tabulation ou la flèche du bas pour naviguer dans la liste du champ autocomplété. Confirmez votre choix avec la touche entrée, ou la touche échap pour fermer la liste de suggestions.',
          defaultClassForInvisibleText: 'invisible',
          suggestionSingle: 'Il y a ',
          suggestionPlural: 'Il y a ',
          suggestionWord: 'suggestion',
          comboboxButtonTitle: 'Effacer ce champ',
          comboboxButtonClearText: '<i class="fal fa-times"></i>',
          comboboxCaseSensitive: 'no',
          comboboxMinLength: 0,
          comboboxLimitNumberSuggestions: 666,
          comboboxSearchOption: 'containing',
          comboboxSeeMoreText: 'Plus de résultats…'
        });
      }
    });
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.js-combobox-3').jsonToDatalist({
      jsonPath: 'http://www.mocky.io/v2/5ab3e1ed2f00006000ca39f3',
      callback: function callback(obj) {
        obj.accessibleCombobox();
      }
    });
  });
}

/***/ }),
/* 436 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);

/*
 * jQuery accessible and keyboard-enhanced autocomplete list
 * @version v2.0.0
 * @author Nicolas Hoffmann
 * Website: https://a11y.nicolas-hoffmann.net/autocomplet-list/
 * License MIT: https://github.com/nico3333fr/jquery-accessible-autocomplete-list-aria/blob/master/LICENSE
 *
 * Modified by Steven Mouret
 */

__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.regExpEscape = function (s) {
  return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
};

function normalizeString(string) {
  var accents = 'ÀÁÂÃÄÅàáâãäåßÒÓÔÕÕÖØòóôõöøÈÉÊËèéêëðÇçÐÌÍÎÏìíîïÙÚÛÜùúûüÑñŠšŸÿýŽž';
  var accentsOut = 'AAAAAAaaaaaaBOOOOOOOooooooEEEEeeeeeCcDIIIIiiiiUUUUuuuuNnSsYyyZz';
  return string.split('').map(function (letter, index) {
    var accentIndex = accents.indexOf(letter);
    return accentIndex !== -1 ? accentsOut[accentIndex] : letter;
  }).join('');
}

__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.fn.extend({
  accessibleCombobox: function accessibleCombobox(options) {
    var defaults = {
      comboboxPrefixClass: 'combobox',
      comboboxHelpText: 'Use tabulation (or down) key to access and browse suggestions after input. Confirm your choice with enter key, or esc key to close suggestions box.',
      defaultClassForInvisibleText: 'invisible',
      suggestionSingle: 'There is ',
      suggestionPlural: 'There are ',
      suggestionWord: 'suggestion',
      comboboxButtonTitle: 'clear this field',
      comboboxButtonClearText: 'X',
      comboboxCaseSensitive: 'yes',
      comboboxMinLength: 0,
      comboboxLimitNumberSuggestions: 666,
      comboboxSearchOption: 'beginning',
      // or 'containing'
      comboboxSeeMoreText: 'See more results…'
    };
    var options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(defaults, options);
    var tablo_suggestions = [];

    function do_see_more_option() {
      var $output_content = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#js-codeit');
      $output_content.html('You have to code a function or a redirection to display more results ;)');
    }

    this.each(function (index_combo) {
      var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
          objData = $this.data(),
          o = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(true, {}, options, objData);
      var $this_id = $this.attr('id'),
          $label_this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('label[for="' + $this_id + '"]'),
          index_lisible = index_combo + 1,
          $combobox_prefix_class = o.comboboxPrefixClass + '-',
          default_class_for_invisible_text = o.defaultClassForInvisibleText,
          $combobox_help_text = o.comboboxHelpText,
          $list_suggestions = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + $this.attr('list')),
          $combobox_button_title = o.comboboxButtonTitle,
          $combobox_button_text = o.comboboxButtonClearText,
          $combobox_case_sensitive = o.comboboxCaseSensitive,
          tablo_temp_suggestions = []; // input

      $this.attr({
        'data-number': index_lisible,
        'autocorrect': 'off',
        'autocapitalize': 'off',
        'spellcheck': 'false',
        'autocomplete': 'off',
        'aria-describedby': $combobox_prefix_class + 'help-text' + index_lisible,
        'aria-autocomplete': 'list',
        'data-lastval': '',
        'aria-owns': $combobox_prefix_class + 'suggest_' + index_lisible
      }); // stock into array

      $list_suggestions.find('option').each(function (index_option, index_element) {
        tablo_temp_suggestions.push(index_element.value);
      });

      if ($combobox_case_sensitive === 'no') {
        // order case tablo_temp_suggestions
        tablo_suggestions[index_lisible] = tablo_temp_suggestions.sort(function (a, b) {
          a = a.toLowerCase();
          b = b.toLowerCase();

          if (a == b) {
            return 0;
          }

          if (a > b) {
            return 1;
          }

          return -1;
        });
      } else {
        tablo_suggestions[index_lisible] = tablo_temp_suggestions.sort();
      } // wrap into a container


      $this.wrap('<div class="' + $combobox_prefix_class + 'container js-container" data-combobox-prefix-class="' + $combobox_prefix_class + '"></div>');
      var $combobox_container = $this.parent(); // custom datalist/listbox linked to input

      $combobox_container.append('<div id="' + $combobox_prefix_class + 'suggest_' + index_lisible + '" class="js-suggest ' + $combobox_prefix_class + 'suggestions"><div role="listbox"></div></div>');
      $list_suggestions.remove(); // status zone

      $combobox_container.prepend('<div id="' + $combobox_prefix_class + 'suggestion-text' + index_lisible + '" class="js-suggestion-text ' + $combobox_prefix_class + 'suggestion-text ' + default_class_for_invisible_text + '" aria-live="assertive"></div>'); // help text

      $combobox_container.prepend('<span id="' + $combobox_prefix_class + 'help-text' + index_lisible + '" class="' + $combobox_prefix_class + 'help-text ' + default_class_for_invisible_text + '">' + $combobox_help_text + '</span>'); // label id

      $label_this.attr('id', 'label-id-' + $this_id); // button clear

      $this.after('<button class="js-clear-button ' + $combobox_prefix_class + 'clear-button" aria-label="' + $combobox_button_title + '" title="' + $combobox_button_title + '" aria-describedby="label-id-' + $this_id + '" type="button">' + $combobox_button_text + '</button>'); // listeners
      // keydown on field

      $this.on('keyup', function (event) {
        //console.log('keyup');
        var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
            $container = $this.parent(),
            $form = $container.parents('form'),
            options = $container.data(),
            $combobox_prefix_class = typeof options.comboboxPrefixClass !== 'undefined' ? options.comboboxPrefixClass : '',
            // no "-"" because already generated
        $suggestions = $container.find('.js-suggest div'),
            $suggestions_text = $container.find('.js-suggestion-text'),
            $combobox_suggestion_single = o.suggestionSingle,
            $combobox_suggestion_plural = o.suggestionPlural,
            $combobox_suggestion_word = o.suggestionWord,
            combobox_min_length = o.comboboxMinLength,
            combobox_limit_number_suggestions = o.comboboxLimitNumberSuggestions,
            $combobox_search_option = o.comboboxSearchOption,
            $combobox_see_more_text = o.comboboxSeeMoreText,
            index_table = $this.attr('data-number'),
            value_to_search = normalizeString($this.val()),
            text_number_suggestions = '';

        if (event.keyCode === 13) {
          $form.submit();
        } else {
          if (event.keyCode !== 27) {
            // No Escape
            $this.attr('data-lastval', value_to_search); // search for text suggestion in the array tablo_suggestions[index_table]

            var size_tablo = tablo_suggestions[index_table].length,
                i = 0,
                counter = 0;
            $suggestions.empty();

            if (value_to_search != '' && value_to_search.length >= combobox_min_length) {
              while (i < size_tablo) {
                if (counter < combobox_limit_number_suggestions) {
                  if ($combobox_search_option === 'containing' && $combobox_case_sensitive === 'yes' && normalizeString(tablo_suggestions[index_table][i]).indexOf(value_to_search) >= 0 || $combobox_case_sensitive === 'no' && normalizeString(tablo_suggestions[index_table][i]).toUpperCase().indexOf(value_to_search.toUpperCase()) >= 0 || $combobox_search_option === 'beginning' && $combobox_case_sensitive === 'yes' && normalizeString(tablo_suggestions[index_table][i]).substring(0, value_to_search.length) === value_to_search || $combobox_case_sensitive === 'no' && normalizeString(tablo_suggestions[index_table][i]).substring(0, value_to_search.length).toUpperCase() === value_to_search.toUpperCase()) {
                    var html = '';

                    if (value_to_search.trim() === '') {
                      html = tablo_suggestions[index_table][i];
                    } else {
                      var normalizedSuggestion = normalizeString(tablo_suggestions[index_table][i]);
                      var value = normalizeString($this.val().trim());

                      if (value) {
                        var startPos = normalizedSuggestion.toLowerCase().indexOf(value.toLowerCase());
                        var endPos = startPos + value.length;
                        var restStringIndex = -(tablo_suggestions[index_table][i].length - endPos);

                        if (startPos > -1) {
                          var partToReplace = '<mark>' + tablo_suggestions[index_table][i].slice(startPos, endPos) + '</mark>';
                          var wordsArray = tablo_suggestions[index_table][i].split('');
                          wordsArray.splice(startPos, value.length, partToReplace);
                          html = wordsArray.join('');
                        }
                      }
                    }

                    $suggestions.append('<div id="suggestion-' + index_table + '-' + counter + '" class="js-suggestion ' + $combobox_prefix_class + 'suggestion" tabindex="-1" role="option">' + html + '</div>');
                    counter++;
                  }
                }

                i++;
              }

              if (counter >= combobox_limit_number_suggestions) {
                $suggestions.append('<div id="suggestion-' + index_table + '-' + counter + '" class="js-suggestion js-seemore ' + $combobox_prefix_class + 'suggestion" tabindex="-1" role="option">' + $combobox_see_more_text + '</div>');
                counter++;
              } // update number of suggestions


              if (counter > 1) {
                text_number_suggestions = $combobox_suggestion_plural + counter + ' ' + $combobox_suggestion_word + 's.';
              }

              if (counter === 1) {
                text_number_suggestions = $combobox_suggestion_single + counter + ' ' + $combobox_suggestion_word + '.';
              }

              if (counter === 0) {
                text_number_suggestions = $combobox_suggestion_single + counter + ' ' + $combobox_suggestion_word + '.';
              }

              if (counter >= 0) {
                var text_number_suggestions_default = $suggestions_text.text();

                if (text_number_suggestions != text_number_suggestions_default) {
                  // @Goestu trick to make it work on all AT
                  var suggestions_to_add = __WEBPACK_IMPORTED_MODULE_0_jquery___default()("<p>").text(text_number_suggestions);
                  $suggestions_text.attr('aria-live', 'polite');
                  $suggestions_text.empty();
                  $suggestions_text.append(suggestions_to_add);
                }
              }
            }
          }
        }
      }).on('click', function (event) {
        //console.log('click');
        var $target = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(event.target),
            $suggestions_text = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.js-suggestion-text:not(:empty)'),
            // if a suggestion text is not empty => suggestion opened somewhere
        $container = $suggestions_text.parents('.js-container'),
            $input_text = $container.find('.js-combobox'),
            $suggestions = $container.find('.js-suggest div'); // if click outside => close opened suggestions

        if (!$target.is('.js-suggestion') && !$target.is('.js-combobox') && $suggestions_text.length) {
          $input_text.val($input_text.attr('data-lastval'));
          $suggestions.empty();
          $suggestions_text.empty();
        }
      }) // tab + down management for autocomplete (when list of suggestion)
      .on('keydown', function (event) {
        //console.log('keydown');
        var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
            $container = $this.parent(),
            $input_text = $container.find('.js-combobox'),
            $suggestions = $container.find('.js-suggest div'),
            $suggestion_list = $suggestions.find('.js-suggestion'),
            $suggestions_text = $container.find('.js-suggestion-text'),
            $autorise_tab_options = typeof $this.attr('data-combobox-notab-options') !== 'undefined' ? false : true,
            $first_suggestion = $suggestion_list.first();

        if (!event.shiftKey && event.keyCode == 9 && $autorise_tab_options || event.keyCode == 40) {
          // tab (if authorised) or bottom
          // See if there are suggestions, and yes => focus on first one
          if ($suggestion_list.length) {
            $input_text.val($first_suggestion.html().replace(/<mark>|<\/mark>/gi, ''));
            $suggestion_list.first().focus();
            event.preventDefault();
          }
        }

        if (event.keyCode == 27 || $autorise_tab_options === false && event.keyCode == 9) {
          // esc or (tab/shift tab + notab option) = close
          $input_text.val($input_text.attr('data-lastval').replace(/<mark>|<\/mark>/gi, ''));
          $suggestions.empty();
          $suggestions_text.empty();

          if (event.keyCode == 27) {
            // Esc prevented only, tab can go :)
            event.preventDefault();
            setTimeout(function () {
              $input_text.focus();
            }, 300); // timeout to avoid problem in suggestions display
          }
        }
      }); // tab + down management in list of suggestions

      $this.parent().on('keydown', '.js-suggestion', function (event) {
        //console.log('keydown js-suggestion');
        var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
            $container = $this.parents('.js-container'),
            $input_text = $container.find('.js-combobox'),
            $autorise_tab_options = typeof $input_text.attr('data-combobox-notab-options') !== 'undefined' ? false : true,
            $suggestions = $container.find('.js-suggest div'),
            $suggestions_text = $container.find('.js-suggestion-text'),
            $next_suggestion = $this.next(),
            $previous_suggestion = $this.prev();

        if (event.keyCode == 27 || $autorise_tab_options === false && event.keyCode == 9) {
          // esc or (tab/shift tab + notab option) = close
          if (event.keyCode == 27) {
            // Esc prevented only, tab can go :)
            $input_text.val($input_text.attr('data-lastval').replace(/<mark>|<\/mark>/gi, ''));
            $suggestions.empty();
            $suggestions_text.empty();
            setTimeout(function () {
              $input_text.focus();
            }, 300); // timeout to avoid problem in suggestions display

            event.preventDefault();
          }

          if ($autorise_tab_options === false && event.keyCode == 9) {
            $suggestions.empty();
            $suggestions_text.empty();
            $input_text.focus();
          }
        }

        if (event.keyCode == 13 || event.keyCode == 32) {
          // Enter or space
          if ($this.hasClass('js-seemore')) {
            $input_text.val($input_text.attr('data-lastval').replace(/<mark>|<\/mark>/gi, ''));
            $suggestions.empty();
            $suggestions_text.empty();
            setTimeout(function () {
              $input_text.focus();
            }, 300); // timeout to avoid problem in suggestions display
            // go define the function you need when we click the see_more option

            setTimeout(function () {
              do_see_more_option();
            }, 301); // timeout to avoid problem in suggestions display

            event.preventDefault();
          } else {
            $input_text.val($this.html().replace(/<mark>|<\/mark>/gi, ''));
            $input_text.attr('data-lastval', $this.html().replace(/<mark>|<\/mark>/gi, ''));
            $suggestions.empty();
            $suggestions_text.empty();
            setTimeout(function () {
              $input_text.focus();
            }, 300); // timeout to avoid problem in suggestions display

            event.preventDefault();
          }
        }

        if (!event.shiftKey && event.keyCode == 9 && $autorise_tab_options || event.keyCode == 40) {
          // tab (if authorised) or bottom
          if ($next_suggestion.length) {
            $input_text.val($next_suggestion.html().replace(/<mark>|<\/mark>/gi, ''));
            $next_suggestion.focus();
          } else {
            $input_text.val($input_text.attr('data-lastval').replace(/<mark>|<\/mark>/gi, ''));

            if (!event.shiftKey && event.keyCode == 9) {
              // tab closes the list
              var e = jQuery.Event("keydown");
              e.which = 27; // # Some key code value

              e.keyCode = 27;
              $this.trigger(e);
            } else {
              setTimeout(function () {
                $input_text.focus();
              }, 300);
            } // timeout to avoid problem in suggestions display

          }

          event.preventDefault();
        }

        if (event.shiftKey && event.keyCode == 9 && $autorise_tab_options || event.keyCode == 38) {
          // top or Maj+tab (if authorised)
          if ($previous_suggestion.length) {
            $input_text.val($previous_suggestion.html().replace(/<mark>|<\/mark>/gi, ''));
            $previous_suggestion.focus();
          } else {
            $input_text.val($input_text.attr('data-lastval')).focus();
          }

          event.preventDefault();
        }
      }) // clear button
      .on('click', '.js-clear-button', function () {
        //console.log('click js-clear-button');
        var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
            $container = $this.parent(),
            $input_text = $container.find('.js-combobox'),
            $suggestions = $container.find('.js-suggest div'),
            $suggestions_text = $container.find('.js-suggestion-text');
        $suggestions.empty();
        $suggestions_text.empty();
        $input_text.val('');
        $input_text.attr('data-lastval', '');
      }).on('click', '.js-suggestion', function () {
        //console.log('click js-suggestion');
        var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
            value = $this.html().replace(/<mark>|<\/mark>/gi, ''),
            $container = $this.parents('.js-container'),
            $input_text = $container.find('.js-combobox'),
            $suggestions = $container.find('.js-suggest div'),
            $suggestions_text = $container.find('.js-suggestion-text');

        if ($this.hasClass('js-seemore')) {
          $suggestions.empty();
          $suggestions_text.empty();
          $input_text.focus(); // go define the function you need when we click the see_more option

          do_see_more_option();
        } else {
          $input_text.val(value).focus();
          $suggestions.empty();
          $suggestions_text.empty();
        }
      });
    }); // End each
  } // End plugin

});

/***/ }),
/* 437 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);

/*
 * jQuery json to datalist
 * @version 0.1.0
 * @author Steven Mouret
 * License MIT
 */

__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.fn.extend({
  jsonToDatalist: function jsonToDatalist(options) {
    var defaults = {
      jsonPath: null,
      callback: function callback() {}
    };
    var options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(defaults, options);
    this.each(function () {
      var $this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),
          objData = $this.data(),
          o = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(true, {}, options, objData);
      var jsonPath = o.jsonPath,
          $this_list = $this.attr('list');

      if (jsonPath) {
        __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.getJSON(jsonPath, function (data) {
          // Save option in array
          var items = [];
          __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(data, function (key, val) {
            items.push('<option value="' + val.name + '">');
          }); // Add datalist

          __WEBPACK_IMPORTED_MODULE_0_jquery___default()("<datalist/>", {
            "id": $this_list,
            html: items.join("")
          }).insertAfter($this);
          o.callback.call(this, $this);
        });
      } else {
        console.log('JSON path is empty or null.');
      }
    });
  }
});

/***/ }),
/* 438 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initPreloader;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);

function initPreloader() {
  var preloader = document.getElementById('preloader');

  if (preloader !== null) {
    setTimeout(function () {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](preloader, '-is-hidden');
      preloader.setAttribute('aria-hidden', true);
    }, 500);
  }
}

/***/ }),
/* 439 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Megamenu; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Class represents Menu.
 */

var Menu =
/*#__PURE__*/
function () {
  /**
   * Create base for menu.
   * @param {string} selector - selector for megamenu.
   */
  function Menu(selector) {
    _classCallCheck(this, Menu);

    this.selector = selector;
    this.wrapper = null;
    this.list = null;
    this.items = null;
    this.itemsWithDropdown = null;
    this.links = null;
    this.toggles = null;
    this.submenus = null;
    this.dropdownWrappers = null;
    this.dropdownContainers = null;
    this.dropdownCloseButtons = null;
    this.closeButton = null;
    this.openerButton = null;
    this.lastClickedLink = null;
    this.lastEvent = null;
    this.menuPosition = null;
    this.comments = {};
    this.options = {
      menu: {
        type: 'aside',
        className: 'js-mnv',
        listClassName: 'js-mnv-list',
        itemClassName: 'js-mnv-item',
        itemWithDropdownClassName: 'js-mnv-item-has-dropdown',
        linkClassName: 'js-mnv-link',
        wrapperClassName: 'js-mnv-wrapper',
        dropdownWrapperClassName: 'js-mnv-dropdown-wrapper',
        dropdownContainerClassName: 'js-mnv-dropdown-container',
        dropdownCloseClassName: 'js-mnv-dropdown-close',
        submenuClassName: 'js-mnv-submenu',
        toggleClassName: 'js-mnv-submenu-toggle',
        openedClassName: '-is-open',
        generatedClassName: '-is-generated',
        currentClassName: ['-is-current', 'is-active']
      },
      overlay: {
        show: true,
        text: 'Close',
        className: 'js-mnv-overlay'
      },
      closeButton: {
        show: true,
        text: 'Close',
        className: 'js-mnv-close'
      },
      openerButton: {
        show: true,
        text: '',
        className: 'js-mnv-toggle'
      },
      body: {
        openedClassName: 'mnv-opened'
      },
      breakpoints: ['tablet', 'smartphone'],
      replaceTo: 'site-header',
      rebuildMenu: [],
      initSubmenuToggles: ['tablet', 'smartphone'],
      closeAllChildren: false,
      submenusHandler: {
        closeAllBeforeOpen: false,
        breakpoints: ['desktop']
      },
      emitInsideHandlerFor: '',
      focusTrap: {
        init: true,
        closeOnLastElementOut: false
      },
      messages: {
        close: 'Close'
      }
    };
  }
  /**
   * Get menu wrapper.
   * @returns {node} - Wrapper dom node.
   */


  _createClass(Menu, [{
    key: "getMenuWrapper",
    value: function getMenuWrapper() {
      return this.selector.children[0];
    }
    /**
     * Get menu dropdown wrappers.
     * @returns {array} - Nodes array of dropdown wrappers.
     */

  }, {
    key: "getMenuDropdownWrappers",
    value: function getMenuDropdownWrappers() {
      if (this.items) {
        return this.items.filter(function (item) {
          return item.querySelector('div');
        }).map(function (item) {
          return item.querySelector('div');
        });
      }

      this.items = this.getMenuItems();
      return this.items ? this.getMenuDropdownWrappers() : null;
    }
    /**
     * Get menu dropdown containers.
     * @returns {array} - Nodes array of dropdown containers.
     */

  }, {
    key: "getMenuDropdownContainers",
    value: function getMenuDropdownContainers() {
      if (this.dropdownWrappers) {
        return this.dropdownWrappers.map(function (wrapper) {
          return wrapper.querySelector('div');
        });
      }

      this.dropdownWrappers = this.getMenuDropdownWrappers();
      return this.dropdownWrappers ? this.getMenuDropdownContainers() : null;
    }
    /**
     * Get all dropdown close buttons inside menu list.
     * @returns {array} - Nodes array of dropdown close buttons.
     */

  }, {
    key: "getMenuDropdownCloseButtons",
    value: function getMenuDropdownCloseButtons() {
      if (this.dropdownContainers) {
        return this.dropdownContainers.map(function (container) {
          return container.querySelector('button');
        });
      }

      this.dropdownContainers = this.getMenuDropdownContainers();
      return this.dropdownContainers ? this.getMenuDropdownCloseButtons() : null;
    }
    /**
     * Get main menu list node.
     * @returns {Node} - Menu list node.
     */

  }, {
    key: "getMenuList",
    value: function getMenuList() {
      if (this.wrapper) {
        return this.wrapper.querySelector('ul');
      }

      return this.getMenuWrapper().querySelector('ul');
    }
    /**
     * Get all menu items.
     * @returns {array} - Items array.
     */

  }, {
    key: "getMenuItems",
    value: function getMenuItems() {
      return _toConsumableArray(this.list.querySelectorAll('li'));
    }
    /**
     * Get all menu items which has submenus.
     * @returns {array} - Items with dropdowns array.
     */

  }, {
    key: "getMenuItemsWithDropdown",
    value: function getMenuItemsWithDropdown() {
      if (this.items) {
        return this.items.filter(function (item) {
          return item.querySelector('ul');
        });
      }

      this.items = this.getMenuItems();
      return this.items ? this.getMenuItemsWithDropdown() : null;
    }
    /**
     * Get all menu links
     * @returns {array} - Links array.
     */

  }, {
    key: "getMenuLinks",
    value: function getMenuLinks() {
      return _toConsumableArray(this.list.querySelectorAll('a'));
    }
    /**
     * Get all menu toggels (buttons which manipulates submenus)
     * @returns {array} - Toggels array.
     */

  }, {
    key: "getMenuToggles",
    value: function getMenuToggles() {
      return _toConsumableArray(this.list.querySelectorAll("button:not(.".concat(this.options.closeButton.className, ")")));
    }
    /**
     * Get all submenus.
     * @returns {array} - Submenus array.
     */

  }, {
    key: "getMenuSubmenus",
    value: function getMenuSubmenus() {
      if (this.items) {
        return this.items.filter(function (item) {
          return item.querySelector('ul');
        }).map(function (item) {
          return item.querySelector('ul');
        });
      }

      this.items = this.getMenuItems();
      return this.items ? this.getMenuSubmenus() : null;
    }
    /**
     * Get close button for all menu.
     * @returns {node} - Close menu button node.
     */

  }, {
    key: "getCloseButton",
    value: function getCloseButton() {
      return this.selector.querySelector(".".concat(this.options.closeButton.className));
    }
    /**
     * Get opener button for all menu.
     * @returns {node} - Opener button node.
     */

  }, {
    key: "getOpenerButton",
    value: function getOpenerButton() {
      return document.querySelector(".".concat(this.options.openerButton.className));
    }
    /**
     * Get menu overlay.
     * @returns {node|null} - Overlay node or null if we haven't it.
     */

  }, {
    key: "getOverlay",
    value: function getOverlay() {
      var element = this.selector.nextElementSibling;

      if (element && __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](element, this.options.overlay.className)) {
        return element;
      }

      return null;
    }
    /**
     * Get all focusable elements on the top level menu.
     * @returns {array} - Nodes array of focusable elements.
     */

  }, {
    key: "getFirstLevelFocusableElements",
    value: function getFirstLevelFocusableElements() {
      var _this = this;

      if (this.list) {
        var elements = __WEBPACK_IMPORTED_MODULE_0__helpers__["i" /* getFocusableElements */](this.list);

        if (elements) {
          var depth = 10000;
          return elements.filter(function (element) {
            var index = Menu.getDepthIndex(element, _this.selector);

            if (index <= depth) {
              depth = index;
              return element;
            }

            return false;
          });
        }
      }

      this.list = this.getMenuList();
      return this.list ? this.getFirstLevelFocusableElements() : null;
    }
    /**
     * Get first level links.
     * @returns {array} - Nodes array of first level links.
     */

  }, {
    key: "getFirstLevelLinks",
    value: function getFirstLevelLinks() {
      var _this2 = this;

      if (this.links) {
        var depth = 10000;
        return this.links.filter(function (link) {
          var index = Menu.getDepthIndex(link, _this2.selector);

          if (index <= depth) {
            depth = index;
            return link;
          }

          return false;
        });
      }

      this.links = this.getMenuLinks();
      return this.links ? this.getFirstLevelLinks() : null;
    }
    /**
     * Get all opened items.
     * @returns {array} - Nodes array of opened items.
     */

  }, {
    key: "getOpenedItems",
    value: function getOpenedItems() {
      var _this3 = this;

      return this.items.filter(function (item) {
        return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](item, _this3.options.menu.openedClassName);
      });
    }
    /**
     * Get all opened submenus.
     * @returns {array} - Nodes array of opened submenus.
     */

  }, {
    key: "getOpenedSubmenus",
    value: function getOpenedSubmenus() {
      var _this4 = this;

      return this.submenus.filter(function (submenu) {
        return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](submenu.parentNode, _this4.options.menu.openedClassName);
      });
    }
    /**
     * Get opened children inside element.
     * @param element {node} - element in which we should search.
     * @returns {array} - Array of opened items inside element.
     */

  }, {
    key: "getOpenedChildren",
    value: function getOpenedChildren(element) {
      var _this5 = this;

      var children = _toConsumableArray(element.children);

      if (children) {
        return children.filter(function (item) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](item, _this5.options.menu.openedClassName);
        });
      }

      return null;
    }
    /**
     * Set class to elements.
     * @param elements {array} - Array of elements.
     * @param className {string} - Class which need to add.
     */

  }, {
    key: "setElementsClass",
    value: function setElementsClass(elements, className) {
      if (elements) {
        elements.forEach(function (element) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, className);
        });
      }
    }
    /**
     * Create new overlay element.
     * @returns {HTMLElement} - New overlay element.
     */

  }, {
    key: "createOverlay",
    value: function createOverlay() {
      var element = document.createElement('div');
      element.innerHTML = "<span class=\"ghost\">".concat(this.options.overlay.text, "</span>");
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, this.options.overlay.className);
      return element;
    }
    /**
     * Create new close button element.
     * @param html {string} - String or markup to put inside close button.
     * @returns {HTMLElement} - New close button.
     */

  }, {
    key: "createCloseButton",
    value: function createCloseButton(html) {
      var button = document.createElement('button');
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](button, this.options.closeButton.className);
      button.setAttribute('type', 'button');
      button.innerHTML = html || this.options.closeButton.text;
      return button;
    }
    /**
     * Add close button before/after element.
     * @param element {node} - node before/after we should paste.
     * @param position {string} - position to insert.
     */

  }, {
    key: "addCloseButton",
    value: function addCloseButton(element, position) {
      this.closeButton = this.createCloseButton();

      if (position === 'before') {
        element.parentNode.insertBefore(this.closeButton, element);
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["q" /* insertAfter */](this.closeButton, element);
      }
    }
    /**
     * Add overlay after menu.
     */

  }, {
    key: "addOverlay",
    value: function addOverlay() {
      if (this.overlay) {
        return __WEBPACK_IMPORTED_MODULE_0__helpers__["q" /* insertAfter */](this.overlay, this.selector);
      }

      this.overlay = this.createOverlay();
      return __WEBPACK_IMPORTED_MODULE_0__helpers__["q" /* insertAfter */](this.overlay, this.selector);
    }
    /**
     * Insert toggle button after node.
     * @param node {node} - node after we must insert.
     * @returns {HTMLElement} - inserted toggle.
     */

  }, {
    key: "addToggleAfter",
    value: function addToggleAfter(node) {
      if (node) {
        var toggle = this.createToggle(node.textContent);
        __WEBPACK_IMPORTED_MODULE_0__helpers__["q" /* insertAfter */](toggle, node);
        return toggle;
      }
    }
    /**
     * Insert toggle button before node.
     * @param node {node} - node before we must insert.
     * @returns {HTMLElement} - inserted toggle.
     */

  }, {
    key: "addToggleBefore",
    value: function addToggleBefore(node) {
      if (node) {
        var toggle = this.createToggle(node.textContent);
        node.parentNode.insertBefore(toggle, node);
        return toggle;
      }
    }
    /**
     * Create new toggle button.
     * @param text {string} - text inside toggle button.
     * @returns {HTMLElement} - Toggle element.
     */

  }, {
    key: "createToggle",
    value: function createToggle(text) {
      var toggle = document.createElement('button');
      toggle.setAttribute('type', 'button');
      toggle.innerHTML = "<span class=\"ghost\">".concat(text, "</span>");
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](toggle, this.options.menu.toggleClassName);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](toggle, this.options.menu.generatedClassName);
      return toggle;
    }
    /**
     * Regenerate overlay.
     */

  }, {
    key: "setOverlay",
    value: function setOverlay() {
      var _this6 = this;

      if (this.options.overlay) {
        this.onResponsive(this.options.overlay.show, function () {
          _this6.addOverlay();
        }, function () {
          _this6.overlay = _this6.getOverlay();

          _this6.removeElement(_this6.overlay);
        });
      }
    }
    /**
     * Generate close button if needs.
     */

  }, {
    key: "setCloseButton",
    value: function setCloseButton() {
      if (this.options.closeButton) {
        this.closeButton = this.getCloseButton();

        if (!this.closeButton) {
          this.addCloseButton(this.list, 'before');
        }
      }
    }
    /**
     * Remove element from dom.
     * @param element {node} - node to remove.
     */

  }, {
    key: "removeElement",
    value: function removeElement(element) {
      if (element) {
        element.parentNode.removeChild(element);
      }
    }
    /**
     * Set class to element.
     * @param element {node} - element node.
     * @param className {string} - Class to add.
     */

  }, {
    key: "setElementClass",
    value: function setElementClass(element, className) {
      if (element) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, className);
      }
    }
    /**
     * Remove class from elements.
     * @param elements {array} - elements array.
     * @param className {string} - Class to remove
     */

  }, {
    key: "removeElementsClass",
    value: function removeElementsClass(elements, className) {
      if (elements) {
        elements.forEach(function (element) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, className);
        });
      }
    }
    /**
     * Remove class from element.
     * @param element {node} - element node.
     * @param className {string} - Class to remove
     */

  }, {
    key: "removeElementClass",
    value: function removeElementClass(element, className) {
      if (element) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, className);
      }
    }
    /**
     * Set helper class names for all megamenu elements.
     */

  }, {
    key: "setClassNames",
    value: function setClassNames() {
      // Add helper class for menu element
      this.setElementClass(this.selector, this.options.menu.className); // Add helper class for menu inner wrapper

      this.wrapper = this.selector.children[0];
      this.setElementClass(this.wrapper, this.options.menu.wrapperClassName); // Add helper class for menu list

      this.list = this.getMenuList();
      this.setElementClass(this.list, this.options.menu.listClassName); // Add helper class for menu items

      this.items = this.getMenuItems();
      this.setElementsClass(this.items, this.options.menu.itemClassName); // Add helper class for menu items with dropdown

      this.itemsWithDropdown = this.getMenuItemsWithDropdown();
      this.setElementsClass(this.itemsWithDropdown, this.options.menu.itemWithDropdownClassName); // Add helper class for menu links

      this.links = this.getMenuLinks();
      this.setElementsClass(this.links, this.options.menu.linkClassName); // Add helper class for toggle buttons

      this.toggles = this.getMenuToggles();
      this.setElementsClass(this.toggles, this.options.menu.toggleClassName); // Add helper class for submenus

      this.submenus = this.getMenuSubmenus();
      this.setElementsClass(this.submenus, this.options.menu.submenuClassName); // Add helper class for dropdown wrappers

      this.dropdownWrappers = this.getMenuDropdownWrappers();
      this.setElementsClass(this.dropdownWrappers, this.options.menu.dropdownWrapperClassName); // Add helper class for dropdown containers

      this.dropdownContainers = this.getMenuDropdownContainers();
      this.setElementsClass(this.dropdownContainers, this.options.menu.dropdownContainerClassName); // Add helper class for dropdown close buttons

      this.dropdownCloseButtons = this.getMenuDropdownCloseButtons();
      this.setElementsClass(this.dropdownCloseButtons, this.options.menu.dropdownCloseClassName);
    }
    /**
     * Get current link.
     * @returns {array} - current link array (because we have different classes with drupal).
     */

  }, {
    key: "getCurrentLink",
    value: function getCurrentLink() {
      var _this7 = this;

      return this.options.menu.currentClassName.map(function (className) {
        return _this7.selector.querySelector("a.".concat(className));
      });
    }
    /**
     * Add attributes for current link and all parents.
     */

  }, {
    key: "initCurrent",
    value: function initCurrent() {
      var current = this.getCurrentLink()[0];

      if (current) {
        var parent = current.parentNode;
        current.setAttribute('aria-current', 'page');

        while (!__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](parent, this.options.menu.wrapperClassName)) {
          if (__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](parent, this.options.menu.itemClassName)) {
            var link = parent.querySelector(".".concat(this.options.menu.linkClassName));
            var toggle = parent.querySelector(".".concat(this.options.menu.toggleClassName));

            if (link !== current) {
              link.setAttribute('aria-current', true);
            }

            parent.setAttribute('data-has-current', true); // this.onResponsive(this.options.breakpoints, () => {
            //     if (toggle) {
            //         toggle.click();
            //     }
            //
            //     this.setElementClass(parent, this.options.menu.openedClassName);
            // }, () => {
            //     if (helpers.hasClass(parent, this.options.menu.openedClassName) && toggle) {
            //         toggle.click();
            //     }
            // });
          }

          parent = parent.parentNode;
        }
      }
    }
    /**
     * Open submenu and change a11y for it.
     * @param item {node} - Toggle button connected with submenu.
     */

  }, {
    key: "openSubmenu",
    value: function openSubmenu(item) {
      var _this8 = this;

      var parent = item.parentNode;
      var submenu = parent.querySelector('ul');

      var children = _toConsumableArray(submenu.children);

      if (this.options.submenusHandler.closeAllBeforeOpen) {
        var siblings = __WEBPACK_IMPORTED_MODULE_0__helpers__["k" /* getSiblings */](parent);
        this.onResponsive(this.options.submenusHandler.breakpoints, function () {
          if (siblings.length) {
            siblings.filter(function (siblingItem) {
              return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](siblingItem, _this8.options.menu.openedClassName);
            }).map(function (openedItem) {
              return openedItem.querySelector(".".concat(_this8.options.menu.toggleClassName));
            }).forEach(function (toggle) {
              return _this8.closeSubmenu(toggle);
            });
          }
        });
      }

      this.setElementClass(parent, this.options.menu.openedClassName);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](item, submenu, 'opened');
      children.forEach(function (child) {
        return __WEBPACK_IMPORTED_MODULE_0__helpers__["z" /* setChildrenTabindex */](child, 0);
      });

      if (this.getOpenedItems().length) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](this.list, this.options.menu.openedClassName);
      }
    }
    /**
     * Close submenu and change a11y for it.
     * @param item {node} - Toggle button connected with submenu.
     */

  }, {
    key: "closeSubmenu",
    value: function closeSubmenu(item) {
      var _this9 = this;

      var parent = item.parentNode;
      var submenu = parent.querySelector('ul');

      var children = _toConsumableArray(submenu.children);

      this.removeElementClass(parent, this.options.menu.openedClassName);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](item, submenu, 'closed');
      children.forEach(function (child) {
        return __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](child, -1);
      }); // Close all child submenus if you hide parent

      if (this.options.closeAllChildren) {
        children.filter(function (child) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](child, _this9.options.menu.openedClassName);
        }).forEach(function (child) {
          var childToggle = child.querySelector(".".concat(_this9.options.menu.toggleClassName));
          return childToggle ? _this9.closeSubmenu(childToggle) : null;
        });
      }

      if (!this.getOpenedItems().length) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](this.list, this.options.menu.openedClassName);
      }
    }
    /**
     * Toggle between open/close submenu.
     * @param event - Browser event.
     */

  }, {
    key: "toggleSubmenu",
    value: function toggleSubmenu(event) {
      var item = __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](event.target, this.options.menu.toggleClassName) ? event.target : __WEBPACK_IMPORTED_MODULE_0__helpers__["g" /* findAncestor */](event.target, this.options.menu.toggleClassName);
      return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](item.parentNode, this.options.menu.openedClassName) ? this.closeSubmenu(item) : this.openSubmenu(item);
    }
    /**
     * Function which checks resolution and execute success or backwards function.
     * @param param {array} - array of resolutions ['desktop', 'tablet', 'mobile']
     * @param success {function} - function wich executes if your resolution matches with param.
     * @param backwards {function} - function wich executes if your resolution not matches with param.
     */

  }, {
    key: "onResponsive",
    value: function onResponsive(param) {
      var success = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      var backwards = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
      var counter = 0;

      if (typeof success !== 'function') {
        throw new Error("".concat(success, " should be a function"));
      }

      if (param) {
        if (typeof param === 'boolean') {
          return success();
        }

        if (Array.isArray(param)) {
          param.forEach(function (resolution) {
            return window.responsive === resolution ? counter += 1 : counter;
          });
        } else {
          throw new Error("".concat(param, " should be an Array or Boolean"));
        }
      }

      if (counter) {
        return success();
      }

      return backwards();
    }
    /**
     * Replace custom elements from their position and insert it inside menu. And backwards.
     */

  }, {
    key: "insertCustomElements",
    value: function insertCustomElements() {
      var _this10 = this;

      __WEBPACK_IMPORTED_MODULE_0__helpers__["c" /* checkExpectedParams */]({
        array: [this.options.rebuildMenu]
      });
      this.options.rebuildMenu.forEach(function (rule, index) {
        // Check required params before start
        __WEBPACK_IMPORTED_MODULE_0__helpers__["c" /* checkExpectedParams */]({
          array: [rule.breakpoints],
          string: [rule.selector],
          function: [rule.callback]
        });
        var elements = [].slice.call(document.querySelectorAll(rule.selector)); // Select elements
        // Create and store comments on first load

        if (!Object.prototype.hasOwnProperty.call(_this10.comments, index)) {
          _this10.comments[index] = [];
          elements.forEach(function (element) {
            var commentText = element.classList[0];
            var comment = document.createComment(commentText);
            __WEBPACK_IMPORTED_MODULE_0__helpers__["q" /* insertAfter */](comment, element);

            _this10.comments[index].push(comment);
          });
        } // Loop through elements and check if we need to put them into nav or back.


        elements.forEach(function (element, i) {
          if (rule.breakpoints.indexOf(window.responsive) !== -1) {
            // If we need to put element to nav ...
            // Check if it's already there
            if (!_this10.wrapper.contains(element)) {
              rule.callback(element, _this10.wrapper, _this10); // Run callback
            }
          } else {
            // ... or put it back
            var comment = _this10.comments[index][i]; // Check if it's already there

            if (comment.previousSibling !== null && comment.previousSibling !== element) {
              comment.parentNode.insertBefore(element, comment);
            }
          }
        });
      });
    }
  }, {
    key: "checkIncludedElements",
    value: function checkIncludedElements(e) {
      if (this.options.emitInsideHandlerFor.length) {
        var elements = _toConsumableArray(document.querySelectorAll(this.options.emitInsideHandlerFor));

        return elements.filter(function (element) {
          return element.contains(e.target);
        }).length > 0;
      }

      return false;
    }
    /**
     * Close menu if you click outside selector.
     * @param e - Browser event.
     */

  }, {
    key: "clickOutside",
    value: function clickOutside(e) {
      var isClickInside = this.selector.contains(e.target) || this.openerButton.contains(e.target) || this.checkIncludedElements(e);

      if (!isClickInside) {
        this.closeMenu();
      }
    }
    /**
     * Open menu
     */

  }, {
    key: "openMenu",
    value: function openMenu() {}
    /**
     * Close menu
     */

  }, {
    key: "closeMenu",
    value: function closeMenu() {}
    /**
     * Toggle between open/close menu.
     * @returns {*}
     */

  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.selector, this.options.menu.openedClassName) ? this.closeMenu() : this.openMenu();
    }
    /**
     * Init focus trap for menu.
     * @param event - Browser event.
     */

  }, {
    key: "initFocusTrap",
    value: function initFocusTrap(event) {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["p" /* initFocusTrap */](this.selector, event, true);
      var elementOut = this.options.focusTrap.closeOnLastElementOut ? __WEBPACK_IMPORTED_MODULE_0__helpers__["j" /* getLastFocusableElement */](this.selector) : null;
      var closeCondition = this.options.focusTrap.closeOnLastElementOut ? event.keyCode === 27 || event.target === elementOut : event.keyCode === 27;

      if (closeCondition) {
        this.closeMenu();
      }
    }
    /**
     * Merge to objects.
     * @param defaults {object} - default object.
     * @param options {object} - object ot merge.
     * @returns {object} - merged object.
     */

  }, {
    key: "extend",
    value: function extend(defaults, options) {
      if (options instanceof Object) {
        return __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](defaults, options);
      }
    }
    /**
     * Get depth of DOM element tree.
     * @param element {HTMLElement} - element node in which whe should calc depth.
     * @returns {number} - depth value.
     */

  }], [{
    key: "getDepth",
    value: function getDepth(element) {
      var queue = [];
      var depth = -1;
      queue.push(element);

      var _loop = function _loop() {
        var innerQueue = [];

        while (queue.length > 0) {
          var tempNode = queue.shift();

          if (tempNode.children.length) {
            _toConsumableArray(tempNode.children).forEach(function (child) {
              innerQueue.push(child);
            });
          }
        }

        depth += 1;
        queue = innerQueue;
      };

      while (queue.length > 0) {
        _loop();
      }

      return depth;
    }
    /**
     * Get depth position of element inside wrapper.
     * @param element {HTMLElement} - element node to take depth index.
     * @param wrapper {HTMLElement} - element in which search.
     * @returns {number} - depth level.
     */

  }, {
    key: "getDepthIndex",
    value: function getDepthIndex(element, wrapper) {
      var elem = element;
      var index = 0;

      while (elem !== wrapper) {
        if (elem === document.body) {
          index = null;
          break;
        }

        index += 1;
        elem = elem.parentNode;
      }

      return index;
    }
  }]);

  return Menu;
}();
/**
 * Class represents Aside menu.
 */


var AsideMenu =
/*#__PURE__*/
function (_Menu) {
  _inherits(AsideMenu, _Menu);

  /**
   * Create menu instance
   * @param selector {string} - element selector.
   * @param options {object} - object with menu settings.
   */
  function AsideMenu(selector, options) {
    var _this11;

    _classCallCheck(this, AsideMenu);

    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(AsideMenu).call(this, selector));
    _this11.options = options;

    _this11.create();

    return _this11;
  }
  /**
   * Init A11y for menu.
   */


  _createClass(AsideMenu, [{
    key: "initAccessibility",
    value: function initAccessibility() {
      var _this12 = this;

      // Create a11y connections between controls and menu
      var togglesArray = [];

      if (this.overlay) {
        togglesArray.push(this.overlay);
      }

      if (this.closeButton) {
        togglesArray.push(this.closeButton);
      }

      togglesArray.push(this.openerButton);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */](togglesArray, this.selector); // Create a11y connections between controls and submenu

      if (this.toggles) {
        this.toggles.forEach(function (toggle) {
          var submenu = toggle.parentNode.querySelector(".".concat(_this12.options.menu.submenuClassName));
          __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */](toggle, submenu);
        });
      } // Set tabindex to -1 for all menu


      __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.selector, -1);
    }
    /**
     * Create menu structure, set classes, events.
     */

  }, {
    key: "create",
    value: function create() {
      this.setClassNames();

      if (this.options.openerButton || this.options.overlay || this.options.closeButton) {
        this.openerButton = this.getOpenerButton();

        if (!this.openerButton) {
          throw new Error("Please add opener button with class: ".concat(this.options.openerButton.className));
        }

        this.setOverlay();
        this.setCloseButton();
      } else {
        throw new Error("Please add opener button with class: ".concat(this.options.openerButton.className));
      }

      this.initAccessibility();
      this.initEvents();
      this.initCurrent();
      this.insertCustomElements();
    }
    /**
     * Initialize menu events.
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      var _this13 = this;

      this.toggleMenuHandler = this.toggleMenu.bind(this);
      this.closeMenuHandler = this.closeMenu.bind(this);
      this.updateMenuHandler = this.update.bind(this);
      this.outsideHandler = this.clickOutside.bind(this);
      this.openerButton.addEventListener('click', this.toggleMenuHandler);
      [this.closeButton, this.overlay].forEach(function (element) {
        if (element) {
          element.addEventListener('click', _this13.closeMenuHandler);
        }
      });

      if (this.toggles) {
        this.toggleSubmenuHandler = this.toggleSubmenu.bind(this);
        this.toggles.forEach(function (toggle) {
          return toggle.addEventListener('click', _this13.toggleSubmenuHandler);
        });
      }

      if (this.options.focusTrap.init) {
        this.focusTrapHandler = this.initFocusTrap.bind(this);
        this.selector.addEventListener('keydown', this.focusTrapHandler);
      }

      window.addEventListener('responsive', this.updateMenuHandler);
      document.addEventListener('click', this.outsideHandler);
    }
    /**
     * Remove menu events.
     */

  }, {
    key: "removeEvents",
    value: function removeEvents() {
      var _this14 = this;

      this.openerButton.removeEventListener('click', this.toggleMenuHandler);
      [this.closeButton, this.overlay].forEach(function (element) {
        if (element) {
          element.removeEventListener('click', _this14.closeMenuHandler);
        }
      });

      if (this.toggles) {
        this.toggles.forEach(function (toggle) {
          return toggle.removeEventListener('click', _this14.toggleSubmenuHandler);
        });
      }

      if (this.options.focusTrap.init) {
        this.selector.removeEventListener('keydown', this.focusTrapHandler);
      }

      window.removeEventListener('responsive', this.updateMenuHandler);
      document.removeEventListener('click', this.outsideHandler);
    }
    /**
     * Open menu.
     */

  }, {
    key: "openMenu",
    value: function openMenu() {
      this.setElementClass(this.selector, this.options.menu.openedClassName);
      this.setElementClass(this.overlay, this.options.menu.openedClassName);
      this.setElementClass(document.body, this.options.body.openedClassName);

      if (this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["D" /* toggleTabindex */](this.closeButton);
      }

      __WEBPACK_IMPORTED_MODULE_0__helpers__["r" /* manageBodyOverflow */]('hidden');

      if (this.overlay && this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay, this.closeButton], this.selector, 'opened');
      } else if (this.overlay) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay], this.selector, 'opened');
      } else if (this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.closeButton], this.selector, 'opened');
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.openerButton, this.selector, 'opened');
      }

      this.setElementClass(this.openerButton, this.options.menu.openedClassName);
      var firstLevelElements = this.getFirstLevelFocusableElements();

      if (firstLevelElements) {
        var firstLevelIndex = AsideMenu.getDepthIndex(firstLevelElements[0], this.selector);
        __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](this.selector, 0, firstLevelIndex);
        var openedItems = this.getOpenedItems();

        if (openedItems) {
          openedItems.forEach(function (item) {
            __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](item, 0, 3);
          });
        }
      }

      var focusableElements = __WEBPACK_IMPORTED_MODULE_0__helpers__["i" /* getFocusableElements */](this.selector, true); // When open set focus on first element

      if (focusableElements) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["A" /* setFirstElementFocus */](focusableElements);
      }
    }
    /**
     * Close menu.
     */

  }, {
    key: "closeMenu",
    value: function closeMenu() {
      var _this15 = this;

      if (__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.selector, this.options.menu.openedClassName)) {
        this.onResponsive(this.options.openerButton.show, function () {
          _this15.openerButton.focus();
        });
      }

      this.removeElementClass(this.selector, this.options.menu.openedClassName);
      this.removeElementClass(this.overlay, this.options.menu.openedClassName);
      this.removeElementClass(document.body, this.options.body.openedClassName);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["r" /* manageBodyOverflow */]('visible');
      __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.selector, -1);

      if (this.overlay && this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay, this.closeButton], this.selector, 'closed');
      } else if (this.overlay) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay], this.selector, 'closed');
      } else if (this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.closeButton], this.selector, 'closed');
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.openerButton, this.selector, 'closed');
      }

      this.removeElementClass(this.openerButton, this.options.menu.openedClassName);
    }
    /**
     * Update menu structure and handlers.
     */

  }, {
    key: "update",
    value: function update() {
      this.closeMenu();
      this.removeEvents();
      this.setOverlay();
      this.setCloseButton();
      this.initAccessibility();
      this.insertCustomElements();
      this.initEvents();
    }
  }]);

  return AsideMenu;
}(Menu);
/**
 * Class represents Default menu.
 */


var DefaultMenu =
/*#__PURE__*/
function (_Menu2) {
  _inherits(DefaultMenu, _Menu2);

  /**
   * Create menu instance
   * @param selector {string} - element selector.
   * @param options {object} - object with menu settings.
   */
  function DefaultMenu(selector, options) {
    var _this16;

    _classCallCheck(this, DefaultMenu);

    _this16 = _possibleConstructorReturn(this, _getPrototypeOf(DefaultMenu).call(this, selector));
    _this16.options = options;

    _this16.create();

    return _this16;
  }
  /**
   * Create menu structure, set classes, events.
   */


  _createClass(DefaultMenu, [{
    key: "create",
    value: function create() {
      this.setClassNames(); // Create comment node to remember menu position

      var comment = document.createComment(this.selector.className);
      this.menuPosition = this.selector.parentNode.insertBefore(comment, this.selector);

      if (this.options.openerButton || this.options.overlay || this.options.closeButton) {
        this.openerButton = this.getOpenerButton();

        if (!this.openerButton) {
          throw new Error("Please add opener button with class: ".concat(this.options.openerButton.className));
        }

        this.setOverlay();
        this.setCloseButton();
      } else {
        throw new Error("Please add opener button with class: ".concat(this.options.openerButton.className));
      }

      this.insertCustomElements();
      this.initAccessibility();
      this.generateToggels();
      this.initEvents();
      this.initCurrent();
      this.updateMenuPosition();
    }
    /**
     * Init A11y for menu.
     */

  }, {
    key: "initAccessibility",
    value: function initAccessibility() {
      var _this17 = this;

      // Create a11y connections between controls and menu
      var togglesArray = [];

      if (this.overlay) {
        togglesArray.push(this.overlay);
      }

      if (this.closeButton) {
        togglesArray.push(this.closeButton);
      }

      togglesArray.push(this.openerButton);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */](togglesArray, this.selector); // Create a11y connections between controls and submenu

      this.onResponsive(this.options.initSubmenuToggles, function () {
        if (_this17.toggles) {
          _this17.toggles.filter(function (toggle) {
            return !__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggle, _this17.options.menu.dropdownCloseClassName);
          }).forEach(function (toggle) {
            var submenu = toggle.parentNode.querySelector(".".concat(_this17.options.menu.submenuClassName));
            __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */](toggle, submenu);
          });
        }
      }, function () {
        if (_this17.toggles) {
          _this17.toggles.filter(function (toggle) {
            return !__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggle, _this17.options.menu.dropdownCloseClassName);
          }).forEach(function (toggle) {
            var submenu = toggle.parentNode.querySelector(".".concat(_this17.options.menu.submenuClassName));
            __WEBPACK_IMPORTED_MODULE_0__helpers__["u" /* removeAriaControls */](toggle);
            __WEBPACK_IMPORTED_MODULE_0__helpers__["u" /* removeAriaControls */](submenu);
          });
        }
      }); // Create a11y connections between first level links and dropdowns

      var links = this.getFirstLevelLinks();
      links.forEach(function (link) {
        // link.setAttribute('tabindex', 0);
        var dropdownWrapper = link.parentNode.querySelector(".".concat(_this17.options.menu.dropdownWrapperClassName));
        var closeButton = dropdownWrapper ? dropdownWrapper.querySelector(".".concat(_this17.options.menu.dropdownCloseClassName)) : null;

        if (dropdownWrapper && closeButton) {
          __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */]([link, closeButton], dropdownWrapper);
        } else if (dropdownWrapper) {
          __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */](link, dropdownWrapper);
        }

        _this17.onResponsive(_this17.options.breakpoints, function () {}, function () {
          link.removeAttribute('tabindex');
        });

        if (__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](link.parentNode, _this17.options.menu.itemWithDropdownClassName)) {
          _this17.onResponsive(_this17.options.breakpoints, function () {
            link.removeAttribute('role');
          }, function () {
            link.setAttribute('role', 'button');
          });
        }
      });
      this.onResponsive(this.options.breakpoints, function () {
        _this17.selector.setAttribute('aria-hidden', true);

        __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](_this17.selector, -1);
      }, function () {
        _this17.selector.setAttribute('aria-hidden', false); // Set tabindex to -1 for all menu containers


        if (_this17.dropdownContainers) {
          _this17.dropdownContainers.forEach(function (container) {
            return __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](container, -1);
          });
        }
      });
    }
    /**
     * Initialize menu events.
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      var _this18 = this;

      this.toggleMenuHandler = this.toggleMenu.bind(this);
      this.outsideHandler = this.clickOutside.bind(this);
      this.toggleMobileMenuHandler = this.toggleMobileMenu.bind(this);
      this.updateMenuHandler = this.update.bind(this);
      this.toggleSubmenuHandler = this.toggleSubmenu.bind(this);
      this.scrollHandler = this.closeMenuOnScroll.bind(this);
      [this.openerButton, this.closeButton, this.overlay].forEach(function (element) {
        if (element) {
          element.addEventListener('click', _this18.toggleMobileMenuHandler);
        }
      });
      var links = this.getFirstLevelLinks();

      if (links) {
        links.filter(function (link) {
          return link.parentNode.querySelector(".".concat(_this18.options.menu.dropdownWrapperClassName));
        }).forEach(function (link) {
          ['click', 'keydown'].forEach(function (evenType) {
            link.addEventListener(evenType, _this18.toggleMenuHandler);
          });
        });
        var toggles = links.filter(function (link) {
          return link.parentNode.querySelector(".".concat(_this18.options.menu.toggleClassName));
        }).map(function (link) {
          return link.parentNode.querySelector(".".concat(_this18.options.menu.toggleClassName));
        }).forEach(function (link) {
          return link.addEventListener('click', _this18.toggleMenuHandler);
        });
      }

      if (this.toggles) {
        var submenuToggles = this.toggles.filter(function (toggle) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggle.nextElementSibling, _this18.options.menu.submenuClassName);
        });
        this.onResponsive(this.options.initSubmenuToggles, function () {
          submenuToggles.forEach(function (toggle) {
            return toggle.addEventListener('click', _this18.toggleSubmenuHandler);
          });
        }, function () {
          submenuToggles.forEach(function (toggle) {
            return toggle.removeEventListener('click', _this18.toggleSubmenuHandler);
          });
        });
      }

      if (this.options.focusTrap.init) {
        this.focusTrapHandler = this.initFocusTrap.bind(this);
        this.onResponsive(this.options.breakpoints, function () {
          _this18.selector.addEventListener('keydown', _this18.focusTrapHandler);
        }, function () {
          _this18.selector.removeEventListener('keydown', _this18.focusTrapHandler);
        });
      }

      document.addEventListener('click', this.outsideHandler);
      window.addEventListener('responsive', this.updateMenuHandler);
      window.addEventListener('scroll', this.scrollHandler);
    }
    /**
     * Remove menu events.
     */

  }, {
    key: "removeEvents",
    value: function removeEvents() {
      var _this19 = this;

      [this.openerButton, this.closeButton, this.overlay].forEach(function (element) {
        if (element) {
          element.removeEventListener('click', _this19.toggleMobileMenuHandler);
        }
      });
      var links = this.getFirstLevelLinks();

      if (links) {
        links.filter(function (link) {
          return link.parentNode.querySelector(".".concat(_this19.options.menu.dropdownWrapperClassName));
        }).forEach(function (link) {
          ['click', 'keydown'].forEach(function (evenType) {
            link.removeEventListener(evenType, _this19.toggleMenuHandler);
          });
        });
        var toggles = links.filter(function (link) {
          return link.parentNode.querySelector(".".concat(_this19.options.menu.toggleClassName));
        }).map(function (link) {
          return link.parentNode.querySelector(".".concat(_this19.options.menu.toggleClassName));
        }).forEach(function (link) {
          return link.removeEventListener('click', _this19.toggleMenuHandler);
        });
      }

      if (this.toggles) {
        var submenuToggles = this.toggles.filter(function (toggle) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggle.nextElementSibling, _this19.options.menu.submenuClassName);
        }).forEach(function (toggle) {
          return toggle.removeEventListener('click', _this19.toggleSubmenuHandler);
        });
      }

      if (this.options.focusTrap.init) {
        this.selector.removeEventListener('keydown', this.focusTrapHandler);
      }

      document.removeEventListener('click', this.outsideHandler);
      window.removeEventListener('responsive', this.updateMenuHandler);
    }
  }, {
    key: "closeMenuOnScroll",
    value: function closeMenuOnScroll(event) {
      if (this.lastClickedLink) {
        if (this.getOpenedItems().length) {
          this.closeMenu(this.lastClickedLink.parentNode, this.lastEvent);
        }
      }
    }
    /**
     * Open mobile menu.
     */

  }, {
    key: "openMobileMenu",
    value: function openMobileMenu() {
      this.setElementClass(this.selector, this.options.menu.openedClassName);
      this.setElementClass(this.overlay, this.options.menu.openedClassName);
      this.setElementClass(document.body, this.options.body.openedClassName);
      this.selector.setAttribute('aria-hidden', false);

      if (this.closeButton) {
        this.closeButton.setAttribute('tabindex', 0);
      }

      __WEBPACK_IMPORTED_MODULE_0__helpers__["r" /* manageBodyOverflow */]('hidden');

      if (this.overlay && this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay, this.closeButton], this.selector, 'opened');
      } else if (this.overlay) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay], this.selector, 'opened');
      } else if (this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.closeButton], this.selector, 'opened');
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.openerButton, this.selector, 'opened');
      }

      this.setElementClass(this.openerButton, this.options.menu.openedClassName);
      var firstLevelElements = this.getFirstLevelFocusableElements();

      if (firstLevelElements) {
        var firstLevelIndex = AsideMenu.getDepthIndex(firstLevelElements[0], this.selector);
        __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](this.selector, 0, firstLevelIndex);
        var openedItems = this.getOpenedItems();

        if (openedItems) {
          openedItems.forEach(function (item) {
            __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](item, 0, 3);
          });
        }
      }

      var focusableElements = __WEBPACK_IMPORTED_MODULE_0__helpers__["i" /* getFocusableElements */](this.selector, true); // When open set focus on first element

      if (focusableElements) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["A" /* setFirstElementFocus */](focusableElements);
      }
    }
    /**
     * Close mobile menu.
     */

  }, {
    key: "closeMobileMenu",
    value: function closeMobileMenu() {
      var _this20 = this;

      if (__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.selector, this.options.menu.openedClassName)) {
        this.onResponsive(this.options.openerButton.show, function () {
          _this20.openerButton.focus();
        });
      }

      this.removeElementClass(this.selector, this.options.menu.openedClassName);
      this.removeElementClass(this.overlay, this.options.menu.openedClassName);
      this.removeElementClass(document.body, this.options.body.openedClassName);
      this.selector.setAttribute('aria-hidden', true);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["r" /* manageBodyOverflow */]('visible');
      __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](this.selector, -1);

      if (this.overlay && this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay, this.closeButton], this.selector, 'closed');
      } else if (this.overlay) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.overlay], this.selector, 'closed');
      } else if (this.closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.openerButton, this.closeButton], this.selector, 'closed');
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.openerButton, this.selector, 'closed');
      }

      this.removeElementClass(this.openerButton, this.options.menu.openedClassName);
      this.onResponsive(this.options.breakpoints, function () {
        _this20.openerButton.focus();
      });
    }
    /**
     * Toggle between open/close mobile menu.
     */

  }, {
    key: "toggleMobileMenu",
    value: function toggleMobileMenu() {
      return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](this.selector, this.options.menu.openedClassName) ? this.closeMobileMenu() : this.openMobileMenu();
    }
    /**
     * Open menu (first level)
     * @param item {HTMLElement} - Node which should be opened.
     * @param event - Browser event.
     */

  }, {
    key: "openMenu",
    value: function openMenu(item, event) {
      var _this21 = this;

      var eventIsDisabled = false;
      this.onResponsive(this.options.breakpoints, function () {
        event.stopPropagation();
        eventIsDisabled = false;
      }, function () {
        event.preventDefault();
        eventIsDisabled = true;
      }); // Disable link on mobile view

      if (event.target && event.target.tagName.toLowerCase() === 'a' && !eventIsDisabled) {
        return false;
      }

      if (this.lastClickedLink) {
        this.onResponsive(this.options.breakpoints, function () {}, function () {
          _this21.closeMenu(_this21.lastClickedLink.parentNode, event);
        });
      }

      this.lastClickedLink = item.querySelector('a');
      this.lastEvent = event;
      this.setElementClass(item, this.options.menu.openedClassName);
      this.onResponsive(this.options.breakpoints, function () {}, function () {
        _this21.setElementClass(document.body, _this21.options.body.openedClassName);
      });
      var dropdown = item.querySelector(".".concat(this.options.menu.dropdownWrapperClassName));
      var toggle = this.lastClickedLink.nextElementSibling.tagName.toLowerCase() === 'button' ? this.lastClickedLink.nextElementSibling : null;
      var closeButton = dropdown ? dropdown.querySelector(".".concat(this.options.menu.dropdownCloseClassName)) : null;

      if (dropdown && closeButton && toggle) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.lastClickedLink, closeButton, toggle], dropdown, 'opened');
      } else if (dropdown && closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.lastClickedLink, closeButton], dropdown, 'opened');
      } else if (dropdown) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.lastClickedLink, dropdown, 'opened');
      }

      var submenus = _toConsumableArray(dropdown.querySelectorAll(".".concat(this.options.menu.submenuClassName))); // // When open set focus on first element (need timeout because we have visibility animation)


      this.onResponsive(this.options.breakpoints, function () {
        if (submenus.length) {
          submenus.filter(function (submenu) {
            return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](submenu.parentNode, _this21.options.menu.dropdownContainerClassName);
          }).forEach(function (submenu) {
            return __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](submenu, 0, 3);
          });
        }
      }, function () {
        if (submenus.length) {
          submenus.forEach(function (submenu) {
            return submenu.getAttribute('aria-hidden') ? __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](dropdown, 0, 3) : __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](dropdown, 0);
          });
        }

        setTimeout(function () {
          __WEBPACK_IMPORTED_MODULE_0__helpers__["A" /* setFirstElementFocus */](__WEBPACK_IMPORTED_MODULE_0__helpers__["i" /* getFocusableElements */](dropdown, true));
        }, 100);
      });
      var openedItems = this.getOpenedItems();

      if (openedItems) {
        openedItems.filter(function (openedItem) {
          var wrapper = __WEBPACK_IMPORTED_MODULE_0__helpers__["g" /* findAncestor */](openedItem, _this21.options.menu.dropdownWrapperClassName);
          return wrapper && wrapper.getAttribute('aria-hidden') === 'false';
        }).forEach(function (openedItem) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["s" /* manageTabindex */](openedItem, 0, 3);
        });
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](this.list, this.options.menu.openedClassName);
      }

      this.onResponsive(this.options.breakpoints, function () {}, function () {
        _this21.getFirstLevelLinks().forEach(function (link) {
          return link.setAttribute('tabindex', -1);
        });

        if (_this21.options.focusTrap.init) {
          dropdown.addEventListener('keydown', _this21.focusTrapHandler);
        }
      });
    }
    /**
     * Close menu (first level)
     * @param item {HTMLElement} - Node which should be closed.
     * @param event - Browser event.
     */

  }, {
    key: "closeMenu",
    value: function closeMenu(item, event) {
      var _this22 = this;

      var eventIsDisabled = false;

      if (this.selector.contains(event.target)) {
        this.onResponsive(this.options.breakpoints, function () {
          event.stopPropagation();
          eventIsDisabled = false;
        }, function () {
          event.preventDefault();
          eventIsDisabled = true;
        });
      } // Disable link on mobile view


      if (event.target && event.target.tagName.toLowerCase() === 'a' && !eventIsDisabled) {
        return false;
      }

      this.removeElementClass(item, this.options.menu.openedClassName);
      this.onResponsive(this.options.breakpoints, function () {}, function () {
        _this22.removeElementClass(document.body, _this22.options.body.openedClassName);
      });
      var dropdown = item.querySelector(".".concat(this.options.menu.dropdownWrapperClassName));
      var toggle = this.lastClickedLink && this.lastClickedLink.nextElementSibling && this.lastClickedLink.nextElementSibling.tagName.toLowerCase() === 'button' ? this.lastClickedLink.nextElementSibling : null;
      var closeButton = dropdown ? dropdown.querySelector(".".concat(this.options.menu.dropdownCloseClassName)) : null;
      __WEBPACK_IMPORTED_MODULE_0__helpers__["B" /* setTabindex */](dropdown, -1); // Close all opened items inside current item

      var openedItems = _toConsumableArray(item.querySelectorAll(".".concat(this.options.menu.itemClassName, ".").concat(this.options.menu.openedClassName)));

      if (openedItems) {
        openedItems.forEach(function (openedItem) {
          var openedItemToggle = openedItem.querySelector(".".concat(_this22.options.menu.toggleClassName));

          if (openedItemToggle) {
            openedItemToggle.click();
          }
        });
      }

      if (!this.getOpenedItems().length) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](this.list, this.options.menu.openedClassName);
      }

      if (dropdown && closeButton && toggle) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.lastClickedLink, closeButton, toggle], dropdown, 'closed');
      } else if (dropdown && closeButton) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */]([this.lastClickedLink, closeButton], dropdown, 'closed');
      } else if (dropdown) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["x" /* setAriaControls */](this.lastClickedLink, dropdown, 'closed');
      }

      this.onResponsive(this.options.breakpoints, function () {}, function () {
        _this22.getFirstLevelLinks().forEach(function (link) {
          return link.setAttribute('tabindex', 0);
        });

        if (_this22.selector.contains(event.target)) {
          _this22.lastClickedLink.focus();
        }

        if (_this22.options.focusTrap.init) {
          dropdown.removeEventListener('keydown', _this22.focusTrapHandler);
        }
      });
    }
    /**
     * Toggle between open/close {first levetl} menu.
     * @param event - Browser event.
     */

  }, {
    key: "toggleMenu",
    value: function toggleMenu(event) {
      if (event.target && event.target.getAttribute('role') === 'button') {
        if (event.type === 'click' || event.keyCode === 13 || event.keyCode === 32) {
          var item = __WEBPACK_IMPORTED_MODULE_0__helpers__["g" /* findAncestor */](event.target, this.options.menu.itemClassName);
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](item, this.options.menu.openedClassName) ? this.closeMenu(item, event) : this.openMenu(item, event);
        }
      } else {
        var _item = __WEBPACK_IMPORTED_MODULE_0__helpers__["g" /* findAncestor */](event.target, this.options.menu.itemClassName);

        return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](_item, this.options.menu.openedClassName) ? this.closeMenu(_item, event) : this.openMenu(_item, event);
      }
    }
    /**
     * Close menu if you click outside selector.
     * @param event - Browser event.
     */

  }, {
    key: "clickOutside",
    value: function clickOutside(e) {
      var isClickInside = this.selector.contains(e.target) || this.openerButton.contains(e.target) || this.checkIncludedElements(e);

      if (!isClickInside && this.lastClickedLink) {
        this.closeMenu(this.lastClickedLink.parentNode, e);
      }
    }
    /**
     * Init focus trap for menu.
     * @param event - Browser event.
     */

  }, {
    key: "initFocusTrap",
    value: function initFocusTrap(event) {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["p" /* initFocusTrap */](this.selector, event, true);
      var elementOut = this.options.focusTrap.closeOnLastElementOut ? __WEBPACK_IMPORTED_MODULE_0__helpers__["j" /* getLastFocusableElement */](this.selector) : null;
      var closeCondition = this.options.focusTrap.closeOnLastElementOut ? event.keyCode === 27 || event.target === elementOut : event.keyCode === 27;

      if (closeCondition) {
        this.closeMenu(this.lastClickedLink.parentNode, event);
      }
    }
    /**
     * Update menu position in DOM tree. (Mobile position can be changed)
     */

  }, {
    key: "updateMenuPosition",
    value: function updateMenuPosition() {
      var _this23 = this;

      // Replace menu
      this.onResponsive(this.options.breakpoints, function () {
        var container = document.querySelector(".".concat(_this23.options.replaceTo));

        if (container) {
          container.appendChild(_this23.selector);
        }
      }, function () {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["q" /* insertAfter */](_this23.selector, _this23.menuPosition);
      });
    }
    /**
     * Generate Toggle buttons.
     */

  }, {
    key: "generateToggels",
    value: function generateToggels() {
      var _this24 = this;

      this.onResponsive(this.options.breakpoints, function () {
        _this24.links.forEach(function (link) {
          if (__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](link.parentNode, _this24.options.menu.itemWithDropdownClassName)) {
            // If link already has connections
            if (link.nextElementSibling.tagName.toLocaleLowerCase() !== 'button' && link.getAttribute('aria-controls')) {
              var id = link.getAttribute('aria-controls');

              var connectedElements = _toConsumableArray(_this24.selector.querySelectorAll("[aria-controls='".concat(id, "']")));

              var controlElement = _this24.selector.querySelector("#".concat(id)); // add button after link


              var toggle = _this24.addToggleAfter(link); // Reinit a11y for this elements


              __WEBPACK_IMPORTED_MODULE_0__helpers__["o" /* initAriaControls */]([].concat(_toConsumableArray(connectedElements), [toggle]), controlElement);
            }
          }
        });
      }, function () {
        _this24.getMenuToggles().filter(function (toggle) {
          return __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggle, _this24.options.menu.generatedClassName) ? toggle.parentNode.removeChild(toggle) : false;
        });
      });
    }
    /**
     * Update menu
     */

  }, {
    key: "update",
    value: function update() {
      var _this25 = this;

      // Close last opened menu
      // if (this.lastClickedLink) {
      //     this.closeMenu(this.lastClickedLink.parentNode, this.lastEvent);
      // }
      // Close all opened menus
      if (this.getOpenedItems().length) {
        this.getOpenedItems().forEach(function (item) {
          if (DefaultMenu.getDepthIndex(item, _this25.selector) <= 3) {
            _this25.closeMenu(item, _this25.lastEvent);
          }
        });
      } // Close mobile menu


      this.closeMobileMenu(); // Remove all event listeners

      this.removeEvents(); // Update menu position if it needs

      this.updateMenuPosition(); // Generate toggels if it needs

      this.generateToggels(); // Regenerate overlay

      this.setOverlay(); // Regenerate close button

      this.setCloseButton(); // Reinit A11y

      this.initAccessibility(); // Update current item

      this.initCurrent(); // Replace custom elements if it needs

      this.insertCustomElements(); // Init new event listeners

      this.initEvents();
    }
  }]);

  return DefaultMenu;
}(Menu);
/**
 * Represents megamenu.
 */


var Megamenu =
/*#__PURE__*/
function (_Menu3) {
  _inherits(Megamenu, _Menu3);

  /**
   * Create megamenu instance.
   * @param selector {string} - selector for megamenu.
   * @param options {object} - object with menu settings.
   */
  function Megamenu(selector, options) {
    var _this26;

    _classCallCheck(this, Megamenu);

    _this26 = _possibleConstructorReturn(this, _getPrototypeOf(Megamenu).call(this, selector));
    _this26.options = _this26.extend(_this26.options, options);

    _this26.checkBeforeInit();

    return _this26;
  }
  /**
   * Check before initializing menu.
   */


  _createClass(Megamenu, [{
    key: "checkBeforeInit",
    value: function checkBeforeInit() {
      var _this27 = this;

      if (typeof this.selector === 'string') {
        _toConsumableArray(document.querySelectorAll(this.selector)).forEach(function (menu) {
          return new Megamenu(menu, _this27.options);
        });
      } else {
        this.init();
      }
    }
    /**
     * Initialize megamenu.
     * @returns {Menu} - Menu object which will be created.
     */

  }, {
    key: "init",
    value: function init() {
      switch (this.options.menu.type) {
        case 'aside':
          return new AsideMenu(this.selector, this.options);

        default:
          return new DefaultMenu(this.selector, this.options);
      }
    }
  }]);

  return Megamenu;
}(Menu);



/***/ }),
/* 440 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ResponsiveEvent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 Responsive event. Dispatch change window width event.
 If you need to change some state of your code when window width (current breakpoint) is changes, just add window event listener for this.

 @important: Init the plugin in the very end of the code to get event dispatch at the page loading;
 @important: You can get current breakpoint from global scope - window.responsive

 @example: window.addEventListener('responsive', menuOld);
 @example: window.addEventListener('responsive', () => {
    console.log('current breakpoint: ', window.responsive)
 });

 @param {Object} options - Object of all options.
 @param {Object} options.sizes - Object of sizes to generate events on them.
 @param {string} options.eventName - Name of the generated event

 @version 1.0.1
 */

var ResponsiveEvent =
/*#__PURE__*/
function () {
  function ResponsiveEvent() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, ResponsiveEvent);

    this.options = {
      sizes: {
        0: 'smartphone',
        767: 'tablet',
        1279: 'desktop'
      },
      eventName: 'responsive'
    };

    if (options instanceof Object) {
      this.options = __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](this.options, options);
    } // 1.0.1 In future we can attach functions in some kind of a stack to call them without event
    // this.stack = [];


    this.event = null;
    window.responsive = '';
    this.init();
  }

  _createClass(ResponsiveEvent, [{
    key: "init",
    value: function init() {
      this.IEPolyfill();
      this.event = new CustomEvent(this.options.eventName, {
        bubbles: true,
        cancelable: false,
        detail: {
          responsive: this.getSize(window.innerWidth)
        }
      });
      window.addEventListener('resize', __WEBPACK_IMPORTED_MODULE_0__helpers__["d" /* debounce */](this.checkView.bind(this), 50));
      this.checkView();
    }
  }, {
    key: "getSize",
    value: function getSize(width) {
      var view = false;

      for (var size in this.options.sizes) {
        if (size < width) {
          view = this.options.sizes[size];
        } else {
          break;
        }
      }

      return view;
    }
  }, {
    key: "checkView",
    value: function checkView() {
      var view = this.getSize(window.innerWidth);

      if (view !== window.responsive) {
        // 1.0.1 In future we can attach functions in some kind of a stack to call them without event
        // this.stack.forEach(f => helpers.executeIfFunction(f.bind(view)));
        window.responsive = view;
        this.event.detail.responsive = view;
        window.dispatchEvent(this.event);
      }
    }
  }, {
    key: "IEPolyfill",
    value: function IEPolyfill() {
      try {
        var event = new CustomEvent('IE has CustomEvent, but doesn\'t support constructor');
      } catch (e) {
        window.CustomEvent = function (event) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            bubbles: false,
            cancelable: false,
            detail: undefined
          };
          var evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
          return evt;
        };

        CustomEvent.prototype = Object.create(window.Event.prototype);
      }
    }
  }]);

  return ResponsiveEvent;
}();



/***/ }),
/* 441 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);

/*
* TODO: add documentation
* */

function initFixedHeader(selector) {
  var onlyFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var element = document.querySelector(selector);

  if (element === null) {
    return;
  }

  setTimeout(function () {
    var elementHeight = element.offsetHeight;
    var fixedPos = elementHeight + offset;
    var emptyElement = document.createElement('div');
    var elementStyle = getComputedStyle(element);
    var siblings = element.parentNode.children;
    var lastScrollPos = 0;

    if (!__WEBPACK_IMPORTED_MODULE_0__helpers__["n" /* hasElement */](siblings, emptyElement) && elementStyle.position !== 'absolute' && elementStyle.position !== 'fixed') {
      element.parentNode.insertBefore(emptyElement, element);
      emptyElement.style.height = "".concat(elementHeight, "px");
    }

    __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, '-absolute'); // console.log(element, element.offsetHeight, element.clientHeight);
    // console.dir(element, element.offsetHeight);

    window.addEventListener('resize', __WEBPACK_IMPORTED_MODULE_0__helpers__["C" /* throttle */](function () {
      if (__WEBPACK_IMPORTED_MODULE_0__helpers__["n" /* hasElement */](siblings, emptyElement)) {
        emptyElement.style.height = "".concat(element.offsetHeight, "px");
      }
    }));
    window.addEventListener('scroll', __WEBPACK_IMPORTED_MODULE_0__helpers__["C" /* throttle */](function () {
      var scroll = window.pageYOffset;

      if (scroll >= fixedPos) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, '-is-fixed');

        if (!onlyFixed) {
          if (scroll > lastScrollPos) {
            setTimeout(function () {
              __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, '-scroll-up');
              __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, '-scroll-down');
            }, 250);
          } else {
            if (scroll + window.innerHeight < document.body.clientHeight) {
              setTimeout(function () {
                __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, '-scroll-down');
                __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, '-scroll-up');
              }, 250);
            }
          }
        } else {
          setTimeout(function () {
            __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](element, '-only-fixed');
          }, 250);
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, '-is-fixed');

        if (!onlyFixed) {
          __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, '-scroll-up');
        } else {
          setTimeout(function () {
            __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](element, '-only-fixed');
          }, 250);
        }
      }

      lastScrollPos = scroll;
    }));
  }, 250);
}

/***/ }),
/* 442 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cookiesManagement;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);


function checkSocialCookieEnabled() {
  var socialCookieEnabled = false;

  if (typeof localStorage.getItem('cookiesFunctional') !== 'undefined' && localStorage.getItem('cookiesFunctional') !== null && localStorage.getItem('cookiesFunctional') === 'true') {
    socialCookieEnabled = true;
  }

  return socialCookieEnabled;
} // Example of use

/* if(checkSocialCookieEnabled()) {
 alert('Social cookie is enabled');
 } */


function getCookie(checkName) {
  // first we'll split this cookie up into name/value pairs
  // note: document.cookie only returns name=value, not the other components
  var allCookies = document.cookie.split(';');
  var tempCookies = '';
  var cookieName = '';
  var cookieValue = '';
  var cookieFound = false;

  for (i = 0; i < allCookies.length; i++) {
    // now we'll split apart each name=value pair
    tempCookies = allCookies[i].split('='); // and trim left/right whitespace while we're at it

    cookieName = tempCookies[0].replace(/^\s+|\s+$/g, ''); // if the extracted name matches passed checkName

    if (cookieName === checkName) {
      cookieFound = true; // we need to handle case where cookie has no value but exists (no = sign, that is):

      if (tempCookies.length > 1) {
        cookieValue = unescape(tempCookies[1].replace(/^\s+|\s+$/g, ''));
      } // note that in cases where cookie is initialized but no value, null is returned


      return cookieValue;
      break;
    }

    tempCookies = null;
    cookieName = '';
  }

  if (!cookieFound) {
    return null;
  }
}

function clearCookie(name, domain, path) {
  try {
    if (getCookie(name)) {
      var domainNew = domain || document.domain;
      var pathNew = path || '/';
      document.cookie = "".concat(name, "=; expires=").concat(new Date(), "; domain=").concat(domainNew, "; path=").concat(pathNew);
    }
  } catch (err) {// console.log('Error with cookies');
  }
}

function removeFunctionalCookies() {
  var domainToUseForGoogle = location.hostname.replace('www', ''); // dev

  clearCookie('__utma', domainToUseForGoogle, '/');
  clearCookie('__utmb', domainToUseForGoogle, '/');
  clearCookie('__utmc', domainToUseForGoogle, '/');
  clearCookie('__utmz', domainToUseForGoogle, '/');
  clearCookie('__utmv', domainToUseForGoogle, '/');
  clearCookie('comments_title', location.hostname, '/');
  clearCookie('comments_firstname', location.hostname, '/');
  clearCookie('comments_lastname', location.hostname, '/');
  clearCookie('comments_email', location.hostname, '/');
  clearCookie('comments_homepage', location.hostname, '/');
  clearCookie('tx_comments_pi1_title', location.hostname, '/');
  clearCookie('tx_comments_pi1_firstname', location.hostname, '/');
  clearCookie('tx_comments_pi1_lastname', location.hostname, '/');
  clearCookie('tx_comments_pi1_email', location.hostname, '/');
  clearCookie('tx_comments_pi1_homepage', location.hostname, '/');
} // cookies management

/**
 * Les éléments à ne pas afficher si les cookies sociaux sont désactivés
 * doivent être wrappés comme ceci
 *
 * <div class="element-with-social-cookies">
 *    <!--
 *      example...
 *    -->
 * </div>
 */


function cookiesManagement() {
  // affiche/cache les éléments de contenu type réseaux sociaux
  if (checkSocialCookieEnabled()) {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.element-with-social-cookies').each(function (index, value) {
      var content = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).html().replace('<!--', '').replace('-->', '');
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).html(content);
    });
  } // gestion des cookies


  if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()('#cookie-manager').length > 0 || __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').length > 0) {
    // Add aria-live on container
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#cookie-manager').attr('aria-live', 'polite'); // creation des localstorage avec la valeur 1 s'ils n'existent pas,
    // ou s'ils ont été autorisés par l'utilisateur
    // cookies de suivi

    if (typeof localStorage.getItem('cookiesFunctional') === 'undefined' || localStorage.getItem('cookiesFunctional') === null) {
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input#cookies-functional').attr('checked', 'checked');
      localStorage.setItem('cookiesFunctional', 'true');
      cookiesManagement();
    } else {
      if (localStorage.getItem('cookiesFunctional') === 'true') {
        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input#cookies-functional').attr('checked', 'checked');
      } else {
        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input#cookies-functional').removeAttr('checked');
        removeFunctionalCookies();
      }
    }

    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#cookie-manager .cookie-manager__submit, .cookies-block__button.-accept').click(function () {
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').hide(); // Save to local storage state of functional cookies

      if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()('#cookies-functional').prop('checked')) {
        localStorage.setItem('cookiesFunctional', 'true');
      } else {
        localStorage.setItem('cookiesFunctional', 'false');
        removeFunctionalCookies();
      }

      if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-recorded').length !== 0) {
        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-recorded').remove();
      }

      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).after('<p class="cookies-recorded"><span>Configuration sauvegardée</span></p>'); // save decision to localstorage

      localStorage.setItem('cookiesConfirmed', 1);
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').slideUp();
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.page').removeAttr('style');
      return false;
    });
  } // show cookies top block


  if (typeof localStorage.getItem('cookiesConfirmed') === 'undefined' || localStorage.getItem('cookiesConfirmed') === null || localStorage.getItem('cookiesConfirmed') === 0) {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').show();
  }

  if (window.innerWidth < 940 && __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').is(':visible')) {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.page').css('padding-bottom', __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').outerHeight());
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.page').addClass('cookies-top-bloc--on');
  }

  __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).resize(function () {
    if (window.innerWidth < 940 && __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').is(':visible')) {
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.page').css('padding-bottom', __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.cookies-block').outerHeight());
    } else {
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.page').removeClass('cookies-top-bloc--on');
      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.page').removeAttr('style');
    }
  });
}

/***/ }),
/* 443 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = linkExternalNewWindow;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);

/**
 * Add to external link the mention 'alt + (External link)'
 * Add to blank link the mention 'alt + (New window)', and the rel noreferrer, noopener
 * Add to external and blank link the mention 'alt + (New window External link)', and the rel noreferrer, noopener
 */

function linkExternalNewWindow() {
  // Get anchors and filter them
  var anchors = Array.prototype.slice.call(document.querySelectorAll('body a')); // Skip if anchor has .new-window-off or .tooltip-svg classes

  anchors = anchors.filter(function (anchor) {
    return !__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](anchor, 'new-window-off') && !__WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](anchor, 'tooltip-svg');
  }); // Add rel noopener to element

  var addRelNoopener = function addRelNoopener(elem) {
    var elemRel = elem.hasAttribute('rel') && elem.getAttribute('rel');

    if (elemRel) {
      if (elemRel.split(' ').indexOf('noopener') < 0) {
        elem.setAttribute('rel', "".concat(elemRel, " noopener"));
      }
    } else {
      elem.setAttribute('rel', 'noopener');
    }
  }; // Add aria-label to element


  var getAlt = function getAlt(elem) {
    var title = elem.getAttribute('title');
    var ariaLabel = elem.getAttribute('aria-label');
    var text;

    if (title) {
      text = title;
      elem.removeAttribute('title');
    } else if (ariaLabel) {
      text = ariaLabel;
    } else {
      var textArray = [];
      var elemChildren = Array.prototype.slice.call(elem.childNodes);
      elemChildren.forEach(function (child) {
        if (child.nodeName === 'IMG') {
          textArray.push(child.alt);
        } else if (child.nodeName === 'PICTURE') {
          var pictureChildren = [].slice.call(child.querySelectorAll('*'));
          pictureChildren.forEach(function (child2) {
            if (child2.nodeName === 'IMG') {
              textArray.push(child2.alt);
            }
          });
        } else if (child.nodeName === '#text') {
          textArray.push(child.textContent.trim().toLowerCase());
        } else if (child.nodeName === 'svg') {
          textArray.push(child.getAttribute('aria-label'));
        } else {
          textArray.push(child.textContent.trim().toLowerCase());
        }
      });
      text = textArray.join(' ');
    }

    return text;
  }; // Main loop


  anchors.forEach(function (anchor) {
    // If external link but not _blank
    if (anchor.hostname !== location.hostname && anchor.getAttribute('target') !== '_blank') {
      anchor.setAttribute('title', "".concat(getAlt(anchor), " (").concat(l10n.linkExternalLink, ")"));
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](anchor, 'link-external');
    } else if (anchor.hostname !== location.hostname && anchor.getAttribute('target') === '_blank') {
      // If external link and _blank
      anchor.setAttribute('title', "".concat(getAlt(anchor), " (").concat(l10n.linkNewWindow, " ").concat(l10n.linkExternalLink, ")"));
      addRelNoopener(anchor);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](anchor, 'link-external');
    } else if (anchor.hostname === location.hostname && anchor.getAttribute('target') === '_blank') {
      // If internal and blank
      anchor.setAttribute('title', "".concat(getAlt(anchor), " (").concat(l10n.linkNewWindow, ")"));
      addRelNoopener(anchor);
    }
  });
}

/***/ }),
/* 444 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = accessTooltip;
/*
* TODO: need to finish refactoring tooltip
* */
// AccessTooltip
// A lightweight Javascript function to make the title attribute accessible for keyboard user
//
// GPL licence
// https://github.com/access42/AccessTooltip
// Copyright (c) 2015 Access42, access42.net
//
//
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&dn=gpl-3.0.txt GPL-v3-or-Later
//
//
// *** Parameters ***
// - required objs : query selector for elements to set (tagName or any CSS selector)
// - required tooltipClassName : tooltip CSS design classname
// - required toolTipBetween : distance in pixels between the tooltip and the focused element
// - optionnal tooltipUp : false to set the tooltip above, true to set over the focused element
// - optionnal mouse : false to ignore, true to set mouse mode(replace native title by tooltip on mouseover)
// - optionnal tempDelay : displaying delay in millisecondes ( O to ignore)
// - optionnal useAriaDP : true to use the tooltip design pattern ARIA
// - optionnal useEscClose : true to allow tooltip closed by ESC Key (note : true by default when useAriaDP is set)
//
// *** implementation ***
// Insert this code right before the closing </body> element of your HTML document.
// <script type="text/javascript" src="AccessTooltip.js"></script>
// <script type="text/javascript">
// AccessTooltip({
// objs : 'a, button, input, textarea, select',
// tooltipClassName : 'access-tooltip',
// toolTipBetween : 5,
// toolTipUp : false,
// mouse : true,
// tempDelay : 4000,
// useAriaDP : false,
// useEscClose : true
// });
// </script>

/* AccessTooltip */
function accessTooltip(options) {
  // IE11 on windows 8 is the only browser wich expose the title on keyboard focus
  // Below a little trash, but sufficient, IE11/windows 8 filtering method
  // filter is based on the new user agent string for IE11+
  var Unsupported = function Unsupported() {
    var objUA = window.navigator.userAgent; // If IE 11

    if (objUA.indexOf('Trident') > 0 && objUA.indexOf('MSIE') < 0) {
      // If windows 7 then title keyboard focus is unsupported
      if (objUA.indexOf('NT 6.1') > 0) {
        return true;
      } // If windows 8+ title keyboard focus is supported


      return false;
    } // If not IE title keyboard focus is unsupported


    return true;
  };
  /* set displaying delay */


  var timeoutID;
  /* IE11/windows8+ detection */

  var unsupported = Unsupported();
  /* set tooltip */

  var divTooltip = document.getElementById('AccessibleTooltip') || document.createElement('DIV');

  var clearTooltip = function clearTooltip(obj, mouse) {
    if (divTooltip.firstChild) {
      if (mouse) {
        obj.setAttribute('title', divTooltip.firstChild.nodeValue);
      }

      divTooltip.removeChild(divTooltip.firstChild);
      divTooltip.style.top = null;
      divTooltip.style.left = null;
      divTooltip.style.display = 'none';
    }

    clearTimeout(timeoutID);
  }; // obj position


  var position = function position(obj, coordinate) {
    var pos;
    var parent = obj.offsetParent;
    pos = coordinate === 'x' ? obj.offsetLeft : obj.offsetTop;

    while (parent != null) {
      pos = coordinate === 'x' ? pos + parent.offsetLeft : pos + parent.offsetTop;
      parent = parent.offsetParent;
    }

    return pos;
  }; // Escape function


  var escClose = function escClose(event) {
    if (event.keyCode === 27) {
      if (divTooltip.firstChild) {
        divTooltip.removeChild(divTooltip.firstChild);
        divTooltip.style.display = 'none';
      }

      document.removeEventListener('keydown', escClose, false);
    }
  };
  /* AccessTooltip dependencies */


  var setTooltip = function setTooltip(obj, reset, mouse) {
    if (reset) {
      clearTooltip(obj, mouse);
    } else if (obj.getAttribute('title')) {
      var txt = obj.getAttribute('title');
      var txtTooltip = document.createTextNode(txt); // Set tooltip

      if (txt !== '') {
        if (mouse) {
          obj.removeAttribute('title');
        }

        divTooltip.style.display = 'block';

        if (divTooltip.firstChild) {
          divTooltip.removeChild(divTooltip.firstChild);
        }

        divTooltip.appendChild(txtTooltip); // position

        var resetPosRight = 0;
        var posRight = obj.offsetLeft + obj.offsetWidth + divTooltip.offsetWidth;
        var windowWidth = document.body.clientWidth;
        var windowHeight = document.body.clientHeight;

        if (posRight > windowWidth) {
          resetPosRight = posRight - windowWidth;
        }

        var setPos = options.toolTipBetween + obj.offsetHeight;
        var toolTipTop = position(obj, 'y') + setPos;

        if (options.toolTipUp) {
          toolTipTop = position(obj, 'y') - setPos - 5;
        }

        divTooltip.style.top = "".concat(toolTipTop, "px");
        divTooltip.style.left = "".concat(position(obj, 'x') + obj.offsetWidth * 25 / 100 - resetPosRight, "px");

        if (options.tempDelay > 0) {
          timeoutID = setTimeout(function () {
            if (divTooltip.firstChild) {
              if (mouse) obj.setAttribute('title', divTooltip.firstChild.nodeValue);
              divTooltip.removeChild(divTooltip.firstChild);
              divTooltip.style.display = 'none';
            }
          }, options.tempDelay);
        }

        if (options.useAriaDP || options.useEscClose) {
          document.addEventListener('keydown', escClose, false);
        }
      } else {
        obj.removeAttribute('title');
      }
    }
  };

  divTooltip.setAttribute('id', 'AccessibleTooltip');
  divTooltip.setAttribute('class', options.tooltipClassName);
  document.body.appendChild(divTooltip);

  if (options.useAriaDP) {
    divTooltip.setAttribute('role', 'tooltip');
  }

  divTooltip.style.display = 'none';
  /* set elements targeted */

  var tabList = document.querySelectorAll(options.objs);

  var _loop = function _loop(i, len) {
    if (tabList[i].getAttribute('title')) {
      tabList[i].setAttribute('tabindex', '0');

      if (options.useAriaDP) {
        tabList[i].setAttribute('aria-describedby', 'AccessibleTooltip');
      } // set Event listeners


      if (unsupported) {
        tabList[i].addEventListener('focus', function () {
          setTooltip(tabList[i]);
        }, false);
        tabList[i].addEventListener('blur', function () {
          setTooltip(tabList[i], true);
        }, false);
      } // mouse option


      if (options.mouse) {
        tabList[i].addEventListener('mouseover', function () {
          setTooltip(tabList[i], false, true);
        }, false);
        tabList[i].addEventListener('mouseout', function () {
          setTooltip(tabList[i], true, true);
        }, false);
      }
    }
  };

  for (var i = 0, len = tabList.length; i < len; i++) {
    _loop(i, len);
  }
} // @license-end

/***/ }),
/* 445 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = enableDatePicker;
/* harmony export (immutable) */ __webpack_exports__["b"] = enableTimePicker;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_datepicker__ = __webpack_require__(446);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__jquery_timepicker__ = __webpack_require__(447);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__jquery_timepicker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__jquery_timepicker__);



function enableDatePicker() {
  var inputDatepicker = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input[type=text].datepicker');
  var inputDate = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input[type=date]:not(.datepicker)'); // Input date is supported ?

  var hasNativeDatePicker = function hasNativeDatePicker() {
    var elem = document.createElement('input');
    elem.setAttribute('type', 'date');
    elem.value = 'foo';
    return elem.type === 'date' && elem.value !== 'foo';
  };

  function frenchToEnglishDate(frenchDate, separatorIn, separatorOut) {
    console.log('frenchDate', frenchDate);
    var dateElem = frenchDate.split(separatorIn);
    return dateElem[2] + separatorOut + dateElem[1] + separatorOut + dateElem[0];
  }

  function showInternationalDate(argObj) {
    console.log('argObj', argObj);
    var argObjId = argObj.id || argObj.attr('id');
    var argObjDate = argObj.date || new Date(frenchToEnglishDate(argObj.val()), '-', '/');
    var inputHidden = document.getElementById("".concat(argObjId, "-hidden"));
    inputHidden.value = __WEBPACK_IMPORTED_MODULE_1__lib_datepicker__["a" /* default */].printFormattedDate(argObjDate, '%Y-%m-%d', false);
  }

  function pluginDatepicker($this) {
    var thisId = $this.attr('id');
    var thisName = $this.attr('name');
    var obj = {};
    $this.attr('data-name', thisName).removeAttr('name').after("<input type=\"hidden\" name=\"".concat(thisName, "\" id=\"").concat(thisId, "-hidden\" value=\"\">")).on('change', function () {
      var inputHidden = $this.nextAll("#".concat(thisId, "-hidden"));
      var formatDate = frenchToEnglishDate($this.val(), '/', '-');
      inputHidden.val(formatDate);
    });

    if ($this.val() !== '') {
      showInternationalDate($this);
    } // obj[thisId] = '%d/%m/%Y';


    obj[thisId] = '%Y-%m-%d';
    __WEBPACK_IMPORTED_MODULE_1__lib_datepicker__["a" /* default */].createDatePicker({
      formElements: obj,
      callbackFunctions: {
        datereturned: [showInternationalDate]
      }
    });
  }

  function nativeDatepicker($this) {
    $this.each(function () {
      var thisId = $this.attr('id');
      var thisValue = $this.val() || '';
      var thisName = $this.attr('name');
      $this.attr('data-name', thisName).removeAttr('name').after("<input type=\"hidden\" name=\"".concat(thisName, "\" id=\"").concat(thisId, "-hidden\" value=\"").concat(thisValue, "\">")).on('change', function () {
        var inputHidden = $this.next();
        inputHidden.val($this.val());
      });
    });
  }

  if (!hasNativeDatePicker()) {
    // If has no native datepicker (IE11)
    inputDatepicker.each(function (index, item) {
      pluginDatepicker(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(item));
    });
    inputDate.each(function (index, item) {
      pluginDatepicker(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(item));
    });
  } else {
    // If has native datepicker (Chrome, Firefox, Opera, Safari)
    inputDatepicker.each(function (index, item) {
      pluginDatepicker(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(item));
    });
    inputDate.each(function (index, item) {
      nativeDatepicker(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(item));
    });
  }
}
function enableTimePicker() {
  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.time input').timepicker({
    timeFormat: 'H:i'
  });
}

/***/ }),
/* 446 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! DatePicker v6.3.6 MIT/GPL2 @freqdec */
var datePickerController = function datePickerController() {
  "use strict";

  var _debug = false,
      isOpera = Object.prototype.toString.call(window.opera) === "[object Opera]",
      describedBy = "",
      languageInfo = parseUILanguage(),
      nbsp = String.fromCharCode(160),
      datePickers = {},
      weeksInYearCache = {},
      bespokeTitles = {},
      uniqueId = 0,
      finalOpacity = 100,
      cssAnimations = null,
      transitionEnd = "",
      buttonTabIndex = true,
      mouseWheel = true,
      deriveLocale = true,
      localeImport = false,
      _nodrag = false,
      langFileFolder = false,
      returnLocaleDate = false,
      kbEvent = false,
      dateParseFallback = true,
      cellFormat = "%d %F %Y",
      titleFormat = "%F %d, %Y",
      statusFormat = "",
      formatParts = isOpera ? ["%j"] : ["%j", " %F %Y"],
      dPartsRegExp = /%([d|j])/,
      mPartsRegExp = /%([M|F|m|n])/,
      yPartsRegExp = /%[y|Y]/,
      noSelectionRegExp = /date-picker-unused|out-of-range|day-disabled|not-selectable/,
      formatTestRegExp = /%([d|j|M|F|m|n|Y|y])/,
      formatSplitRegExp = /%([d|D|l|j|N|w|S|W|M|F|m|n|t|Y|y])/,
      rangeRegExp = /^((\d\d\d\d)(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01]))$/,
      wcDateRegExp = /^(((\d\d\d\d)|(\*\*\*\*))((0[1-9]|1[012])|(\*\*))(0[1-9]|[12][0-9]|3[01]))$/,
      wsCharClass = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029",
      // https://gist.github.com/padolsey/527683
  oldIE = function () {
    var undef,
        v = 3,
        div = document.createElement('div'),
        all = div.getElementsByTagName('i');

    while (div.innerHTML = '<!--[if gt IE ' + ++v + ']><i></i><![endif]-->', all[0]) {
      ;
    }

    return v > 4 ? v : undef;
  }();

  (function () {
    var scriptFiles = document.getElementsByTagName('script'),
        json = parseJSON(String(scriptFiles[scriptFiles.length - 1].innerHTML).replace(/[\n\r\s\t]+/g, " ").replace(/^\s+/, "").replace(/\s+$/, ""));

    if (_typeof(json) === "object" && !("err" in json)) {
      affectJSON(json);
    }

    ;

    if (deriveLocale && (typeof fdLocale === "undefined" ? "undefined" : _typeof(fdLocale)) != "object") {
      var head = document.getElementsByTagName("head")[0] || document.documentElement,
          loc = langFileFolder ? langFileFolder : scriptFiles[scriptFiles.length - 1].src.substr(0, scriptFiles[scriptFiles.length - 1].src.lastIndexOf("/")) + "/lang/",
          script,
          i;

      for (i = 0; i < languageInfo.length; i++) {
        script = document.createElement('script');
        script.type = "text/javascript";
        script.src = loc + languageInfo[i] + ".js";
        script.charSet = "utf-8";

        if (oldIE && oldIE < 8) {
          var bases = document.getElementsByTagName('base');

          if (bases.length && bases[0].childNodes.length) {
            bases[0].appendChild(script);
          } else {
            head.appendChild(script);
          }

          ;
          bases = null;
        } else {
          head.appendChild(script);
        }

        ;
      }

      ;
      script = null;
    } else {
      returnLocaleDate = true;
    }

    ;
  })();

  function removeChildNodes(elem) {
    while (elem.firstChild) {
      elem.removeChild(elem.firstChild);
    }

    ;
  }

  ;

  function addClass(e, c) {
    if (new RegExp("(^|[" + wsCharClass + "])" + c + "([" + wsCharClass + "]|$)").test(e.className)) {
      return;
    }

    ;
    e.className += (e.className ? " " : "") + c;
  }

  ;

  function removeClass(e, c) {
    e.className = !c ? "" : e.className.replace(new RegExp("(^|[" + wsCharClass + "])" + c + "([" + wsCharClass + "]|$)"), " ").replace(new RegExp("/^[" + wsCharClass + "][" + wsCharClass + "]*/"), '').replace(new RegExp("/[" + wsCharClass + "][" + wsCharClass + "]*$/"), '');
  }

  ; // Attempts to parse the current language from the HTML element. Defaults to "en" if none given

  function parseUILanguage() {
    var languageTag = document.getElementsByTagName('html')[0].getAttribute('lang') || document.getElementsByTagName('html')[0].getAttribute('xml:lang');
    languageTag = !languageTag ? "en" : languageTag.toLowerCase();
    return languageTag.search(/^([a-z]{2,3})-([a-z]{2})$/) != -1 ? [languageTag.match(/^([a-z]{2,3})-([a-z]{2})$/)[1], languageTag] : [languageTag];
  }

  ; // Cross browser split from http://blog.stevenlevithan.com/archives/cross-browser-split

  var cbSplit = function cbSplit(str, separator, limit) {
    // if `separator` is not a regex, use the native `split`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return cbSplit._nativeSplit.call(str, separator, limit);
    }

    ;
    var output = [],
        lastLastIndex = 0,
        flags = "",
        separator = RegExp(separator.source, "g"),
        separator2,
        match,
        lastIndex,
        lastLength;
    str = str + "";

    if (!cbSplit._compliantExecNpcg) {
      separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags);
    }

    ;
    /* behavior for `limit`: if it's...
     - `undefined`: no limit.
     - `NaN` or zero: return an empty array.
     - a positive number: use `Math.floor(limit)`.
     - a negative number: no limit.
     - other: type-convert, then use the above rules. */

    if (limit === undefined || +limit < 0) {
      limit = Infinity;
    } else {
      limit = Math.floor(+limit);

      if (!limit) {
        return [];
      }

      ;
    }

    ;

    while (match = separator.exec(str)) {
      lastIndex = match.index + match[0].length; // `separator.lastIndex` is not reliable cross-browser

      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index)); // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups

        if (!cbSplit._compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function () {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undefined) {
                match[i] = undefined;
              }

              ;
            }

            ;
          });
        }

        ;

        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }

        ;
        lastLength = match[0].length;
        lastLastIndex = lastIndex;

        if (output.length >= limit) {
          break;
        }

        ;
      }

      ;

      if (separator.lastIndex === match.index) {
        // avoid an infinite loop
        separator.lastIndex++;
      }

      ;
    }

    ;

    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }

      ;
    } else {
      output.push(str.slice(lastLastIndex));
    }

    ;
    return output.length > limit ? output.slice(0, limit) : output;
  }; // NPCG: nonparticipating capturing group


  cbSplit._compliantExecNpcg = /()??/.exec("")[1] === undefined;
  cbSplit._nativeSplit = String.prototype.split; // Affects the JSON passed to the script

  function affectJSON(json) {
    if (!(_typeof(json) === "object")) {
      return;
    }

    ;
    var key,
        switchObj = {
      "debug": function debug(value) {
        _debug = !!value;
        return true;
      },
      "lang": function lang(value) {
        if (typeof value === "string" && value.search(/^[a-z]{2,3}(-([a-z]{2}))?$/i) != -1) {
          languageInfo = [value.toLowerCase()];
          returnLocaleDate = true;
          deriveLocale = true;
        }

        ;
        return true;
      },
      "nodrag": function nodrag(value) {
        _nodrag = !!value;
        return true;
      },
      "buttontabindex": function buttontabindex(value) {
        buttonTabIndex = !!value;
        return true;
      },
      "derivelocale": function derivelocale(value) {
        deriveLocale = !!value;
        return true;
      },
      "mousewheel": function mousewheel(value) {
        mouseWheel = !!value;
        return true;
      },
      "cellformat": function cellformat(value) {
        if (typeof value === "string") {
          parseCellFormat(value);
        }

        ;
        return true;
      },
      "titleformat": function titleformat(value) {
        if (typeof value === "string") {
          titleFormat = value;
        }

        ;
        return true;
      },
      "statusformat": function statusformat(value) {
        if (typeof value === "string") {
          statusFormat = value;
        }

        ;
        return true;
      },
      "describedby": function describedby(value) {
        if (typeof value === "string") {
          describedBy = value;
        }

        ;
        return true;
      },
      "finalopacity": function finalopacity(value) {
        if (typeof value === 'number' && +value > 20 && +value <= 100) {
          finalOpacity = parseInt(value, 10);
        }

        ;
        return true;
      },
      "bespoketitles": function bespoketitles(value) {
        if (_typeof(value) === "object") {
          bespokeTitles = {};

          for (var dt in value) {
            if (value.hasOwnProperty(dt) && String(dt).match(wcDateRegExp) != -1) {
              bespokeTitles[dt] = String(value[dt]);
            }

            ;
          }

          ;
        }

        ;
        return true;
      },
      "dateparsefallback": function dateparsefallback(value) {
        dateParseFallback = !!value;
        return true;
      },
      "languagefilelocation": function languagefilelocation(value) {
        langFileFolder = value;
        return true;
      },
      "_default": function _default() {
        if (_debug) {
          throw "Unknown key located within JSON data: " + key;
        }

        ;
        return true;
      }
    };

    for (key in json) {
      if (!json.hasOwnProperty(key)) {
        continue;
      }

      ;

      (switchObj.hasOwnProperty(String(key).toLowerCase()) && switchObj[String(key).toLowerCase()] || switchObj._default)(json[key]);
    }

    ;
  }

  ; // Parses the JSON passed either between the script tags or by using the
  // setGlobalOptions method

  function parseJSON(str) {
    if (!(typeof str === 'string') || str == "") {
      return {};
    }

    ;

    try {
      // Does a JSON (native or not) Object exist
      if ((typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === "object" && JSON.parse) {
        return window.JSON.parse(str); // Genious code taken from: http://kentbrewster.com/badges/
      } else if (/debug|lang|nodrag|buttontabindex|derivelocale|mousewheel|cellformat|titleformat|statusformat|describedby|finalopacity|bespoketitles|dateparsefallback/.test(str.toLowerCase())) {
        var f = Function(['var document,top,self,window,parent,Number,Date,Object,Function,', 'Array,String,Math,RegExp,Image,ActiveXObject;', 'return (', str.replace(/<\!--.+-->/gim, '').replace(/\bfunction\b/g, 'function-'), ');'].join(''));
        return f();
      }

      ;
    } catch (e) {}

    ;

    if (_debug) {
      throw "Could not parse the JSON object";
    }

    ;
    return {
      "err": 1
    };
  }

  ; // Parses the cell format to use whenever the datepicker has keyboard focus

  function parseCellFormat(value) {
    if (isOpera) {
      // Don't use hidden text for opera due to the default
      // "blue" browser focus outline stretching outside of the viewport
      // and degrading visual accessibility. Harsh & hackish though...
      formatParts = ["%j"];
      cellFormat = "%j %F %Y";
      return;
    }

    ; // If no day part stipulated then use presets

    if (value.match(/%([d|j])/) == -1) {
      return;
    }

    ; // Basic split on the %j or %d modifiers

    formatParts = cbSplit(value, /%([d|j])/);
    cellFormat = value;
  }

  ;

  function pad(value, length) {
    length = Math.min(4, length || 2);
    return "0000".substr(0, length - Math.min(String(value).length, length)) + value;
  }

  ; // Very, very basic event functions

  function _addEvent(obj, type, fn) {
    if (obj.addEventListener) {
      obj.addEventListener(type, fn, true);
    } else if (obj.attachEvent) {
      obj.attachEvent("on" + type, fn);
    }

    ;
  }

  ;

  function _removeEvent(obj, type, fn) {
    try {
      if (obj.removeEventListener) {
        obj.removeEventListener(type, fn, true);
      } else if (obj.detachEvent) {
        obj.detachEvent("on" + type, fn);
      }

      ;
    } catch (err) {}

    ;
  }

  ;

  function _stopEvent(e) {
    e = e || document.parentWindow.event;

    if (e.stopPropagation) {
      e.stopPropagation();
      e.preventDefault();
    }

    ;

    if (oldIE) {
      e.cancelBubble = true;
      e.returnValue = false;
    }

    ;
    return false;
  }

  ;

  function setARIARole(element, role) {
    if (element && element.tagName) {
      element.setAttribute("role", role);
    }

    ;
  }

  ;

  function setARIAProperty(element, property, value) {
    if (element && element.tagName) {
      element.setAttribute("aria-" + property, value);
    }

    ;
  }

  ; // Sets a tabindex attribute on an element, bends over for IE.

  function setTabIndex(e, i) {
    e.setAttribute(oldIE ? "tabIndex" : "tabindex", i);
    e.tabIndex = i;
  }

  ;

  function dateToYYYYMMDD(dt) {
    return dt instanceof Date && !isNaN(dt) ? dt.getFullYear() + pad(dt.getMonth() + 1) + "" + pad(dt.getDate()) : dt;
  }

  ; // The datePicker object itself

  function datePicker(options) {
    this.dateSet = null;
    this.timerSet = false;
    this.visible = false;
    this.fadeTimer = null;
    this.timer = null;
    this.yearInc = 0;
    this.monthInc = 0;
    this.dayInc = 0;
    this.mx = 0;
    this.my = 0;
    this.x = 0;
    this.y = 0;
    this.created = false;
    this.disabled = false;
    this.opacity = 0;
    this.opacityTo = 100;
    this.finalOpacity = 100;
    this.inUpdate = false;
    this.kbEventsAdded = false;
    this.fullCreate = false;
    this.selectedTD = null;
    this.cursorTD = null;
    this.cursorDate = options.cursorDate ? options.cursorDate : "", this.date = options.cursorDate ? new Date(+options.cursorDate.substr(0, 4), +options.cursorDate.substr(4, 2) - 1, +options.cursorDate.substr(6, 2), 5, 0, 0) : new Date();
    this.defaults = {};
    this.dynDisabledDates = {};
    this.dateList = [];
    this.bespokeClass = options.bespokeClass;
    this.firstDayOfWeek = localeImport.firstDayOfWeek;
    this.interval = new Date();
    this.clickActivated = false;
    this.showCursor = false;
    this.noFocus = true;
    this.kbEvent = false;
    this.delayedUpdate = false;
    this.bespokeTitles = {};
    this.bespokeTabIndex = options.bespokeTabIndex;

    for (var thing in options) {
      if (!options.hasOwnProperty(thing) || String(thing).search(/^(callbacks|formElements|enabledDates|disabledDates)$/) != -1) {
        continue;
      }

      ;
      this[thing] = options[thing];
    }

    ;

    if (oldIE) {
      this.iePopUp = null;
    }

    ;

    for (var i = 0, prop; prop = ["callbacks", "formElements"][i]; i++) {
      this[prop] = {};

      if (prop in options) {
        for (thing in options[prop]) {
          if (options[prop].hasOwnProperty(thing)) {
            this[prop][thing] = options[prop][thing];
          }

          ;
        }

        ;
      }

      ;
    }

    ; // Adjust time to stop daylight savings madness on windows

    this.date.setHours(5); // Called from an associated form elements onchange event

    this.changeHandler = function () {
      // In a perfect world this shouldn't ever happen
      if (o.disabled) {
        return;
      }

      ;
      o.setDateFromInput();
      o.callback("dateset", o.createCbArgObj());
    }; // Creates the object passed to the callback functions


    this.createCbArgObj = function () {
      return this.dateSet ? {
        "id": this.id,
        "date": this.dateSet,
        "dd": pad(this.date.getDate()),
        "mm": pad(this.date.getMonth() + 1),
        "yyyy": this.date.getFullYear()
      } : {
        "id": this.id,
        "date": null,
        "dd": null,
        "mm": null,
        "yyyy": null
      };
    }; // Attempts to grab the window scroll offsets


    this.getScrollOffsets = function () {
      if (typeof window.pageYOffset == 'number') {
        //Netscape compliant
        return [window.pageXOffset, window.pageYOffset];
      } else if (document.body && (document.body.scrollLeft || document.body.scrollTop)) {
        //DOM compliant
        return [document.body.scrollLeft, document.body.scrollTop];
      } else if (document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {
        //IE6 standards compliant mode
        return [document.documentElement.scrollLeft, document.documentElement.scrollTop];
      }

      ;
      return [0, 0];
    }; // Calculates the current list of disabled & enabled dates for a specific year/month


    this.getDateExceptions = function (y, m) {
      m = pad(m);
      var obj = {},
          lower = o.firstDateShown,
          upper = o.lastDateShown,
          rLength = o.dateList.length,
          rNumber,
          workingDt,
          workingY,
          workingM,
          dtLower,
          dtUpper,
          i,
          dt,
          dt1,
          dt2,
          rngLower,
          rngUpper,
          cDate;

      if (!upper || !lower) {
        lower = o.firstDateShown = y + pad(m) + "01";
        upper = o.lastDateShown = y + pad(m) + pad(daysInMonth(m, y));
      }

      ;
      dtLower = Number(lower.substr(0, 6));
      dtUpper = Number(upper.substr(0, 6));
      workingDt = String(dtLower);

      while (+workingDt <= dtUpper) {
        workingY = workingDt.substr(0, 4);
        workingM = workingDt.substr(4, 2);

        for (rNumber = 0; rNumber < rLength; rNumber++) {
          dt1 = String(o.dateList[rNumber].rLow).replace(/^(\*\*\*\*)/, workingY).replace(/^(\d\d\d\d)(\*\*)/, "$1" + workingM);
          dt2 = String(o.dateList[rNumber].rHigh).replace(/^(\*\*\*\*)/, workingY).replace(/^(\d\d\d\d)(\*\*)/, "$1" + workingM); // Single date

          if (dt2 == 1) {
            if (+dt1 >= +o.firstDateShown && +dt1 <= +o.lastDateShown) {
              obj[dt1] = o.dateList[rNumber].type;
            }

            ;
            continue;
          }

          ; // Date Range

          if (dt1 <= dt2 && workingDt >= dt1.substr(0, 6) && workingDt <= dt2.substr(0, 6)) {
            rngLower = Math.max(dt1, Math.max(String(workingDt) + "01", this.firstDateShown));
            rngUpper = Math.min(dt2, Math.min(String(workingDt) + "31", this.lastDateShown));

            for (i = rngLower; i <= rngUpper; i++) {
              obj[i] = o.dateList[rNumber].type;
            }

            ;
          }

          ;
        }

        ; // Let the Date Object take care of month overflowss

        workingDt = new Date(workingY, +workingM, 2);
        workingDt = workingDt.getFullYear() + "" + pad(workingDt.getMonth() + 1);
      }

      ;
      return obj;
    }; // Repositions the datepicker beside the button - to the bottom by
    // preference but to the top if there is not enough room to display the
    // entire U.I. at the bottom (it really should be updated to favour
    // bottom positioning if not enough room to display the entire U.I. at
    // the top in that scenario though)


    this.reposition = function () {
      if (!o.created || o.staticPos) {
        return;
      }

      ;
      o.div.style.visibility = "hidden";
      o.div.style.left = o.div.style.top = "0px";
      o.div.style.display = "block";
      var osh = o.div.offsetHeight,
          osw = o.div.offsetWidth,
          elem = document.getElementById('fd-but-' + o.id),
          pos = o.truePosition(elem),
          trueBody = document.compatMode && document.compatMode != "BackCompat" ? document.documentElement : document.body,
          sOffsets = o.getScrollOffsets(),
          scrollTop = sOffsets[1],
          scrollLeft = sOffsets[0],
          tSpace = parseInt(pos[1] - 2) - parseInt(scrollTop),
          bSpace = parseInt(trueBody.clientHeight + scrollTop) - parseInt(pos[1] + elem.offsetHeight + 2);
      o.div.style.visibility = "visible";
      o.div.style.left = Number(parseInt(trueBody.clientWidth + scrollLeft) < parseInt(osw + pos[0]) ? Math.abs(parseInt(trueBody.clientWidth + scrollLeft - osw)) : pos[0]) + "px";
      o.div.style.top = bSpace > tSpace ? Math.abs(parseInt(pos[1] + elem.offsetHeight + 2)) + "px" : Math.abs(parseInt(pos[1] - (osh + 2))) + "px";

      if (oldIE === 6) {
        o.iePopUp.style.top = o.div.style.top;
        o.iePopUp.style.left = o.div.style.left;
        o.iePopUp.style.width = osw + "px";
        o.iePopUp.style.height = osh - 2 + "px";
      }

      ;
    };

    this.removeCursorHighlight = function () {
      var td = document.getElementById(o.id + "-date-picker-hover");

      if (td) {
        removeClass(td, "date-picker-hover");
      }

      ;
    };

    this.addCursorHighlight = function () {
      var td = document.getElementById(o.id + "-date-picker-hover");

      if (td) {
        addClass(td, "date-picker-hover");
      }

      ;
    }; // Resets the tabindex of the previously focused cell


    this.removeOldFocus = function () {
      var td = document.getElementById(o.id + "-date-picker-hover");

      if (td) {
        try {
          setTabIndex(td, -1);
          removeClass(td, "date-picker-hover");
          td.id = "";
          td.onblur = null;
          td.onfocus = null;
        } catch (err) {}

        ;
      }

      ;
    }; // Sets the tabindex & focus on the currently highlighted cell


    this.setNewFocus = function () {
      var td = document.getElementById(o.id + "-date-picker-hover");

      if (td) {
        try {
          setTabIndex(td, 0);

          if (this.showCursor) {
            addClass(td, "date-picker-hover");
          }

          ; // If opened with the keyboard then add focus & blur events to the cell

          if (!this.clickActivated) {
            td.onblur = o.onblur;
            td.onfocus = o.onfocus;
          }

          ; // If opened with the keyboard (and not in opera) then add a screen-reader friendly date format

          if (!isOpera && !this.clickActivated) {
            o.addAccessibleDate();
          }

          ; // Try to programmatically set focus on the cell

          if (!this.noFocus && !this.clickActivated) {
            setTimeout(function () {
              try {
                td.focus();
              } catch (err) {}

              ;
            }, 0);
          }

          ;
        } catch (err) {}

        ;
      }

      ;
    }; // Adds a screen-reader friendly date to the current cell whenever
    // the datepicker has been opened with the keyboard


    this.addAccessibleDate = function () {
      var td = document.getElementById(o.id + "-date-picker-hover");

      if (td && !td.getElementsByTagName("span").length) {
        var ymd = td.className.match(/cd-([\d]{4})([\d]{2})([\d]{2})/),
            noS = td.className.search(noSelectionRegExp) != -1,
            spn = document.createElement('span'),
            spnC;
        spn.className = "fd-screen-reader";
        removeChildNodes(td);

        if (noS) {
          spnC = spn.cloneNode(false);
          spnC.appendChild(document.createTextNode(getTitleTranslation(13)));
          td.appendChild(spnC);
        }

        ;

        for (var pt = 0, part; part = formatParts[pt]; pt++) {
          if (part == "%j" || part == "%d") {
            td.appendChild(document.createTextNode(_printFormattedDate(new Date(ymd[1], +ymd[2] - 1, ymd[3], 5, 0, 0), part, true)));
          } else {
            spnC = spn.cloneNode(false);
            spnC.appendChild(document.createTextNode(_printFormattedDate(new Date(ymd[1], +ymd[2] - 1, ymd[3], 5, 0, 0), part, true)));
            td.appendChild(spnC);
          }

          ;
        }

        ;
      }

      ;
    }; // Sets the current cursor to a specific date


    this.setCursorDate = function (yyyymmdd) {
      if (String(yyyymmdd).search(/^([0-9]{8})$/) != -1) {
        this.date = new Date(+yyyymmdd.substr(0, 4), +yyyymmdd.substr(4, 2) - 1, +yyyymmdd.substr(6, 2), 5, 0, 0);
        this.cursorDate = yyyymmdd;

        if (this.staticPos) {
          this.updateTable();
        }

        ;
      }

      ;
    }; // Updates the table used to display the datepicker


    this.updateTable = function (noCallback) {
      if (!o || o.inUpdate || !o.created) {
        return;
      }

      ; // We are currently updating (used to stop public methods from firing)

      o.inUpdate = true; // Remove the focus from the currently highlighted cell

      o.removeOldFocus();
      o.div.dir = localeImport.rtl ? "rtl" : "ltr"; // If the update timer initiated

      if (o.timerSet && !o.delayedUpdate) {
        // Are we incrementing/decrementing the month
        if (o.monthInc) {
          var n = o.date.getDate(),
              d = new Date(o.date);
          d.setDate(2);
          d.setMonth(d.getMonth() + o.monthInc * 1); // Don't go over the days in the month

          d.setDate(Math.min(n, daysInMonth(d.getMonth(), d.getFullYear())));
          o.date = new Date(d);
        } else {
          o.date.setDate(Math.min(o.date.getDate() + o.dayInc, daysInMonth(o.date.getMonth() + o.monthInc, o.date.getFullYear() + o.yearInc)));
          o.date.setMonth(o.date.getMonth() + o.monthInc);
          o.date.setFullYear(o.date.getFullYear() + o.yearInc);
        }

        ;
      }

      ; // Make sure the internal date is within range

      o.outOfRange(); // Disable/enable the today button

      if (!o.noToday) {
        o.disableTodayButton();
      }

      ; // Disable/enable the month & year buttons

      o.showHideButtons(o.date);
      var cd = o.date.getDate(),
          cm = o.date.getMonth(),
          cy = o.date.getFullYear(),
          cursorDate = String(cy) + pad(cm + 1) + pad(cd),
          tmpDate = new Date(cy, cm, 1, 5, 0, 0);
      tmpDate.setHours(5);
      var dt,
          dts,
          cName,
          row,
          td,
          i,
          currentDate,
          cellAdded,
          col,
          currentStub,
          abbr,
          bespokeRenderClass,
          spnC,
          dateSetD,
          selectable,
          weekDay,
          // Weekday of the fist of the month
      weekDayC = (tmpDate.getDay() + 6) % 7,
          // The column index this weekday will occupy
      firstColIndex = (weekDayC - o.firstDayOfWeek + 7) % 7 - 1,
          // The number of days in the current month
      dpm = daysInMonth(cm, cy),
          // Today as a Date Object
      today = new Date(),
          // Today as a YYYYMMDD String
      today = today.getFullYear() + pad(today.getMonth() + 1) + pad(today.getDate()),
          // A Sring date stub in a YYYYMM format for the current date
      stub = String(tmpDate.getFullYear()) + pad(tmpDate.getMonth() + 1),
          //
      cellAdded = [4, 4, 4, 4, 4, 4],
          // The first day of the previous month as a Date Object
      lm = new Date(cy, cm - 1, 1, 5, 0, 0),
          // The first day of the next month as a Date Object
      nm = new Date(cy, cm + 1, 1, 5, 0, 0),
          // The number of days in the previous month
      daySub = daysInMonth(lm.getMonth(), lm.getFullYear()),
          // YYYYMM String date stub for the next month
      stubN = String(nm.getFullYear()) + pad(nm.getMonth() + 1),
          // YYYYMM String date stub for the previous month
      stubP = String(lm.getFullYear()) + pad(lm.getMonth() + 1),
          weekDayN = (nm.getDay() + 6) % 7,
          weekDayP = (lm.getDay() + 6) % 7,
          // A SPAN node to clone when adding dates to individual cells
      spn = document.createElement('span'); // Give the "fd-screen-reader" class to the span in order to hide them in the UI
      // but keep them accessible to screen-readers

      spn.className = "fd-screen-reader"; // The first & last dates shown on the datepicker UI - could be a date from the previous & next month respectively

      o.firstDateShown = !o.constrainSelection && o.fillGrid && 0 - firstColIndex < 1 ? String(stubP) + (daySub + (0 - firstColIndex)) : stub + "01";
      o.lastDateShown = !o.constrainSelection && o.fillGrid ? stubN + pad(41 - firstColIndex - dpm) : stub + String(dpm); // Store a reference to the current YYYYMM String representation of the current month

      o.currentYYYYMM = stub;
      bespokeRenderClass = o.callback("redraw", {
        id: o.id,
        dd: pad(cd),
        mm: pad(cm + 1),
        yyyy: cy,
        firstDateDisplayed: o.firstDateShown,
        lastDateDisplayed: o.lastDateShown
      }) || {}; // An Object of dates that have been explicitly disabled (1) or enabled (0)

      dts = o.getDateExceptions(cy, cm + 1); // Double check current date within limits etc

      o.checkSelectedDate(); //

      dateSetD = o.dateSet != null ? o.dateSet.getFullYear() + pad(o.dateSet.getMonth() + 1) + pad(o.dateSet.getDate()) : false; // If we have selected a date then set its ARIA selected property
      // to false. We then set the ARIA selected property to true on the
      // newly selected cell after redrawing the table

      if (this.selectedTD != null) {
        setARIAProperty(this.selectedTD, "selected", false);
        this.selectedTD = null;
      }

      ; // Redraw all of the table cells representing the date parts of the UI

      for (var curr = 0; curr < 42; curr++) {
        // Current row
        row = Math.floor(curr / 7); // Current TD node

        td = o.tds[curr]; // Clone our SPAN node

        spnC = spn.cloneNode(false); // Remove any previous contents from the cell

        removeChildNodes(td); // If the current cell contains a date

        if (curr > firstColIndex && curr <= firstColIndex + dpm || o.fillGrid) {
          currentStub = stub;
          weekDay = weekDayC;
          dt = curr - firstColIndex;
          cName = [];
          selectable = true; // Are we drawing last month

          if (dt < 1) {
            dt = daySub + dt;
            currentStub = stubP;
            weekDay = weekDayP;
            selectable = !o.constrainSelection;
            cName.push("month-out"); // Are we drawing next month
          } else if (dt > dpm) {
            dt -= dpm;
            currentStub = stubN;
            weekDay = weekDayN;
            selectable = !o.constrainSelection;
            cName.push("month-out");
          }

          ; // Calcuate this cells weekday

          weekDay = (weekDay + dt + 6) % 7; // Push a classname representing the weekday e.g. "day-3"

          cName.push("day-" + weekDay + " cell-" + curr); // A YYYYMMDD String representation of this cells date

          currentDate = currentStub + String(dt < 10 ? "0" : "") + dt; // If this cells date is out of range

          if (o.rangeLow && +currentDate < +o.rangeLow || o.rangeHigh && +currentDate > +o.rangeHigh) {
            // Add a classname to style the cell and stop selection
            td.className = "out-of-range"; // Reset this TD nodes title attribute

            td.title = ""; // Append the cells date as a text node to the TD

            td.appendChild(document.createTextNode(dt)); // Jaysus, what the feck does this line do again...

            if (o.showWeeks) {
              cellAdded[row] = Math.min(cellAdded[row], 2);
            }

            ; // This cells date is within the lower & upper ranges (or no ranges have been defined)
          } else {
            // If it's a date from last or next month and the "constrainSelection" option
            // is false then give the cell a CD-YYYYMMDD class
            if (selectable) {
              td.title = titleFormat ? _printFormattedDate(new Date(+String(currentStub).substr(0, 4), +String(currentStub).substr(4, 2) - 1, +dt, 5, 0, 0), titleFormat, true) : "";
              cName.push("cd-" + currentDate + " yyyymmdd-" + currentDate + " yyyymm-" + currentStub + " mmdd-" + currentStub.substr(4, 2) + pad(dt)); // Otherwise give a "not-selectable" class (which shouldn't be styled in any way, it's for internal use)
            } else {
              td.title = titleFormat ? getTitleTranslation(13) + " " + _printFormattedDate(new Date(+String(currentStub).substr(0, 4), +String(currentStub).substr(4, 2) - 1, +dt, 5, 0, 0), titleFormat, true) : "";
              cName.push("yyyymmdd-" + currentDate + " yyyymm-" + currentStub + " mmdd-" + currentStub.substr(4, 2) + pad(dt) + " not-selectable");
            }

            ; // Add a classname if the current cells date is today

            if (currentDate == today) {
              cName.push("date-picker-today");
            }

            ; // If this cell represents the currently selected date

            if (dateSetD == currentDate) {
              // Add a classname (for styling purposes)
              cName.push("date-picker-selected-date"); // Set the ARIA selected property to true

              setARIAProperty(td, "selected", "true"); // And cache a reference to the current cell

              this.selectedTD = td;
            }

            ; // If the current cell has been explicitly disabled

            if (currentDate in dts && dts[currentDate] == 1 || // or
            // ... the current weekday has been disabled
            o.disabledDays[weekDay] && // ... and the current date has not been explicitly enabled
            !(currentDate in dts && dts[currentDate] == 0)) {
              // Add a classname to style the cell and stop selection
              cName.push("day-disabled"); // Update the current cells title to say "Disabled date: ..." (or whatever the translation says)

              if (titleFormat && selectable) {
                td.title = getTitleTranslation(13) + " " + td.title;
              }

              ;
            }

            ; // Has the redraw callback given us a bespoke classname to add to this cell

            if (currentDate in bespokeRenderClass) {
              cName.push(bespokeRenderClass[currentDate]);
            }

            ; // Do we need to highlight this cells weekday representation

            if (o.highlightDays[weekDay]) {
              cName.push("date-picker-highlight");
            }

            ; // Is the current onscreen cursor set to this cells date

            if (cursorDate == currentDate) {
              td.id = o.id + "-date-picker-hover";
            }

            ; // Add the date to the TD cell as a text node. Note: If the datepicker has been given keyboard
            // events, this textnode is replaced by a more screen-reader friendly date during the focus event

            td.appendChild(document.createTextNode(dt)); // Add the classnames to the TD node

            td.className = cName.join(" "); // If the UI displays week numbers then update the celladded

            if (o.showWeeks) {
              cellAdded[row] = Math.min(cName[0] == "month-out" ? 3 : 1, cellAdded[row]);
            }

            ;
          }

          ; // The current TD node is empty i.e. represents no date in the UI
        } else {
          // Add a classname to style the cell
          td.className = "date-picker-unused"; // Add a non-breaking space to unused TD node (for IEs benefit mostly)

          td.appendChild(document.createTextNode(nbsp)); // Reset the TD nodes title attribute

          td.title = "";
        }

        ; // Do we update the week number for this row

        if (o.showWeeks && curr - row * 7 == 6) {
          removeChildNodes(o.wkThs[row]);
          o.wkThs[row].appendChild(document.createTextNode(cellAdded[row] == 4 && !o.fillGrid ? nbsp : getWeekNumber(cy, cm, curr - firstColIndex - 6)));
          o.wkThs[row].className = "date-picker-week-header" + ["", "", " out-of-range", " month-out", ""][cellAdded[row]];
        }

        ;
      }

      ; // Update the UI title bar displaying the year & month

      var span = o.titleBar.getElementsByTagName("span");
      removeChildNodes(span[0]);
      removeChildNodes(span[1]);
      span[0].appendChild(document.createTextNode(getMonthTranslation(cm, false) + nbsp));
      span[1].appendChild(document.createTextNode(cy)); // If we are in an animation

      if (o.timerSet) {
        // Speed the timer up a little bit to make the pause between updates quicker
        o.timerInc = 50 + Math.round((o.timerInc - 50) / 1.8); // Recall this function in a timeout

        o.timer = window.setTimeout(o.updateTable, o.timerInc);
      }

      ; // We are not currently updating the UI

      o.inUpdate = o.delayedUpdate = false; // Focus on the correct TD node

      o.setNewFocus();
    }; // Removes all scaffold from the DOM & events from memory


    this.destroy = function () {
      // Remove the button if it exists
      if (document.getElementById("fd-but-" + this.id)) {
        document.getElementById("fd-but-" + this.id).parentNode.removeChild(document.getElementById("fd-but-" + this.id));
      }

      ;

      if (!this.created) {
        return;
      }

      ; // Event cleanup for Internet Explorers benefit

      _removeEvent(this.table, "mousedown", o.onmousedown);

      _removeEvent(this.table, "mouseover", o.onmouseover);

      _removeEvent(this.table, "mouseout", o.onmouseout);

      _removeEvent(document, "mousedown", o.onmousedown);

      _removeEvent(document, "mouseup", o.clearTimer);

      if (window.addEventListener && !window.devicePixelRatio) {
        try {
          window.removeEventListener('DOMMouseScroll', this.onmousewheel, false);
        } catch (err) {}

        ;
      } else {
        _removeEvent(document, "mousewheel", this.onmousewheel);

        _removeEvent(window, "mousewheel", this.onmousewheel);
      }

      ;
      o.removeOnFocusEvents();
      clearTimeout(o.fadeTimer);
      clearTimeout(o.timer);

      if (oldIE === 6 && !o.staticPos) {
        try {
          o.iePopUp.parentNode.removeChild(o.iePopUp);
          o.iePopUp = null;
        } catch (err) {}

        ;
      }

      ;

      if (this.div && this.div.parentNode) {
        this.div.parentNode.removeChild(this.div);
      }

      ;
      o = null;
    };

    this.resizeInlineDiv = function () {
      o.div.style.width = o.table.offsetWidth + "px";
      o.div.style.height = o.table.offsetHeight + "px";
    };

    this.reset = function () {
      var elemID, elem;

      for (elemID in o.formElements) {
        elem = document.getElementById(elemID);

        if (elem) {
          if (elem.tagName.toLowerCase() == "select") {
            elem.selectedIndex = o.defaultVals[elemID];
          } else {
            elem.value = o.defaultVals[elemID];
          }

          ;
        }

        ;
      }

      ;
      o.changeHandler();
    }; // Creates the DOM scaffold


    this.create = function () {
      if (document.getElementById("fd-" + this.id)) {
        return;
      }

      ;
      var tr, row, col, tableHead, tableBody, tableFoot;
      this.noFocus = true;

      function createTH(details) {
        var th = document.createElement('th');

        if (details.thClassName) {
          th.className = details.thClassName;
        }

        ;

        if (details.colspan) {
          th.setAttribute(oldIE ? 'colSpan' : "colspan", details.colspan);
        }

        ;
        th.unselectable = "on";
        return th;
      }

      ;

      function createThAndButton(tr, obj) {
        for (var i = 0, details; details = obj[i]; i++) {
          var th = createTH(details);
          tr.appendChild(th);
          var but = document.createElement('span');
          but.className = details.className;
          but.id = o.id + details.id;
          but.appendChild(document.createTextNode(details.text || o.nbsp));
          but.title = details.title || "";
          but.unselectable = "on";
          th.appendChild(but);
        }

        ;
      }

      ;
      this.div = document.createElement('div');
      this.div.id = "fd-" + this.id;
      this.div.className = "date-picker" + (cssAnimations ? " fd-dp-fade " : "") + this.bespokeClass; // Attempt to hide the div from screen readers during content creation

      this.div.style.visibility = "hidden";
      this.div.style.display = "none"; // Set the ARIA describedby property if the required block available

      if (this.describedBy && document.getElementById(this.describedBy)) {
        setARIAProperty(this.div, "describedby", this.describedBy);
      }

      ; // Set the ARIA labelled property if the required label available

      if (this.labelledBy) {
        setARIAProperty(this.div, "labelledby", this.labelledBy.id);
      }

      ;
      this.idiv = document.createElement('div');
      this.table = document.createElement('table');
      this.table.className = "date-picker-table";
      this.table.onmouseover = this.onmouseover;
      this.table.onmouseout = this.onmouseout;
      this.table.onclick = this.onclick;

      if (this.finalOpacity < 100) {
        this.idiv.style.opacity = Math.min(Math.max(parseInt(this.finalOpacity, 10) / 100, .2), 1);
      }

      ;

      if (this.staticPos) {
        this.table.onmousedown = this.onmousedown;
      }

      ;
      this.div.appendChild(this.idiv);
      this.idiv.appendChild(this.table);
      var dragEnabledCN = !this.dragDisabled ? " drag-enabled" : "";

      if (!this.staticPos) {
        this.div.style.visibility = "hidden";
        this.div.className += dragEnabledCN;
        document.getElementsByTagName('body')[0].appendChild(this.div);

        if (oldIE === 6) {
          this.iePopUp = document.createElement('iframe');
          this.iePopUp.src = "javascript:'<html></html>';";
          this.iePopUp.setAttribute('className', 'iehack'); // Remove iFrame from tabIndex

          this.iePopUp.setAttribute("tabIndex", -1); // Hide it from ARIA aware technologies

          setARIARole(this.iePopUp, "presentation");
          setARIAProperty(this.iePopUp, "hidden", "true");
          this.iePopUp.scrolling = "no";
          this.iePopUp.frameBorder = "0";
          this.iePopUp.name = this.iePopUp.id = this.id + "-iePopUpHack";
          document.body.appendChild(this.iePopUp);
        }

        ; // Aria "hidden" property for non active popup datepickers

        setARIAProperty(this.div, "hidden", "true");
      } else {
        var elem = document.getElementById(this.positioned ? this.positioned : this.id);

        if (!elem) {
          this.div = null;

          if (_debug) {
            throw this.positioned ? "Could not locate a datePickers associated parent element with an id:" + this.positioned : "Could not locate a datePickers associated input with an id:" + this.id;
          }

          ;
          return;
        }

        ;
        this.div.className += " static-datepicker";

        if (this.positioned) {
          elem.appendChild(this.div);
        } else {
          elem.parentNode.insertBefore(this.div, elem.nextSibling);
        }

        ;

        if (this.hideInput) {
          for (var elemID in this.formElements) {
            elem = document.getElementById(elemID);

            if (elem) {
              elem.className += " fd-hidden-input";
            }

            ;
          }

          ;
        }

        ;
        setTimeout(this.resizeInlineDiv, 300);
      }

      ; // ARIA Application role

      setARIARole(this.div, "application"); //setARIARole(this.table, "grid");

      if (this.statusFormat) {
        tableFoot = document.createElement('tfoot');
        this.table.appendChild(tableFoot);
        tr = document.createElement('tr');
        tr.className = "date-picker-tfoot";
        tableFoot.appendChild(tr);
        this.statusBar = createTH({
          thClassName: "date-picker-statusbar" + dragEnabledCN,
          colspan: this.showWeeks ? 8 : 7
        });
        tr.appendChild(this.statusBar);
        this.updateStatus();
      }

      ;
      tableHead = document.createElement('thead');
      tableHead.className = "date-picker-thead";
      this.table.appendChild(tableHead);
      tr = document.createElement('tr');
      setARIARole(tr, "presentation");
      tableHead.appendChild(tr); // Title Bar

      this.titleBar = createTH({
        thClassName: "date-picker-title" + dragEnabledCN,
        colspan: this.showWeeks ? 8 : 7
      });
      tr.appendChild(this.titleBar);
      tr = null;
      var span = document.createElement('span');
      span.appendChild(document.createTextNode(nbsp));
      span.className = "month-display" + dragEnabledCN;
      this.titleBar.appendChild(span);
      span = document.createElement('span');
      span.appendChild(document.createTextNode(nbsp));
      span.className = "year-display" + dragEnabledCN;
      this.titleBar.appendChild(span);
      span = null;
      tr = document.createElement('tr');
      setARIARole(tr, "presentation");
      tableHead.appendChild(tr);
      createThAndButton(tr, [{
        className: "prev-but prev-year",
        id: "-prev-year-but",
        text: "\xAB",
        title: getTitleTranslation(2)
      }, {
        className: "prev-but prev-month",
        id: "-prev-month-but",
        text: "\u2039",
        title: getTitleTranslation(0)
      }, {
        colspan: this.showWeeks ? 4 : 3,
        className: "today-but",
        id: "-today-but",
        text: getTitleTranslation(4)
      }, {
        className: "next-but next-month",
        id: "-next-month-but",
        text: "\u203A",
        title: getTitleTranslation(1)
      }, {
        className: "next-but next-year",
        id: "-next-year-but",
        text: "\xBB",
        title: getTitleTranslation(3)
      }]);
      tableBody = document.createElement('tbody');
      this.table.appendChild(tableBody);
      var colspanTotal = this.showWeeks ? 8 : 7,
          colOffset = this.showWeeks ? 0 : -1,
          but,
          abbr,
          formElemId,
          formElem;

      for (var rows = 0; rows < 7; rows++) {
        row = document.createElement('tr');

        if (rows != 0) {
          // ARIA Grid role
          setARIARole(row, "row");
          tableBody.appendChild(row);
        } else {
          tableHead.appendChild(row);
        }

        ;

        for (var cols = 0; cols < colspanTotal; cols++) {
          if (rows === 0 || this.showWeeks && cols === 0) {
            col = document.createElement('th');
          } else {
            col = document.createElement('td');
            setARIAProperty(col, "describedby", this.id + "-col-" + cols + (this.showWeeks ? " " + this.id + "-row-" + rows : ""));
            setARIAProperty(col, "selected", "false");
          }

          ;

          if (oldIE) {
            col.unselectable = "on";
          }

          ;
          row.appendChild(col);

          if (this.showWeeks && cols > 0 && rows > 0 || !this.showWeeks && rows > 0) {//setARIARole(col, "gridcell");
          } else {
            if (rows === 0 && cols > colOffset) {
              col.className = "date-picker-day-header";
              col.scope = "col"; //setARIARole(col, "columnheader");

              col.id = this.id + "-col-" + cols;
            } else {
              col.className = "date-picker-week-header";
              col.scope = "row"; //setARIARole(col, "rowheader");

              col.id = this.id + "-row-" + rows;
            }

            ;
          }

          ;
        }

        ;
      }

      ;
      col = row = null;
      this.ths = this.table.getElementsByTagName('thead')[0].getElementsByTagName('tr')[2].getElementsByTagName('th');

      for (var y = 0; y < colspanTotal; y++) {
        if (y == 0 && this.showWeeks) {
          this.ths[y].appendChild(document.createTextNode(getTitleTranslation(6)));
          this.ths[y].title = getTitleTranslation(8);
          continue;
        }

        ;

        if (y > (this.showWeeks ? 0 : -1)) {
          but = document.createElement("span");
          but.className = "fd-day-header";

          if (oldIE) {
            but.unselectable = "on";
          }

          ;
          this.ths[y].appendChild(but);
        }

        ;
      }

      ;
      but = null;
      this.trs = this.table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
      this.tds = this.table.getElementsByTagName('tbody')[0].getElementsByTagName('td');
      this.butPrevYear = document.getElementById(this.id + "-prev-year-but");
      this.butPrevMonth = document.getElementById(this.id + "-prev-month-but");
      this.butToday = document.getElementById(this.id + "-today-but");
      this.butNextYear = document.getElementById(this.id + "-next-year-but");
      this.butNextMonth = document.getElementById(this.id + "-next-month-but");

      if (this.noToday) {
        this.butToday.style.display = "none";
      }

      ;

      if (this.showWeeks) {
        this.wkThs = this.table.getElementsByTagName('tbody')[0].getElementsByTagName('th');
        this.div.className += " weeks-displayed";
      }

      ;
      tableBody = tableHead = tr = createThAndButton = createTH = null;
      this.updateTableHeaders();
      this.created = true;
      this.updateTable();

      if (this.staticPos) {
        this.visible = true;
        this.opacity = 100;
        this.div.style.visibility = "visible";
        this.div.style.display = "block";
        this.noFocus = true;
        this.fade();
      } else {
        this.reposition();
        this.div.style.visibility = "visible";
        this.fade();
        this.noFocus = true;
      }

      ;
      this.callback("domcreate", {
        "id": this.id
      });
    };

    this.transEnd = function () {
      o.div.style.display = "none";
      o.div.style.visibility = "hidden";
      setARIAProperty(o.div, "hidden", "true");
    };

    this.fade = function () {
      window.clearTimeout(o.fadeTimer);
      o.fadeTimer = null;

      if (cssAnimations) {
        o.opacity = o.opacityTo;

        if (o.opacityTo == 0) {
          o.visible = false;

          _addEvent(o.div, transitionEnd, o.transEnd);

          addClass(o.div, "fd-dp-fade");
        } else {
          _removeEvent(o.div, transitionEnd, o.transEnd);

          o.visible = true;
          o.div.style.display = "block";
          o.div.style.visibility = "visible";
          setARIAProperty(o.div, "hidden", "false");
          removeClass(o.div, "fd-dp-fade");
        }

        ;
        return;
      }

      ;
      var diff = Math.round(o.opacity + (o.opacityTo - o.opacity) / 4);
      o.setOpacity(diff);

      if (Math.abs(o.opacityTo - diff) > 3 && !o.noFadeEffect) {
        o.fadeTimer = window.setTimeout(o.fade, 50);
      } else {
        o.setOpacity(o.opacityTo);

        if (o.opacityTo == 0) {
          o.div.style.display = "none";
          o.div.style.visibility = "hidden";
          setARIAProperty(o.div, "hidden", "true");
          o.visible = false;
        } else {
          setARIAProperty(o.div, "hidden", "false");
          o.visible = true;
        }

        ;
      }

      ;
    };

    this.trackDrag = function (e) {
      e = e || window.event;
      var diffx = (e.pageX ? e.pageX : e.clientX ? e.clientX : e.x) - o.mx;
      var diffy = (e.pageY ? e.pageY : e.clientY ? e.clientY : e.Y) - o.my;
      o.div.style.left = Math.round(o.x + diffx) > 0 ? Math.round(o.x + diffx) + 'px' : "0px";
      o.div.style.top = Math.round(o.y + diffy) > 0 ? Math.round(o.y + diffy) + 'px' : "0px";

      if (oldIE === 6 && !o.staticPos) {
        o.iePopUp.style.top = o.div.style.top;
        o.iePopUp.style.left = o.div.style.left;
      }

      ;
    };

    this.stopDrag = function (e) {
      var b = document.getElementsByTagName("body")[0];
      removeClass(b, "fd-drag-active");

      _removeEvent(document, 'mousemove', o.trackDrag, false);

      _removeEvent(document, 'mouseup', o.stopDrag, false);

      o.div.style.zIndex = 9999;
    };

    this.onmousedown = function (e) {
      e = e || document.parentWindow.event;
      var el = e.target != null ? e.target : e.srcElement,
          origEl = el,
          hideDP = true,
          reg = new RegExp("^fd-(but-)?" + o.id + "$");
      o.mouseDownElem = null; // Are we within the wrapper div or the button

      while (el) {
        if (el.id && el.id.length && el.id.search(reg) != -1) {
          hideDP = false;
          break;
        }

        ;

        try {
          el = el.parentNode;
        } catch (err) {
          break;
        }

        ;
      }

      ; // If not, then ...

      if (hideDP) {
        hideAll();
        return true;
      }

      ;

      if ((o.div.className + origEl.className).search('fd-disabled') != -1) {
        return true;
      }

      ; // We check the mousedown events on the buttons

      if (origEl.id.search(new RegExp("^" + o.id + "(-prev-year-but|-prev-month-but|-next-month-but|-next-year-but)$")) != -1) {
        o.mouseDownElem = origEl;

        _addEvent(document, "mouseup", o.clearTimer);

        _addEvent(origEl, "mouseout", o.clearTimer);

        var incs = {
          "-prev-year-but": [0, -1, 0],
          "-prev-month-but": [0, 0, -1],
          "-next-year-but": [0, 1, 0],
          "-next-month-but": [0, 0, 1]
        },
            check = origEl.id.replace(o.id, ""),
            dateYYYYMM = Number(o.date.getFullYear() + pad(o.date.getMonth() + 1));
        o.timerInc = 800;
        o.timerSet = true;
        o.dayInc = incs[check][0];
        o.yearInc = incs[check][1];
        o.monthInc = incs[check][2];
        o.accellerator = 1;

        if (!(o.currentYYYYMM == dateYYYYMM)) {
          if (o.currentYYYYMM < dateYYYYMM && (o.yearInc == -1 || o.monthInc == -1) || o.currentYYYYMM > dateYYYYMM && (o.yearInc == 1 || o.monthInc == 1)) {
            o.delayedUpdate = false;
            o.timerInc = 1200;
          } else {
            o.delayedUpdate = true;
          }

          ;
        }

        ;
        o.updateTable();
        return _stopEvent(e);
      } else if (el.className.search("drag-enabled") != -1) {
        o.mx = e.pageX ? e.pageX : e.clientX ? e.clientX : e.x;
        o.my = e.pageY ? e.pageY : e.clientY ? e.clientY : e.Y;
        o.x = parseInt(o.div.style.left, 10);
        o.y = parseInt(o.div.style.top, 10);

        _addEvent(document, 'mousemove', o.trackDrag, false);

        _addEvent(document, 'mouseup', o.stopDrag, false);

        addClass(document.getElementsByTagName("body")[0], "fd-drag-active");
        o.div.style.zIndex = 10000;
        return _stopEvent(e);
      }

      ;
      return true;
    };

    this.onclick = function (e) {
      if (!cssAnimations && o.opacity != o.opacityTo || o.disabled) {
        return _stopEvent(e);
      }

      ;
      e = e || document.parentWindow.event;
      var el = e.target != null ? e.target : e.srcElement;

      while (el.parentNode) {
        // Are we within a valid i.e. clickable TD node
        if (el.tagName && el.tagName.toLowerCase() == "td") {
          if (el.className.search(/cd-([0-9]{8})/) == -1 || el.className.search(noSelectionRegExp) != -1) {
            return _stopEvent(e);
          }

          ;
          var cellDate = el.className.match(/cd-([0-9]{8})/)[1];
          o.date = new Date(cellDate.substr(0, 4), cellDate.substr(4, 2) - 1, cellDate.substr(6, 2), 5, 0, 0);
          o.dateSet = new Date(o.date);
          o.noFocus = true;
          o.callback("dateset", {
            "id": o.id,
            "date": o.dateSet,
            "dd": o.dateSet.getDate(),
            "mm": o.dateSet.getMonth() + 1,
            "yyyy": o.dateSet.getFullYear()
          });
          o.returnFormattedDate();
          o.hide();
          o.stopTimer();
          break;
        } else if (el.id && el.id == o.id + "-today-but") {
          o.date = new Date();
          o.updateTable();
          o.stopTimer();
          break;
        } else if (el.className.search(/date-picker-day-header/) != -1) {
          var cnt = o.showWeeks ? -1 : 0,
              elem = el;

          while (elem.previousSibling) {
            elem = elem.previousSibling;

            if (elem.tagName && elem.tagName.toLowerCase() == "th") {
              cnt++;
            }

            ;
          }

          ;
          o.firstDayOfWeek = (o.firstDayOfWeek + cnt) % 7;
          o.updateTableHeaders();
          break;
        }

        ;

        try {
          el = el.parentNode;
        } catch (err) {
          break;
        }

        ;
      }

      ;
      return _stopEvent(e);
    };

    this.show = function (autoFocus) {
      if (this.staticPos) {
        return;
      }

      ;
      var elem, elemID;

      for (elemID in this.formElements) {
        elem = document.getElementById(this.id);

        if (!elem || elem && elem.disabled) {
          return;
        }

        ;
      }

      ;
      this.noFocus = true; // If the datepicker doesn't exist in the dom

      if (!this.created || !document.getElementById('fd-' + this.id)) {
        this.created = false;
        this.fullCreate = false;
        this.create();
        this.fullCreate = true;
      } else {
        this.setDateFromInput();
        this.reposition();
      }

      ;
      this.noFocus = !!!autoFocus;

      if (this.noFocus) {
        this.clickActivated = true;
        this.showCursor = false;

        _addEvent(document, "mousedown", this.onmousedown);

        if (mouseWheel) {
          if (window.addEventListener && !window.devicePixelRatio) {
            window.addEventListener('DOMMouseScroll', this.onmousewheel, false);
          } else {
            _addEvent(document, "mousewheel", this.onmousewheel);

            _addEvent(window, "mousewheel", this.onmousewheel);
          }

          ;
        }

        ;
      } else {
        this.clickActivated = false;
        this.showCursor = true;
      }

      ;
      this.opacityTo = 100;
      this.div.style.display = "block";

      if (oldIE === 6) {
        this.iePopUp.style.width = this.div.offsetWidth + "px";
        this.iePopUp.style.height = this.div.offsetHeight + "px";
        this.iePopUp.style.display = "block";
      }

      ;
      this.setNewFocus();
      this.fade();
      var butt = document.getElementById('fd-but-' + this.id);

      if (butt) {
        addClass(butt, "date-picker-button-active");
      }

      ;
    };

    this.hide = function () {
      if (!this.visible || !this.created || !document.getElementById('fd-' + this.id)) {
        return;
      }

      ;
      this.kbEvent = false;
      removeClass(o.div, "date-picker-focus");
      this.stopTimer();
      this.removeOnFocusEvents();
      this.clickActivated = false;
      this.noFocus = true;
      this.showCursor = false;
      this.setNewFocus();

      if (this.staticPos) {
        return;
      }

      ;

      if (this.statusBar) {
        this.updateStatus(getTitleTranslation(9));
      }

      ;
      var butt = document.getElementById('fd-but-' + this.id);

      if (butt) {
        removeClass(butt, "date-picker-button-active");
      }

      ;

      _removeEvent(document, "mousedown", this.onmousedown);

      if (mouseWheel) {
        if (window.addEventListener && !window.devicePixelRatio) {
          try {
            window.removeEventListener('DOMMouseScroll', this.onmousewheel, false);
          } catch (err) {}

          ;
        } else {
          _removeEvent(document, "mousewheel", this.onmousewheel);

          _removeEvent(window, "mousewheel", this.onmousewheel);
        }

        ;
      }

      ;

      if (oldIE === 6) {
        this.iePopUp.style.display = "none";
      }

      ;
      this.opacityTo = 0;
      this.fade();
    };

    this.onblur = function (e) {
      o.removeCursorHighlight();
      o.hide();
    }; // The current cursor cell gains focus


    this.onfocus = function (e) {
      o.noFocus = false;
      addClass(o.div, "date-picker-focus");

      if (o.statusBar) {
        o.updateStatus(_printFormattedDate(o.date, o.statusFormat, true));
      }

      ;
      o.showCursor = true;
      o.addCursorHighlight();
      o.addOnFocusEvents();
    };

    this.onmousewheel = function (e) {
      e = e || document.parentWindow.event;
      var delta = 0;

      if (e.wheelDelta) {
        delta = e.wheelDelta / 120;

        if (isOpera && window.opera.version() < 9.2) {
          delta = -delta;
        }

        ;
      } else if (e.detail) {
        delta = -e.detail / 3;
      }

      ;
      var n = o.date.getDate(),
          d = new Date(o.date),
          inc = delta > 0 ? 1 : -1;
      d.setDate(2);
      d.setMonth(d.getMonth() + inc * 1);
      d.setDate(Math.min(n, daysInMonth(d.getMonth(), d.getFullYear())));

      if (o.outOfRange(d)) {
        return _stopEvent(e);
      }

      ;
      o.date = new Date(d);
      o.updateTable();

      if (o.statusBar) {
        o.updateStatus(_printFormattedDate(o.date, o.statusFormat, true));
      }

      ;
      return _stopEvent(e);
    };

    this.onkeydown = function (e) {
      o.stopTimer();

      if (!o.visible) {
        return false;
      }

      ;
      e = e || document.parentWindow.event;
      var kc = e.keyCode ? e.keyCode : e.charCode;

      if (kc == 13) {
        // RETURN/ENTER: close & select the date
        var td = document.getElementById(o.id + "-date-picker-hover");

        if (!td || td.className.search(/cd-([0-9]{8})/) == -1 || td.className.search(/out-of-range|day-disabled/) != -1) {
          return _stopEvent(e);
        }

        ;
        o.dateSet = new Date(o.date);
        o.callback("dateset", o.createCbArgObj());
        o.returnFormattedDate();
        o.hide();
        return _stopEvent(e);
      } else if (kc == 27) {
        // ESC: close, no date selection, refocus on popup button
        if (!o.staticPos) {
          o.hide();
          var butt = document.getElementById('fd-but-' + o.id);

          if (butt) {
            setTimeout(function () {
              try {
                butt.focus();
              } catch (err) {}
            }, 0);
          }

          ;
          return _stopEvent(e);
        }

        ;
        return true;
      } else if (kc == 32 || kc == 0) {
        // SPACE: goto todays date
        o.date = new Date();
        o.updateTable();
        return _stopEvent(e);
      } else if (kc == 9) {
        // TAB: pass focus - non popup datepickers only
        if (!o.staticPos) {
          return _stopEvent(e);
        }

        ;
        return true;
      }

      ; // TODO - test the need for the IE specific stuff in IE9
      // Internet Explorer fires the keydown event faster than the JavaScript engine can
      // update the interface. The following attempts to fix this.

      if (oldIE) {
        if (new Date().getTime() - o.interval.getTime() < 50) {
          return _stopEvent(e);
        }

        ;
        o.interval = new Date();
      }

      ; // A number key has been pressed so change the first day of the week

      if (kc > 49 && kc < 56 || kc > 97 && kc < 104) {
        if (kc > 96) {
          kc -= 96 - 48;
        }

        ;
        kc -= 49;
        o.firstDayOfWeek = (o.firstDayOfWeek + kc) % 7;
        o.updateTableHeaders();
        return _stopEvent(e);
      }

      ; // If outside any other tested keycodes then let the keystroke pass

      if (kc < 33 || kc > 40) {
        return true;
      }

      ;
      var d = new Date(o.date),
          cursorYYYYMM = o.date.getFullYear() + pad(o.date.getMonth() + 1),
          tmp; // HOME: Set date to first day of current month

      if (kc == 36) {
        d.setDate(1); // END: Set date to last day of current month
      } else if (kc == 35) {
        d.setDate(daysInMonth(d.getMonth(), d.getFullYear())); // PAGE UP & DOWN
      } else if (kc == 33 || kc == 34) {
        var inc = kc == 34 ? 1 : -1; // CTRL + PAGE UP/DOWN: Moves to the same date in the previous/next year

        if (e.ctrlKey) {
          d.setFullYear(d.getFullYear() + inc * 1); // PAGE UP/DOWN: Moves to the same date in the previous/next month
        } else {
          var n = o.date.getDate();
          d.setDate(2);
          d.setMonth(d.getMonth() + inc * 1);
          d.setDate(Math.min(n, daysInMonth(d.getMonth(), d.getFullYear())));
        }

        ; // LEFT ARROW
      } else if (kc == 37) {
        d = new Date(o.date.getFullYear(), o.date.getMonth(), o.date.getDate() - 1, 5, 0, 0); // RIGHT ARROW
      } else if (kc == 39 || kc == 34) {
        d = new Date(o.date.getFullYear(), o.date.getMonth(), o.date.getDate() + 1, 5, 0, 0); // UP ARROW
      } else if (kc == 38) {
        d = new Date(o.date.getFullYear(), o.date.getMonth(), o.date.getDate() - 7, 5, 0, 0); // DOWN ARROW
      } else if (kc == 40) {
        d = new Date(o.date.getFullYear(), o.date.getMonth(), o.date.getDate() + 7, 5, 0, 0);
      }

      ; // If the new date is out of range then disallow action

      if (o.outOfRange(d)) {
        return _stopEvent(e);
      }

      ; // Otherwise set the new cursor date

      o.date = d; // Update the status bar if needs be

      if (o.statusBar) {
        o.updateStatus(o.getBespokeTitle(o.date.getFullYear(), o.date.getMonth() + 1, o.date.getDate()) || _printFormattedDate(o.date, o.statusFormat, true));
      }

      ; // YYYYMMDD format String of the current cursor date

      var t = String(o.date.getFullYear()) + pad(o.date.getMonth() + 1) + pad(o.date.getDate()); // If we need to redraw the UI completely

      if (e.ctrlKey || kc == 33 || kc == 34 || t < o.firstDateShown || t > o.lastDateShown) {
        o.updateTable();

        if (oldIE) {
          o.interval = new Date();
        }

        ; // Just highlight current cell
      } else {
        // Do we need to disable the today button for this date
        if (!o.noToday) {
          o.disableTodayButton();
        }

        ; // Remove focus from the previous cell

        o.removeOldFocus(); // Show/hide the month & year buttons

        o.showHideButtons(o.date); // Locate this TD

        for (var i = 0, td; td = o.tds[i]; i++) {
          if (td.className.search("cd-" + t) == -1) {
            continue;
          }

          ;
          td.id = o.id + "-date-picker-hover";
          o.setNewFocus();
          break;
        }

        ;
      }

      ;
      return _stopEvent(e);
    };

    this.onmouseout = function (e) {
      e = e || document.parentWindow.event;
      var p = e.toElement || e.relatedTarget;

      while (p && p != this) {
        try {
          p = p.parentNode;
        } catch (e) {
          p = this;
        }

        ;
      }

      ;

      if (p == this) {
        return false;
      }

      ;

      if (o.clickActivated || o.staticPos && !o.kbEventsAdded) {
        o.showCursor = false;
        o.removeCursorHighlight();
      }

      ;

      if (o.currentTR) {
        o.currentTR.className = "";
        o.currentTR = null;
      }

      ;

      if (o.statusBar) {
        o.updateStatus(o.dateSet ? o.getBespokeTitle(o.dateSet.getFullYear(), o.dateSet.getMonth() + 1, o.dateSet.getDate()) || _printFormattedDate(o.dateSet, o.statusFormat, true) : getTitleTranslation(9));
      }

      ;
    };

    this.onmouseover = function (e) {
      e = e || document.parentWindow.event;
      var el = e.target != null ? e.target : e.srcElement;

      while (el.nodeType != 1) {
        el = el.parentNode;
      }

      ;

      if (!el || !el.tagName) {
        return;
      }

      ;
      o.noFocus = true;
      var statusText = getTitleTranslation(9);

      if (o.clickActivated || o.staticPos && !o.kbEventsAdded) {
        o.showCursor = false;
      }

      ;

      switch (el.tagName.toLowerCase()) {
        case "td":
          if (el.className.search(/date-picker-unused|out-of-range/) != -1) {
            statusText = getTitleTranslation(9);
          }

          if (el.className.search(/cd-([0-9]{8})/) != -1) {
            o.showCursor = true;
            o.stopTimer();
            var cellDate = el.className.match(/cd-([0-9]{8})/)[1];
            o.removeOldFocus();
            el.id = o.id + "-date-picker-hover";
            o.setNewFocus();
            o.date = new Date(+cellDate.substr(0, 4), +cellDate.substr(4, 2) - 1, +cellDate.substr(6, 2), 5, 0, 0);

            if (!o.noToday) {
              o.disableTodayButton();
            }

            ;
            statusText = o.getBespokeTitle(+cellDate.substr(0, 4), +cellDate.substr(4, 2), +cellDate.substr(6, 2)) || _printFormattedDate(o.date, o.statusFormat, true);
          }

          ;
          break;

        case "th":
          if (!o.statusBar) {
            break;
          }

          ;

          if (el.className.search(/drag-enabled/) != -1) {
            statusText = getTitleTranslation(10);
          } else if (el.className.search(/date-picker-week-header/) != -1) {
            var txt = el.firstChild ? el.firstChild.nodeValue : "";
            statusText = txt.search(/^(\d+)$/) != -1 ? getTitleTranslation(7, [txt, txt < 3 && o.date.getMonth() == 11 ? getWeeksInYear(o.date.getFullYear()) + 1 : getWeeksInYear(o.date.getFullYear())]) : getTitleTranslation(9);
          }

          ;
          break;

        case "span":
          if (!o.statusBar) {
            break;
          }

          ;

          if (el.className.search(/day-([0-6])/) != -1) {
            var day = el.className.match(/day-([0-6])/)[1];
            statusText = getTitleTranslation(11, [getDayTranslation(day, false)]);
          } else if (el.className.search(/(drag-enabled|today-but|prev-(year|month)|next-(year|month))/) != -1 && el.className.search(/disabled/) == -1) {
            statusText = getTitleTranslation({
              "drag-enabled": 10,
              "prev-year": 2,
              "prev-month": 0,
              "next-year": 3,
              "next-month": 1,
              "today-but": 12
            }[el.className.match(/(drag-enabled|today-but|prev-(year|month)|next-(year|month))/)[0]]);
          }

          ;
          break;

        default:
          statusText = "";
      }

      ;

      while (el.parentNode) {
        el = el.parentNode;

        if (el.nodeType == 1 && el.tagName.toLowerCase() == "tr") {
          if (o.currentTR) {
            if (el == o.currentTR) {
              break;
            }

            ;
            o.currentTR.className = "";
          }

          ;
          el.className = "dp-row-highlight";
          o.currentTR = el;
          break;
        }

        ;
      }

      ;

      if (o.statusBar && statusText) {
        o.updateStatus(statusText);
      }

      ;

      if (!o.showCursor) {
        o.removeCursorHighlight();
      }

      ;
    };

    this.clearTimer = function () {
      o.stopTimer();
      o.timerInc = 800;
      o.yearInc = 0;
      o.monthInc = 0;
      o.dayInc = 0;

      _removeEvent(document, "mouseup", o.clearTimer);

      if (o.mouseDownElem != null) {
        _removeEvent(o.mouseDownElem, "mouseout", o.clearTimer);
      }

      ;
      o.mouseDownElem = null;
    };

    var o = this;
    this.setDateFromInput();

    if (this.staticPos) {
      this.create();
    } else {
      this.createButton();
    }

    ;

    (function () {
      var elemID,
          elem,
          elemCnt = 0;

      for (elemID in o.formElements) {
        elem = document.getElementById(elemID);

        if (elem && elem.tagName && elem.tagName.search(/select|input/i) != -1) {
          _addEvent(elem, "change", o.changeHandler);

          if (elemCnt == 0 && elem.form) {
            _addEvent(elem.form, "reset", o.reset);
          }

          ;
          elemCnt++;
        }

        ;

        if (!elem || elem.disabled == true) {
          o.disableDatePicker();
        }

        ;
      }

      ;
    })(); // We have fully created the datepicker...


    this.fullCreate = true;
  }

  ;

  datePicker.prototype.addButtonEvents = function (but) {
    function buttonEvent(e) {
      e = e || window.event;
      var inpId = this.id.replace('fd-but-', ''),
          dpVisible = isVisible(inpId),
          autoFocus = false,
          kbEvent = datePickers[inpId].kbEvent;

      if (kbEvent) {
        datePickers[inpId].kbEvent = false;
        return;
      }

      ;

      if (e.type == "keydown") {
        var kc = e.keyCode != null ? e.keyCode : e.charCode;
        if (kc != 13) return true;
        datePickers[inpId].kbEvent = true;

        if (dpVisible) {
          removeClass(this, "date-picker-button-active");
          hideAll();
          return _stopEvent(e);
        }

        ;
        autoFocus = true;
      } else {
        datePickers[inpId].kbEvent = false;
      }

      ;

      if (!dpVisible) {
        addClass(this, "date-picker-button-active");
        hideAll(inpId);
        showDatePicker(inpId, autoFocus);
      } else {
        removeClass(this, "date-picker-button-active");
        hideAll();
      }

      ;
      return _stopEvent(e);
    }

    ;
    but.onclick = buttonEvent;
    but.onkeydown = buttonEvent;

    if (!buttonTabIndex) {
      setTabIndex(but, -1);
    } else {
      setTabIndex(but, this.bespokeTabIndex);
    }

    ;
  };

  datePicker.prototype.createButton = function () {
    if (this.staticPos || document.getElementById("fd-but-" + this.id)) {
      return;
    }

    ;
    var inp = document.getElementById(this.id),
        span = document.createElement('span'),
        but = document.createElement('a');
    but.href = "#" + this.id;
    but.className = "date-picker-control";
    but.title = getTitleTranslation(5);
    but.id = "fd-but-" + this.id;
    span.appendChild(document.createTextNode(nbsp));
    but.appendChild(span);
    span = document.createElement('span');
    span.className = "fd-screen-reader";
    span.appendChild(document.createTextNode(but.title));
    but.appendChild(span); // Set the ARIA role to be "button"

    setARIARole(but, "button"); // Set a "haspopup" ARIA property

    setARIAProperty(but, "haspopup", true);

    if (this.positioned && document.getElementById(this.positioned)) {
      document.getElementById(this.positioned).appendChild(but);
    } else {
      inp.parentNode.insertBefore(but, inp.nextSibling);
    }

    ;
    this.addButtonEvents(but);
    but = null;
    this.callback("dombuttoncreate", {
      id: this.id
    });
  };

  datePicker.prototype.setBespokeTitles = function (titles) {
    this.bespokeTitles = {};
    this.addBespokeTitles(titles);
  };

  datePicker.prototype.addBespokeTitles = function (titles) {
    for (var dt in titles) {
      if (titles.hasOwnProperty(dt)) {
        this.bespokeTitles[dt] = titles[dt];
      }

      ;
    }

    ;
  };

  datePicker.prototype.getBespokeTitle = function (y, m, d) {
    var dt,
        dtFull,
        yyyymmdd = y + String(pad(m)) + pad(d); // Try the datepickers bespoke titles

    for (dt in this.bespokeTitles) {
      if (this.bespokeTitles.hasOwnProperty(dt)) {
        dtFull = String(dt).replace(/^(\*\*\*\*)/, y).replace(/^(\d\d\d\d)(\*\*)/, "$1" + pad(m));

        if (dtFull == yyyymmdd) {
          return this.bespokeTitles[dt];
        }

        ;
      }

      ;
    }

    ; // Try the generic bespoke titles

    for (dt in bespokeTitles) {
      if (bespokeTitles.hasOwnProperty(dt)) {
        dtFull = String(dt).replace(/^(\*\*\*\*)/, y).replace(/^(\d\d\d\d)(\*\*)/, "$1" + pad(m));

        if (dtFull == yyyymmdd) {
          return bespokeTitles[dt];
        }

        ;
      }

      ;
    }

    ;
    return false;
  };

  datePicker.prototype.returnSelectedDate = function () {
    return this.dateSet;
  };

  datePicker.prototype.setRangeLow = function (range) {
    if (String(range).search(rangeRegExp) == -1) {
      if (_debug) {
        throw "Invalid value passed to setRangeLow method: " + range;
      }

      ;
      return false;
    }

    ;
    this.rangeLow = range;

    if (!this.inUpdate) {
      this.setDateFromInput();
    }

    ;
  };

  datePicker.prototype.setRangeHigh = function (range) {
    if (String(range).search(rangeRegExp) == -1) {
      if (_debug) {
        throw "Invalid value passed to setRangeHigh method: " + range;
      }

      ;
      return false;
    }

    ;
    this.rangeHigh = range;

    if (!this.inUpdate) {
      this.setDateFromInput();
    }

    ;
  };

  datePicker.prototype.setDisabledDays = function (dayArray) {
    if (!dayArray.length || dayArray.join("").search(/^([0|1]{7})$/) == -1) {
      if (_debug) {
        throw "Invalid values located when attempting to call setDisabledDays";
      }

      ;
      return false;
    }

    ;
    this.disabledDays = dayArray;

    if (!this.inUpdate) {
      this.setDateFromInput();
    }

    ;
  };

  datePicker.prototype.setDisabledDates = function (dateObj) {
    this.filterDateList(dateObj, true);
  };

  datePicker.prototype.setEnabledDates = function (dateObj) {
    this.filterDateList(dateObj, false);
  };

  datePicker.prototype.addDisabledDates = function (dateObj) {
    this.addDatesToList(dateObj, true);
  };

  datePicker.prototype.addEnabledDates = function (dateObj) {
    this.addDatesToList(dateObj, false);
  };

  datePicker.prototype.filterDateList = function (dateObj, type) {
    var tmpDates = [];

    for (var i = 0; i < this.dateList.length; i++) {
      if (this.dateList[i].type != type) {
        tmpDates.push(this.dateList[i]);
      }

      ;
    }

    ;
    this.dateList = tmpDates.concat();
    this.addDatesToList(dateObj, type);
  };

  datePicker.prototype.addDatesToList = function (dateObj, areDisabled) {
    var startD;

    for (startD in dateObj) {
      if (String(startD).search(wcDateRegExp) != -1 && (dateObj[startD] == 1 || String(dateObj[startD]).search(wcDateRegExp) != -1)) {
        if (dateObj[startD] != 1 && Number(String(startD).replace(/^\*\*\*\*/, 2010).replace(/^(\d\d\d\d)(\*\*)/, "$1" + "22")) > Number(String(dateObj[startD]).replace(/^\*\*\*\*/, 2010).replace(/^(\d\d\d\d)(\*\*)/, "$1" + "22"))) {
          continue;
        }

        ;
        this.dateList.push({
          type: !!areDisabled,
          rLow: startD,
          rHigh: dateObj[startD]
        });
      }

      ;
    }

    ;

    if (!this.inUpdate) {
      this.setDateFromInput();
    }

    ;
  };

  datePicker.prototype.setSelectedDate = function (yyyymmdd) {
    if (String(yyyymmdd).search(wcDateRegExp) == -1) {
      return false;
    }

    ;
    var match = yyyymmdd.match(rangeRegExp),
        dt = new Date(+match[2], +match[3] - 1, +match[4], 5, 0, 0);

    if (!dt || isNaN(dt) || !this.canDateBeSelected(dt)) {
      return false;
    }

    ;
    this.dateSet = new Date(dt);

    if (!this.inUpdate) {
      this.updateTable();
    }

    ;
    this.callback("dateset", this.createCbArgObj());
    this.returnFormattedDate();
  };

  datePicker.prototype.checkSelectedDate = function () {
    if (this.dateSet && !this.canDateBeSelected(this.dateSet)) {
      this.dateSet = null;
    }

    ;

    if (!this.inUpdate) {
      this.updateTable();
    }

    ;
  };

  datePicker.prototype.addOnFocusEvents = function () {
    if (this.kbEventsAdded || this.noFocus) {
      return;
    }

    ;

    _addEvent(document, "keypress", this.onkeydown);

    _addEvent(document, "mousedown", this.onmousedown);

    if (oldIE) {
      _removeEvent(document, "keypress", this.onkeydown);

      _addEvent(document, "keydown", this.onkeydown);
    }

    ;

    if (window.devicePixelRatio) {
      _removeEvent(document, "keypress", this.onkeydown);

      _addEvent(document, "keydown", this.onkeydown);
    }

    ;
    this.noFocus = false;
    this.kbEventsAdded = true;
  };

  datePicker.prototype.removeOnFocusEvents = function () {
    if (!this.kbEventsAdded) {
      return;
    }

    ;

    _removeEvent(document, "keypress", this.onkeydown);

    _removeEvent(document, "keydown", this.onkeydown);

    _removeEvent(document, "mousedown", this.onmousedown);

    this.kbEventsAdded = false;
  };

  datePicker.prototype.stopTimer = function () {
    this.timerSet = false;
    window.clearTimeout(this.timer);
  };

  datePicker.prototype.setOpacity = function (op) {
    this.div.style.opacity = op / 100;
    this.div.style.filter = 'alpha(opacity=' + op + ')';
    this.opacity = op;
  };

  datePicker.prototype.truePosition = function (element) {
    var pos = this.cumulativeOffset(element);

    if (isOpera) {
      return pos;
    }

    ;
    var iebody = document.compatMode && document.compatMode != "BackCompat" ? document.documentElement : document.body,
        dsocleft = document.all ? iebody.scrollLeft : window.pageXOffset,
        dsoctop = document.all ? iebody.scrollTop : window.pageYOffset,
        posReal = this.realOffset(element);
    return [pos[0] - posReal[0] + dsocleft, pos[1] - posReal[1] + dsoctop];
  };

  datePicker.prototype.realOffset = function (element) {
    var t = 0,
        l = 0;

    do {
      t += element.scrollTop || 0;
      l += element.scrollLeft || 0;
      element = element.parentNode;
    } while (element);

    return [l, t];
  };

  datePicker.prototype.cumulativeOffset = function (element) {
    var t = 0,
        l = 0;

    do {
      t += element.offsetTop || 0;
      l += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);

    return [l, t];
  };

  datePicker.prototype.outOfRange = function (tmpDate) {
    if (!this.rangeLow && !this.rangeHigh) {
      return false;
    }

    ;
    var level = false;

    if (!tmpDate) {
      level = true;
      tmpDate = this.date;
    }

    ;
    var d = pad(tmpDate.getDate()),
        m = pad(tmpDate.getMonth() + 1),
        y = tmpDate.getFullYear(),
        dt = String(y) + String(m) + String(d);

    if (this.rangeLow && +dt < +this.rangeLow) {
      if (!level) {
        return true;
      }

      ;
      this.date = new Date(this.rangeLow.substr(0, 4), this.rangeLow.substr(4, 2) - 1, this.rangeLow.substr(6, 2), 5, 0, 0);
      return false;
    }

    ;

    if (this.rangeHigh && +dt > +this.rangeHigh) {
      if (!level) {
        return true;
      }

      ;
      this.date = new Date(this.rangeHigh.substr(0, 4), this.rangeHigh.substr(4, 2) - 1, this.rangeHigh.substr(6, 2), 5, 0, 0);
    }

    ;
    return false;
  };

  datePicker.prototype.canDateBeSelected = function (tmpDate) {
    if (!tmpDate || isNaN(tmpDate)) {
      return false;
    }

    ;
    var d = pad(tmpDate.getDate()),
        m = pad(tmpDate.getMonth() + 1),
        y = tmpDate.getFullYear(),
        dt = y + "" + m + "" + d,
        dd = this.getDateExceptions(y, m),
        wd = tmpDate.getDay() == 0 ? 7 : tmpDate.getDay(); // If date out of range

    if (this.rangeLow && +dt < +this.rangeLow || this.rangeHigh && +dt > +this.rangeHigh || // or the date has been explicitly disabled
    dt in dd && dd[dt] == 1 || // or the date lies on a disabled weekday and it hasn't been explicitly enabled
    this.disabledDays[wd - 1] && (!(dt in dd) || dt in dd && dd[dt] == 1)) {
      return false;
    }

    ;
    return true;
  };

  datePicker.prototype.updateStatus = function (msg) {
    removeChildNodes(this.statusBar); // All this arseing about just for sups in the footer... nice typography and all that...

    if (msg && this.statusFormat.search(/%S/) != -1 && msg.search(/([0-9]{1,2})(st|nd|rd|th)/) != -1) {
      msg = cbSplit(msg.replace(/([0-9]{1,2})(st|nd|rd|th)/, "$1<sup>$2</sup>"), /<sup>|<\/sup>/);
      var dc = document.createDocumentFragment();

      for (var i = 0, nd; nd = msg[i]; i++) {
        if (/^(st|nd|rd|th)$/.test(nd)) {
          var sup = document.createElement("sup");
          sup.appendChild(document.createTextNode(nd));
          dc.appendChild(sup);
        } else {
          dc.appendChild(document.createTextNode(nd));
        }

        ;
      }

      ;
      this.statusBar.appendChild(dc);
    } else {
      this.statusBar.appendChild(document.createTextNode(msg ? msg : getTitleTranslation(9)));
    }

    ;
  };
  /* Still needs work... */


  datePicker.prototype.setDateFromInput = function () {
    var origDateSet = this.dateSet,
        m = false,
        but = this.staticPos ? false : document.getElementById("fd-but-" + this.id),
        e = localeImport.imported ? [].concat(localeDefaults.fullMonths).concat(localeDefaults.monthAbbrs) : [],
        l = localeImport.imported ? [].concat(localeImport.fullMonths).concat(localeImport.monthAbbrs) : [],
        eosRegExp = /(3[01]|[12][0-9]|0?[1-9])(st|nd|rd|th)/i,
        elemCnt = 0,
        dt = false,
        allFormats,
        i,
        elemID,
        elem,
        elemFmt,
        d,
        y,
        elemVal,
        dp,
        mp,
        yp; // Reset the internal dateSet variable

    this.dateSet = null; // Try and get a year, month and day from the form element values

    for (elemID in this.formElements) {
      elem = document.getElementById(elemID);

      if (!elem) {
        return false;
      }

      ;
      elemCnt++;
      elemVal = String(elem.value);

      if (!elemVal) {
        continue;
      }

      ;
      elemFmt = this.formElements[elemID];
      allFormats = [elemFmt];
      dt = false;
      dp = elemFmt.search(dPartsRegExp) != -1;
      mp = elemFmt.search(mPartsRegExp) != -1;
      yp = elemFmt.search(yPartsRegExp) != -1; // Try to assign some default date formats to throw at
      // the (simple) regExp parser for single date parts.

      if (!(dp && mp && yp)) {
        if (yp && !(mp || dp)) {
          allFormats = allFormats.concat(["%Y", "%y"]);
        } else if (mp && !(yp || dp)) {
          allFormats = allFormats.concat(["%M", "%F", "%m", "%n"]);
        } else if (dp && !(yp || mp)) {
          allFormats = allFormats.concat(["%d%", "%j"]);
        }

        ;
      }

      ;

      for (i = 0; i < allFormats.length; i++) {
        dt = _parseDateString(elemVal, allFormats[i]);

        if (dt) {
          if (!d && dp && dt.d) {
            d = dt.d;
          }

          ;

          if (m === false && mp && dt.m) {
            m = dt.m;
          }

          ;

          if (!y && yp && dt.y) {
            y = dt.y;
          }

          ;
        }

        ;

        if ((dp && d || !dp) && (mp && !m === false || !mp) && (yp && y || !yp)) {
          break;
        }

        ;
      }

      ;
    }

    ; // Last ditch attempt at date parsing for single inputs that
    // represent the day, month and year parts of the date format.
    // I'm - thankfully - passing this responsibility off to the browser.
    // Date parsing in js sucks but the browsers' in-built Date.parse method
    // will inevitably be better than anything I would hazard to write.
    // Date.parse is implementation dependant though so don't expect
    // consistency, rhyme or reason.

    if (dateParseFallback && (!d || m === false || !y) && dp && mp && yp && elemCnt == 1 && elemVal) {
      // If locale imported then replace month names with English
      // counterparts if necessary
      if (localeImport.imported) {
        for (i = 0; i < l.length; i++) {
          elemVal = elemVal.replace(new RegExp(l[i], "i"), e[i]);
        }

        ;
      }

      ; // Remove English ordinal suffix

      if (elemVal.search(eosRegExp) != -1) {
        elemVal = elemVal.replace(eosRegExp, elemVal.match(eosRegExp)[1]);
      }

      ; // Older browsers have problems with dashes so we replace with
      // slashes which appear to be supported by all and then try to use
      // the in-built Date Object to parse a valid date

      dt = new Date(elemVal.replace(new RegExp("\-", "g"), "/"));

      if (dt && !isNaN(dt)) {
        d = dt.getDate();
        m = dt.getMonth() + 1;
        y = dt.getFullYear();
      }

      ;
    }

    ;
    dt = false;

    if (d && !(m === false) && y) {
      if (+d > daysInMonth(+m - 1, +y)) {
        d = daysInMonth(+m - 1, +y);
        dt = false;
      } else {
        dt = new Date(+y, +m - 1, +d, 5, 0, 0);
      }

      ;
    }

    ;

    if (but) {
      removeClass(but, "date-picker-dateval");
    }

    ;

    if (!dt || isNaN(dt)) {
      var newDate = new Date(y || new Date().getFullYear(), !(m === false) ? m - 1 : new Date().getMonth(), 1, 5, 0, 0);
      this.date = this.cursorDate ? new Date(+this.cursorDate.substr(0, 4), +this.cursorDate.substr(4, 2) - 1, +this.cursorDate.substr(6, 2), 5, 0, 0) : new Date(newDate.getFullYear(), newDate.getMonth(), Math.min(+d || new Date().getDate(), daysInMonth(newDate.getMonth(), newDate.getFullYear())), 5, 0, 0);
      this.outOfRange();

      if (this.fullCreate) {
        this.updateTable();
      }

      ;
      return;
    }

    ;
    dt.setHours(5);
    this.date = new Date(dt);
    this.outOfRange();

    if (dt.getTime() == this.date.getTime() && this.canDateBeSelected(this.date)) {
      this.dateSet = new Date(this.date);

      if (but) {
        addClass(but, "date-picker-dateval");
      }

      ;
      this.returnFormattedDate(true);
    }

    ;

    if (this.fullCreate) {
      this.updateTable();
    }

    ;
  };

  datePicker.prototype.setSelectIndex = function (elem, indx) {
    for (var opt = elem.options.length - 1; opt >= 0; opt--) {
      if (elem.options[opt].value == indx) {
        elem.selectedIndex = opt;
        return;
      }

      ;
    }

    ;
  };

  datePicker.prototype.returnFormattedDate = function (noFocus) {
    var but = this.staticPos ? false : document.getElementById("fd-but-" + this.id);

    if (!this.dateSet) {
      if (but) {
        removeClass(but, "date-picker-dateval");
      }

      ;
      return;
    }

    ;
    var d = pad(this.dateSet.getDate()),
        m = pad(this.dateSet.getMonth() + 1),
        y = this.dateSet.getFullYear(),
        el = false,
        elemID,
        elem,
        elemFmt,
        fmtDate;
    noFocus = !!noFocus;

    for (elemID in this.formElements) {
      elem = document.getElementById(elemID);

      if (!elem) {
        return;
      }

      ;

      if (!el) {
        el = elem;
      }

      ;
      elemFmt = this.formElements[elemID];
      fmtDate = _printFormattedDate(this.dateSet, elemFmt, returnLocaleDate);

      if (elem.tagName.toLowerCase() == "input") {
        elem.value = fmtDate;
      } else {
        this.setSelectIndex(elem, fmtDate);
      }

      ;
    }

    ;

    if (this.staticPos) {
      this.noFocus = true;
      this.updateTable();
      this.noFocus = false;
    } else if (but) {
      addClass(but, "date-picker-dateval");
    }

    ;

    if (this.fullCreate) {
      if (el.type && el.type != "hidden" && !noFocus) {
        try {
          el.focus();
        } catch (err) {}

        ;
      }

      ;
    }

    ;

    if (!noFocus) {
      this.callback("datereturned", this.createCbArgObj());
    }

    ;
  };

  datePicker.prototype.disableDatePicker = function () {
    if (this.disabled) {
      return;
    }

    ;

    if (this.staticPos) {
      this.removeOnFocusEvents();
      this.removeOldFocus();
      this.noFocus = true;
      addClass(this.div, "date-picker-disabled");
      this.table.onmouseover = this.table.onclick = this.table.onmouseout = this.table.onmousedown = null;

      _removeEvent(document, "mousedown", this.onmousedown);

      _removeEvent(document, "mouseup", this.clearTimer);
    } else {
      if (this.visible) {
        this.hide();
      }

      ;
      var but = document.getElementById("fd-but-" + this.id);

      if (but) {
        addClass(but, "date-picker-control-disabled"); // Set a "disabled" ARIA state

        setARIAProperty(but, "disabled", true);

        but.onkeydown = but.onclick = function () {
          return false;
        };

        setTabIndex(but, -1);
        but.title = "";
      }
    }

    ;
    clearTimeout(this.timer);
    this.disabled = true;
  };

  datePicker.prototype.enableDatePicker = function () {
    if (!this.disabled) {
      return;
    }

    ;

    if (this.staticPos) {
      this.removeOldFocus();

      if (this.dateSet != null) {
        this.date = this.dateSet;
      }

      ;
      this.noFocus = true;
      this.updateTable();
      removeClass(this.div, "date-picker-disabled");
      this.disabled = false;
      this.table.onmouseover = this.onmouseover;
      this.table.onmouseout = this.onmouseout;
      this.table.onclick = this.onclick;
      this.table.onmousedown = this.onmousedown;
    } else {
      var but = document.getElementById("fd-but-" + this.id);

      if (but) {
        removeClass(but, "date-picker-control-disabled"); // Reset the "disabled" ARIA state

        setARIAProperty(but, "disabled", false);
        this.addButtonEvents(but);
        but.title = getTitleTranslation(5);
      }

      ;
    }

    ;
    this.disabled = false;
  };

  datePicker.prototype.disableTodayButton = function () {
    var today = new Date();
    removeClass(this.butToday, "fd-disabled");

    if (this.outOfRange(today) || this.date.getDate() == today.getDate() && this.date.getMonth() == today.getMonth() && this.date.getFullYear() == today.getFullYear()) {
      addClass(this.butToday, "fd-disabled");
    }

    ;
  };

  datePicker.prototype.updateTableHeaders = function () {
    var colspanTotal = this.showWeeks ? 8 : 7,
        colOffset = this.showWeeks ? 1 : 0,
        d,
        but;

    for (var col = colOffset; col < colspanTotal; col++) {
      d = (this.firstDayOfWeek + (col - colOffset)) % 7;
      this.ths[col].title = getDayTranslation(d, false);

      if (col > colOffset) {
        but = this.ths[col].getElementsByTagName("span")[0];
        removeChildNodes(but);
        but.appendChild(document.createTextNode(getDayTranslation(d, true)));
        but.title = this.ths[col].title;
        but = null;
      } else {
        removeChildNodes(this.ths[col]);
        this.ths[col].appendChild(document.createTextNode(getDayTranslation(d, true)));
      }

      ;
      removeClass(this.ths[col], "date-picker-highlight");

      if (this.highlightDays[d]) {
        addClass(this.ths[col], "date-picker-highlight");
      }

      ;
    }

    ;

    if (this.created) {
      this.updateTable();
    }

    ;
  };

  datePicker.prototype.callback = function (type, args) {
    if (!type || !(type in this.callbacks)) {
      return false;
    }

    ;
    var ret = false,
        func;

    for (func = 0; func < this.callbacks[type].length; func++) {
      ret = this.callbacks[type][func](args || this.id);
    }

    ;
    return ret;
  };

  datePicker.prototype.showHideButtons = function (tmpDate) {
    if (!this.butPrevYear) {
      return;
    }

    ;
    var tdm = tmpDate.getMonth(),
        tdy = tmpDate.getFullYear();

    if (this.outOfRange(new Date(tdy - 1, tdm, daysInMonth(+tdm, tdy - 1), 5, 0, 0))) {
      addClass(this.butPrevYear, "fd-disabled");

      if (this.yearInc == -1) {
        this.stopTimer();
      }

      ;
    } else {
      removeClass(this.butPrevYear, "fd-disabled");
    }

    ;

    if (this.outOfRange(new Date(tdy, +tdm - 1, daysInMonth(+tdm - 1, tdy), 5, 0, 0))) {
      addClass(this.butPrevMonth, "fd-disabled");

      if (this.monthInc == -1) {
        this.stopTimer();
      }

      ;
    } else {
      removeClass(this.butPrevMonth, "fd-disabled");
    }

    ;

    if (this.outOfRange(new Date(tdy + 1, +tdm, 1, 5, 0, 0))) {
      addClass(this.butNextYear, "fd-disabled");

      if (this.yearInc == 1) {
        this.stopTimer();
      }

      ;
    } else {
      removeClass(this.butNextYear, "fd-disabled");
    }

    ;

    if (this.outOfRange(new Date(tdy, +tdm + 1, 1, 5, 0, 0))) {
      addClass(this.butNextMonth, "fd-disabled");

      if (this.monthInc == 1) {
        this.stopTimer();
      }

      ;
    } else {
      removeClass(this.butNextMonth, "fd-disabled");
    }

    ;
  };

  var localeDefaults = {
    fullMonths: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbrs: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    fullDays: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
    dayAbbrs: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    titles: ["Previous month", "Next month", "Previous year", "Next year", "Today", "Show Calendar", "wk", "Week [[%0%]] of [[%1%]]", "Week", "Select a date", "Click & Drag to move", "Display \u201C[[%0%]]\u201D first", "Go to Today\u2019s date", "Disabled date :"],
    rtl: false,
    firstDayOfWeek: 0,
    imported: false
  };

  var joinNodeLists = function joinNodeLists() {
    if (!arguments.length) {
      return [];
    }

    ;
    var nodeList = [];

    for (var i = 0; i < arguments.length; i++) {
      for (var j = 0, item; item = arguments[i][j]; j++) {
        nodeList[nodeList.length] = item;
      }

      ;
    }

    ;
    return nodeList;
  };

  var _cleanUp = function cleanUp() {
    var dp, fe;

    for (dp in datePickers) {
      for (fe in datePickers[dp].formElements) {
        if (!document.getElementById(fe)) {
          datePickers[dp].destroy();
          datePickers[dp] = null;
          delete datePickers[dp];
          break;
        }

        ;
      }

      ;
    }

    ;
  };

  var hideAll = function hideAll(exception) {
    var dp;

    for (dp in datePickers) {
      if (!datePickers[dp].created || exception && exception == datePickers[dp].id) {
        continue;
      }

      ;
      datePickers[dp].hide();
    }

    ;
  };

  var hideDatePicker = function hideDatePicker(inpID) {
    if (inpID in datePickers) {
      if (!datePickers[inpID].created || datePickers[inpID].staticPos) {
        return;
      }

      ;
      datePickers[inpID].hide();
    }

    ;
  };

  var showDatePicker = function showDatePicker(inpID, autoFocus) {
    if (!(inpID in datePickers)) {
      return false;
    }

    ;
    datePickers[inpID].clickActivated = !!!autoFocus;
    datePickers[inpID].show(autoFocus);
    return true;
  };

  var destroy = function destroy(e) {
    e = e || window.event; // Don't remove datepickers if it's a pagehide/pagecache event (webkit et al)

    if (e.persisted) {
      return;
    }

    ;
    var dp;

    for (dp in datePickers) {
      datePickers[dp].destroy();
      datePickers[dp] = null;
      delete datePickers[dp];
    }

    ;
    datePickers = null;

    _removeEvent(window, 'unload', datePickerController.destroy);
  };

  var destroySingleDatePicker = function destroySingleDatePicker(id) {
    if (id && id in datePickers) {
      datePickers[id].destroy();
      datePickers[id] = null;
      delete datePickers[id];
    }

    ;
  };

  var getTitleTranslation = function getTitleTranslation(num, replacements) {
    replacements = replacements || [];

    if (localeImport.titles.length > num) {
      var txt = localeImport.titles[num];

      if (replacements && replacements.length) {
        for (var i = 0; i < replacements.length; i++) {
          txt = txt.replace("[[%" + i + "%]]", replacements[i]);
        }

        ;
      }

      ;
      return txt.replace(/[[%(\d)%]]/g, "");
    }

    ;
    return "";
  };

  var getDayTranslation = function getDayTranslation(day, abbreviation) {
    var titles = localeImport[abbreviation ? "dayAbbrs" : "fullDays"];
    return titles.length && titles.length > day ? titles[day] : "";
  };

  var getMonthTranslation = function getMonthTranslation(month, abbreviation) {
    var titles = localeImport[abbreviation ? "monthAbbrs" : "fullMonths"];
    return titles.length && titles.length > month ? titles[month] : "";
  };

  var daysInMonth = function daysInMonth(nMonth, nYear) {
    nMonth = (nMonth + 12) % 12;
    return 0 == nYear % 4 && (0 != nYear % 100 || 0 == nYear % 400) && nMonth == 1 ? 29 : [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][nMonth];
  };

  var getWeeksInYear = function getWeeksInYear(Y) {
    if (Y in weeksInYearCache) {
      return weeksInYearCache[Y];
    }

    ;
    var X1 = new Date(Y, 0, 4),
        X2 = new Date(Y, 11, 28);
    X1.setDate(X1.getDate() - (6 + X1.getDay()) % 7);
    X2.setDate(X2.getDate() + (7 - X2.getDay()) % 7);
    weeksInYearCache[Y] = Math.round((X2 - X1) / 604800000);
    return weeksInYearCache[Y];
  };

  var getWeekNumber = function getWeekNumber(y, m, d) {
    var d = new Date(y, m, d, 0, 0, 0),
        DoW = d.getDay(),
        ms;
    d.setDate(d.getDate() - (DoW + 6) % 7 + 3);
    ms = d.valueOf();
    d.setMonth(0);
    d.setDate(4);
    return Math.round((ms - d.valueOf()) / (7 * 864e5)) + 1;
  };

  var _printFormattedDate = function printFormattedDate(date, fmt, useImportedLocale) {
    if (!date || isNaN(date)) {
      return fmt;
    }

    ;
    var d = date.getDate(),
        D = date.getDay(),
        m = date.getMonth(),
        y = date.getFullYear(),
        locale = useImportedLocale ? localeImport : localeDefaults,
        fmtParts = String(fmt).split(formatSplitRegExp),
        fmtParts = cbSplit(fmt, formatSplitRegExp),
        fmtNewParts = [],
        flags = {
      "d": pad(d),
      "D": locale.dayAbbrs[D == 0 ? 6 : D - 1],
      "l": locale.fullDays[D == 0 ? 6 : D - 1],
      "j": d,
      "N": D == 0 ? 7 : D,
      "w": D,
      "W": getWeekNumber(y, m, d),
      "M": locale.monthAbbrs[m],
      "F": locale.fullMonths[m],
      "m": pad(m + 1),
      "n": m + 1,
      "t": daysInMonth(m, y),
      "y": String(y).substr(2, 2),
      "Y": y,
      "S": ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    },
        len = fmtParts.length,
        currFlag,
        f;

    for (f = 0; f < len; f++) {
      currFlag = fmtParts[f];
      fmtNewParts.push(currFlag in flags ? flags[currFlag] : currFlag);
    }

    ;
    return fmtNewParts.join("");
  };

  var _parseDateString = function parseDateString(str, fmt) {
    var d = false,
        m = false,
        y = false,
        dp = fmt.search(dPartsRegExp) != -1 ? 1 : 0,
        mp = fmt.search(mPartsRegExp) != -1 ? 1 : 0,
        yp = fmt.search(yPartsRegExp) != -1 ? 1 : 0,
        now = new Date(),
        parts = cbSplit(fmt, formatSplitRegExp),
        str = "" + str,
        len = parts.length,
        pt,
        part,
        l;

    loopLabel: for (pt = 0; pt < len; pt++) {
      part = parts[pt];

      if (part === "") {
        continue loopLabel;
      }

      ;

      if (str.length == 0) {
        break;
      }

      ;

      switch (part) {
        // Dividers - be easy on them all i.e. accept them all when parsing...
        case "/":
        case ".":
        case " ":
        case "-":
        case ",":
        case ":":
          str = str.substr(1);
          break;
        // DAY

        case "d":
          // Day of the month, 2 digits with leading zeros (01 - 31)
          if (str.search(/^(3[01]|[12][0-9]|0[1-9])/) != -1) {
            d = str.substr(0, 2);
            str = str.substr(2);
            break;
          } else {
            return false;
          }

          ;

        case "j":
          // Day of the month without leading zeros (1 - 31)
          if (str.search(/^(3[01]|[12][0-9]|[1-9])/) != -1) {
            d = +str.match(/^(3[01]|[12][0-9]|[1-9])/)[0];
            str = str.substr(str.match(/^(3[01]|[12][0-9]|[1-9])/)[0].length);
            break;
          } else {
            return false;
          }

          ;

        case "D": // A textual representation of a day, three letters (Mon - Sun)

        case "l":
          // A full textual representation of the day of the week (Monday - Sunday)
          // Accept English & imported locales and both modifiers
          l = localeDefaults.fullDays.concat(localeDefaults.dayAbbrs);

          if (localeImport.imported) {
            l = l.concat(localeImport.fullDays).concat(localeImport.dayAbbrs);
          }

          ;

          for (var i = 0; i < l.length; i++) {
            if (new RegExp("^" + l[i], "i").test(str)) {
              str = str.substr(l[i].length);
              continue loopLabel;
            }

            ;
          }

          ;
          break;

        case "N": // ISO-8601 numeric representation of the day of the week (added in PHP 5.1.0) 1 (for Monday) through 7 (for Sunday)

        case "w":
          // Numeric representation of the day of the week 0 (for Sunday) through 6 (for Saturday)
          if (str.search(part == "N" ? /^([1-7])/ : /^([0-6])/) != -1) {
            str = str.substr(1);
          }

          ;
          break;

        case "S":
          // English ordinal suffix for the day of the month, 2 characters: st, nd, rd or th
          if (str.search(/^(st|nd|rd|th)/i) != -1) {
            str = str.substr(2);
          }

          ;
          break;
        // WEEK

        case "W":
          // ISO-8601 week number of year, weeks starting on Monday (added in PHP 4.1.0): 1 - 53
          if (str.search(/^([1-9]|[1234[0-9]|5[0-3])/) != -1) {
            str = str.substr(str.match(/^([1-9]|[1234[0-9]|5[0-3])/)[0].length);
          }

          ;
          break;
        // MONTH

        case "M": // A short textual representation of a month, three letters

        case "F":
          // A full textual representation of a month, such as January or March
          // Accept English & imported locales and both modifiers
          l = localeDefaults.fullMonths.concat(localeDefaults.monthAbbrs);

          if (localeImport.imported) {
            l = l.concat(localeImport.fullMonths).concat(localeImport.monthAbbrs);
          }

          ;

          for (var i = 0; i < l.length; i++) {
            if (str.search(new RegExp("^" + l[i], "i")) != -1) {
              str = str.substr(l[i].length);
              m = (i + 12) % 12 + 1;
              continue loopLabel;
            }

            ;
          }

          ;
          return false;

        case "m":
          // Numeric representation of a month, with leading zeros
          l = /^(1[012]|0[1-9])/;

          if (str.search(l) != -1) {
            m = +str.substr(0, 2);
            str = str.substr(2);
            break;
          } else {
            return false;
          }

          ;

        case "n":
          // Numeric representation of a month, without leading zeros
          // Accept either when parsing
          l = /^(1[012]|[1-9])/;

          if (str.search(l) != -1) {
            m = +str.match(l)[0];
            str = str.substr(str.match(l)[0].length);
            break;
          } else {
            return false;
          }

          ;

        case "t":
          // Number of days in the given month: 28 through 31
          if (str.search(/2[89]|3[01]/) != -1) {
            str = str.substr(2);
            break;
          } else {
            return false;
          }

          ;
        // YEAR

        case "Y":
          // A full numeric representation of a year, 4 digits
          if (str.search(/^(\d{4})/) != -1) {
            y = str.substr(0, 4);
            str = str.substr(4);
            break;
          } else {
            return false;
          }

          ;

        case "y":
          // A two digit representation of a year
          if (str.search(/^(0[0-9]|[1-9][0-9])/) != -1) {
            y = str.substr(0, 2);
            y = +y < 50 ? '20' + String(y) : '19' + String(y);
            str = str.substr(2);
            break;
          } else {
            return false;
          }

          ;

        default:
          str = str.substr(part.length);
      }

      ;
    }

    ;

    if (dp && d === false || mp && m === false || yp && y === false) {
      return false;
    }

    ;

    if (dp && mp && yp && +d > daysInMonth(+m - 1, +y)) {
      return false;
    }

    ;
    return {
      "d": dp ? +d : false,
      "m": mp ? +m : false,
      "y": yp ? +y : false
    };
  };

  var findLabelForElement = function findLabelForElement(element) {
    var label;

    if (element.parentNode && element.parentNode.tagName.toLowerCase() == "label") {
      label = element.parentNode;
    } else {
      var labelList = document.getElementsByTagName('label'); // loop through label array attempting to match each 'for' attribute to the id of the current element

      for (var lbl = 0; lbl < labelList.length; lbl++) {
        // Internet Explorer requires the htmlFor test
        if (labelList[lbl]['htmlFor'] && labelList[lbl]['htmlFor'] == element.id || labelList[lbl].getAttribute('for') == element.id) {
          label = labelList[lbl];
          break;
        }

        ;
      }

      ;
    }

    ;

    if (label && !label.id && element.id) {
      label.id = element.id + "_label";
    }

    ;
    return label;
  };

  var updateLanguage = function updateLanguage() {
    console.log('test');

    if (_typeof(window.fdLocale) == "object") {
      localeImport = {
        titles: fdLocale.titles,
        fullMonths: fdLocale.fullMonths,
        monthAbbrs: fdLocale.monthAbbrs,
        fullDays: fdLocale.fullDays,
        dayAbbrs: fdLocale.dayAbbrs,
        firstDayOfWeek: "firstDayOfWeek" in fdLocale ? fdLocale.firstDayOfWeek : 0,
        rtl: "rtl" in fdLocale ? !!fdLocale.rtl : false,
        imported: true
      };
    } else if (!localeImport) {
      localeImport = localeDefaults;
    }

    ;
  };

  var _loadLanguage = function loadLanguage() {
    updateLanguage();
    var dp;

    for (dp in datePickers) {
      if (!datePickers[dp].created) {
        continue;
      }

      ;
      datePickers[dp].updateTable();
    }

    ;
  };

  var checkElem = function checkElem(elem) {
    return !(!elem || !elem.tagName || !(elem.tagName.toLowerCase() == "input" && (elem.type == "text" || elem.type == "hidden") || elem.tagName.toLowerCase() == "select"));
  };

  var addDatePicker = function addDatePicker(options) {
    updateLanguage();

    if (cssAnimations === null) {
      cssAnimations = testCSSAnimationSupport();
    }

    ;

    if (!options.formElements) {
      if (_debug) {
        throw "No form elements stipulated within initialisation parameters";
      }

      ;
      return;
    }

    ;
    options.id = options.id && options.id in options.formElements ? options.id : "";
    options.enabledDates = false;
    options.disabledDates = false;
    var partsFound = {
      d: 0,
      m: 0,
      y: 0
    },
        defaultVals = {},
        cursorDate = false,
        myMin = 0,
        myMax = 0,
        fmt,
        opts,
        dtPartStr,
        elemID,
        elem,
        dt,
        i;

    for (elemID in options.formElements) {
      elem = document.getElementById(elemID);

      if (!checkElem(elem)) {
        if (_debug) {
          throw "Element '" + elemID + "' is of the wrong type or does not exist within the DOM";
        }

        ;
        return false;
      }

      ;

      if (!options.formElements[elemID].match(formatTestRegExp)) {
        if (_debug) {
          throw "Element '" + elemID + "' has a date format that does not contain either a day (d|j), month (m|F|n) or year (y|Y) part: " + options.formElements[elemID];
        }

        ;
        return false;
      }

      ;

      if (!options.id) {
        options.id = elemID;
      }

      ;
      defaultVals[elemID] = elem.tagName == "select" ? elem.selectedIndex || 0 : elem.defaultValue;
      fmt = {
        "value": options.formElements[elemID]
      };
      fmt.d = fmt.value.search(dPartsRegExp) != -1;
      fmt.m = fmt.value.search(mPartsRegExp) != -1;
      fmt.y = fmt.value.search(yPartsRegExp) != -1;

      if (fmt.d) {
        partsFound.d++;
      }

      ;

      if (fmt.m) {
        partsFound.m++;
      }

      ;

      if (fmt.y) {
        partsFound.y++;
      }

      ;

      if (elem.tagName.toLowerCase() == "select") {
        // If we have a selectList, then try to parse the higher and lower limits
        var selOptions = elem.options; // Check the yyyymmdd

        if (fmt.d && fmt.m && fmt.y) {
          cursorDate = false; // Dynamically calculate the available "enabled" dates

          options.enabledDates = {};
          options.disabledDates = {};

          for (i = 0; i < selOptions.length; i++) {
            dt = _parseDateString(selOptions[i].value, fmt.value);

            if (dt && dt.y && !(dt.m === false) && dt.d) {
              dtPartStr = dt.y + "" + pad(dt.m) + pad(dt.d);

              if (!cursorDate) {
                cursorDate = dtPartStr;
              }

              ;
              options.enabledDates[dtPartStr] = 1;

              if (!myMin || +dtPartStr < +myMin) {
                myMin = dtPartStr;
              }

              ;

              if (!myMax || +dtPartStr > +myMax) {
                myMax = dtPartStr;
              }

              ;
            }

            ;
          }

          ; // Automatically set cursor to first available date (if no bespoke cursorDate was set);

          if (!options.cursorDate && cursorDate) {
            options.cursorDate = cursorDate;
          }

          ;
          options.disabledDates[myMin] = myMax;
        } else if (fmt.m && fmt.y) {
          for (i = 0; i < selOptions.length; i++) {
            dt = _parseDateString(selOptions[i].value, fmt.value);

            if (dt.y && !(dt.m === false)) {
              dtPartStr = dt.y + "" + pad(dt.m);

              if (!myMin || +dtPartStr < +myMin) {
                myMin = dtPartStr;
              }

              ;

              if (!myMax || +dtPartStr > +myMax) {
                myMax = dtPartStr;
              }

              ;
            }

            ;
          }

          ; // Round the min & max values to be used as rangeLow & rangeHigh

          myMin += "" + "01";
          myMax += "" + daysInMonth(+myMax.substr(4, 2) - 1, +myMax.substr(0, 4));
        } else if (fmt.y) {
          for (i = 0; i < selOptions.length; i++) {
            dt = _parseDateString(selOptions[i].value, fmt.value);

            if (dt.y) {
              if (!myMin || +dt.y < +myMin) {
                myMin = dt.y;
              }

              ;

              if (!myMax || +dt.y > +myMax) {
                myMax = dt.y;
              }

              ;
            }

            ;
          }

          ; // Round the min & max values to be used as rangeLow & rangeHigh

          myMin += "" + "0101";
          myMax += "" + "1231";
        }

        ;
      }

      ;
    }

    ;

    if (!(partsFound.d == 1 && partsFound.m == 1 && partsFound.y == 1)) {
      if (_debug) {
        throw "Could not find all of the required date parts within the date format for element: " + elem.id;
      }

      ;
      return false;
    }

    ;
    options.rangeLow = dateToYYYYMMDD(options.rangeLow || false);
    options.rangeHigh = dateToYYYYMMDD(options.rangeHigh || false);
    options.cursorDate = dateToYYYYMMDD(options.cursorDate || false);

    if (myMin && (!options.rangeLow || +options.rangeLow < +myMin)) {
      options.rangeLow = myMin;
    }

    ;

    if (myMax && (!options.rangeHigh || +options.rangeHigh > +myMax)) {
      options.rangeHigh = myMax;
    }

    ;
    opts = {
      formElements: options.formElements,
      // default values
      defaultVals: defaultVals,
      // Form element id
      id: options.id,
      // Non popup datepicker required
      staticPos: !!(options.staticPos || options.nopopup),
      // Position static datepicker or popup datepicker's button
      positioned: options.positioned && document.getElementById(options.positioned) ? options.positioned : "",
      // Ranges stipulated in YYYYMMDD format
      rangeLow: options.rangeLow && String(options.rangeLow).search(rangeRegExp) != -1 ? options.rangeLow : "",
      rangeHigh: options.rangeHigh && String(options.rangeHigh).search(rangeRegExp) != -1 ? options.rangeHigh : "",
      // Status bar format
      statusFormat: options.statusFormat || statusFormat,
      // No fade in/out effect
      noFadeEffect: !!options.staticPos ? true : !!options.noFadeEffect,
      // No drag functionality
      dragDisabled: _nodrag || !!options.staticPos ? true : !!options.dragDisabled,
      // Bespoke tabindex for this datePicker (or its activation button)
      bespokeTabIndex: options.bespokeTabindex && typeof options.bespokeTabindex == 'number' ? parseInt(options.bespokeTabindex, 10) : 0,
      // Bespoke titles
      bespokeTitles: options.bespokeTitles || bespokeTitles || {},
      // Final opacity
      finalOpacity: options.finalOpacity && typeof options.finalOpacity == 'number' && options.finalOpacity > 20 && options.finalOpacity <= 100 ? parseInt(+options.finalOpacity, 10) : !!options.staticPos ? 100 : finalOpacity,
      // Do we hide the form elements on datepicker creation
      hideInput: !!options.hideInput,
      // Do we hide the "today" button
      noToday: !!options.noTodayButton,
      // Do we show week numbers
      showWeeks: !!options.showWeeks,
      // Do we fill the entire grid with dates
      fillGrid: !!options.fillGrid,
      // Do we constrain selection of dates outside the current month
      constrainSelection: "constrainSelection" in options ? !!options.constrainSelection : true,
      // The date to set the initial cursor to
      cursorDate: options.cursorDate && String(options.cursorDate).search(rangeRegExp) != -1 ? options.cursorDate : "",
      // Locate label to set the ARIA labelled-by property
      labelledBy: findLabelForElement(elem),
      // Have we been passed a describedBy to set the ARIA decribed-by property...
      describedBy: options.describedBy && document.getElementById(options.describedBy) ? options.describedBy : describedBy && document.getElementById(describedBy) ? describedBy : "",
      // Callback functions
      callbacks: options.callbackFunctions ? options.callbackFunctions : {},
      // Days of the week to highlight (normally the weekend)
      highlightDays: options.highlightDays && options.highlightDays.length && options.highlightDays.length == 7 ? options.highlightDays : [0, 0, 0, 0, 0, 1, 1],
      // Days of the week to disable
      disabledDays: options.disabledDays && options.disabledDays.length && options.disabledDays.length == 7 ? options.disabledDays : [0, 0, 0, 0, 0, 0, 0],
      // A bespoke class to give the datepicker
      bespokeClass: options.bespokeClass ? " " + options.bespokeClass : ""
    };
    datePickers[options.id] = new datePicker(opts);

    if ("disabledDates" in options && !(options.disabledDates === false)) {
      datePickers[options.id].setDisabledDates(options.disabledDates);
    }

    ;

    if ("enabledDates" in options && !(options.enabledDates === false)) {
      datePickers[options.id].setEnabledDates(options.enabledDates);
    }

    ;
    datePickers[options.id].callback("create", datePickers[options.id].createCbArgObj());
  }; // Used by the button to dictate whether to open or close the datePicker


  var isVisible = function isVisible(id) {
    return !id || !(id in datePickers) ? false : datePickers[id].visible;
  };

  var updateStatic = function updateStatic() {
    var dp;

    for (dp in datePickers) {
      if (datePickers.hasOwnProperty(dp)) {
        datePickers[dp].changeHandler();
      }

      ;
    }

    ;
  };

  var testCSSAnimationSupport = function testCSSAnimationSupport() {
    var domPrefixes = ["Webkit", "Moz", "ms", "O"],
        elm = document.createElement('div'),
        transitions = ["WebkitTransition", "transition", "OTransition", "MozTransition", "msTransition"],
        t;

    for (t = 0; t < transitions.length; t++) {
      if (transitions[t] in elm.style) {
        transitionEnd = transitions[t] == "webkitTransition" || transitions[t] == "OTransition" ? transitions[t] + "End" : "transitionend";
        break;
      }
    }

    if (!transitionEnd) {
      return false;
    }

    ;

    if (elm.style.animationName) {
      return true;
    }

    for (var i = 0; i < domPrefixes.length; i++) {
      if (elm.style[domPrefixes[i] + "AnimationName"] !== undefined) {
        return true;
      }

      ;
    }

    ;
    return false;
  };

  _addEvent(window, 'unload', destroy);

  _addEvent(window, "load", function () {
    setTimeout(updateStatic, 0);
  }); // Add oldie class if needed for IE < 9


  if (oldIE) {
    addClass(document.documentElement, "oldie");
  }

  ;
  return {
    // General event functions...
    addEvent: function addEvent(obj, type, fn) {
      return _addEvent(obj, type, fn);
    },
    removeEvent: function removeEvent(obj, type, fn) {
      return _removeEvent(obj, type, fn);
    },
    stopEvent: function stopEvent(e) {
      return _stopEvent(e);
    },
    // Show a single popup datepicker
    show: function show(inpID) {
      return showDatePicker(inpID, false);
    },
    // Hide a popup datepicker
    hide: function hide(inpID) {
      return hideDatePicker(inpID);
    },
    // Create a new datepicker
    createDatePicker: function createDatePicker(options) {
      addDatePicker(options);
    },
    // Destroy a datepicker (remove events and DOM nodes)
    destroyDatePicker: function destroyDatePicker(inpID) {
      destroySingleDatePicker(inpID);
    },
    // Check datePicker form elements exist, if not, destroy the datepicker
    cleanUp: function cleanUp() {
      _cleanUp();
    },
    // Pretty print a date object according to the format passed in
    printFormattedDate: function printFormattedDate(dt, fmt, useImportedLocale) {
      return _printFormattedDate(dt, fmt, useImportedLocale);
    },
    // Update the internal date using the form element value
    setDateFromInput: function setDateFromInput(inpID) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].setDateFromInput();
    },
    // Set low and high date ranges
    setRangeLow: function setRangeLow(inpID, yyyymmdd) {
      if (!inpID || !(inpID in datePickers)) {
        return false;
      }

      ;
      datePickers[inpID].setRangeLow(dateToYYYYMMDD(yyyymmdd));
    },
    setRangeHigh: function setRangeHigh(inpID, yyyymmdd) {
      if (!inpID || !(inpID in datePickers)) {
        return false;
      }

      ;
      datePickers[inpID].setRangeHigh(dateToYYYYMMDD(yyyymmdd));
    },
    // Set bespoke titles for a datepicker instance
    setBespokeTitles: function setBespokeTitles(inpID, titles) {
      if (!inpID || !(inpID in datePickers)) {
        return false;
      }

      ;
      datePickers[inpID].setBespokeTitles(titles);
    },
    // Add bespoke titles for a datepicker instance
    addBespokeTitles: function addBespokeTitles(inpID, titles) {
      if (!inpID || !(inpID in datePickers)) {
        return false;
      }

      ;
      datePickers[inpID].addBespokeTitles(titles);
    },
    // Attempt to parse a valid date from a date string using the passed in format
    parseDateString: function parseDateString(str, format) {
      return _parseDateString(str, format);
    },
    // Change global configuration parameters
    setGlobalOptions: function setGlobalOptions(json) {
      affectJSON(json);
    },
    // Forces the datepickers "selected" date
    setSelectedDate: function setSelectedDate(inpID, yyyymmdd) {
      if (!inpID || !(inpID in datePickers)) {
        return false;
      }

      ;
      datePickers[inpID].setSelectedDate(dateToYYYYMMDD(yyyymmdd));
    },
    // Is the date valid for selection i.e. not outside ranges etc
    dateValidForSelection: function dateValidForSelection(inpID, dt) {
      if (!inpID || !(inpID in datePickers)) return false;
      return datePickers[inpID].canDateBeSelected(dt);
    },
    // Add disabled and enabled dates
    addDisabledDates: function addDisabledDates(inpID, dts) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].addDisabledDates(dts);
    },
    setDisabledDates: function setDisabledDates(inpID, dts) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].setDisabledDates(dts);
    },
    addEnabledDates: function addEnabledDates(inpID, dts) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].addEnabledDates(dts);
    },
    setEnabledDates: function setEnabledDates(inpID, dts) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].setEnabledDates(dts);
    },
    // Disable and enable the datepicker
    disable: function disable(inpID) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].disableDatePicker();
    },
    enable: function enable(inpID) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].enableDatePicker();
    },
    // Set the cursor date
    setCursorDate: function setCursorDate(inpID, yyyymmdd) {
      if (!inpID || !(inpID in datePickers)) return false;
      datePickers[inpID].setCursorDate(dateToYYYYMMDD(yyyymmdd));
    },
    // Whats the currently selected date
    getSelectedDate: function getSelectedDate(inpID) {
      return !inpID || !(inpID in datePickers) ? false : datePickers[inpID].returnSelectedDate();
    },
    // Attempt to update the language (causes a redraw of all datepickers on the page)
    loadLanguage: function loadLanguage() {
      _loadLanguage();
    },
    // Set the debug level i.e. throw errors or fail silently
    setDebug: function setDebug(dbg) {
      _debug = !!dbg;
    },
    // Converts Date Object to a YYYYMMDD formatted String
    dateToYYYYMMDDStr: function dateToYYYYMMDDStr(dt) {
      return dateToYYYYMMDD(dt);
    }
  };
}();

/* harmony default export */ __webpack_exports__["a"] = (datePickerController);

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * jquery-timepicker v1.11.5 - A jQuery timepicker plugin inspired by Google Calendar. It supports both mouse and keyboard navigation.
 * Copyright (c) 2015 Jon Thornton - http://jonthornton.github.com/jquery-timepicker/
 * License: MIT
 */
(function (factory) {
  if (( false ? "undefined" : _typeof(exports)) === "object" && exports && ( false ? "undefined" : _typeof(module)) === "object" && module && module.exports === exports) {
    // Browserify. Attach to jQuery module.
    factory(__webpack_require__(33));
  } else if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(33)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function ($) {
  var _ONE_DAY = 86400;
  var _lang = {
    am: 'am',
    pm: 'pm',
    AM: 'AM',
    PM: 'PM',
    decimal: '.',
    mins: 'mins',
    hr: 'hr',
    hrs: 'hrs'
  };
  var methods = {
    init: function init(options) {
      return this.each(function () {
        var self = $(this); // pick up settings from data attributes

        var attributeOptions = [];

        for (var key in $.fn.timepicker.defaults) {
          if (self.data(key)) {
            attributeOptions[key] = self.data(key);
          }
        }

        var settings = $.extend({}, $.fn.timepicker.defaults, attributeOptions, options);

        if (settings.lang) {
          _lang = $.extend(_lang, settings.lang);
        }

        settings = _parseSettings(settings);
        self.data('timepicker-settings', settings);
        self.addClass('ui-timepicker-input');

        if (settings.useSelect) {
          _render(self);
        } else {
          self.prop('autocomplete', 'off');

          if (settings.showOn) {
            for (var i in settings.showOn) {
              self.on(settings.showOn[i] + '.timepicker', methods.show);
            }
          }

          self.on('change.timepicker', _formatValue);
          self.on('keydown.timepicker', _keydownhandler);
          self.on('keyup.timepicker', _keyuphandler);

          if (settings.disableTextInput) {
            self.on('keydown.timepicker', _disableTextInputHandler);
          }

          _formatValue.call(self.get(0), null, 'initial');
        }
      });
    },
    show: function show(e) {
      var self = $(this);
      var settings = self.data('timepicker-settings');

      if (e) {
        e.preventDefault();
      }

      if (settings.useSelect) {
        self.data('timepicker-list').focus();
        return;
      }

      if (_hideKeyboard(self)) {
        // block the keyboard on mobile devices
        self.blur();
      }

      var list = self.data('timepicker-list'); // check if input is readonly

      if (self.prop('readonly')) {
        return;
      } // check if list needs to be rendered


      if (!list || list.length === 0 || typeof settings.durationTime === 'function') {
        _render(self);

        list = self.data('timepicker-list');
      }

      if (_isVisible(list)) {
        return;
      }

      self.data('ui-timepicker-value', self.val());

      _setSelected(self, list); // make sure other pickers are hidden


      methods.hide(); // position the dropdown relative to the input

      list.show();
      var listOffset = {};

      if (settings.orientation.match(/r/)) {
        // right-align the dropdown
        listOffset.left = self.offset().left + self.outerWidth() - list.outerWidth() + parseInt(list.css('marginLeft').replace('px', ''), 10);
      } else {
        // left-align the dropdown
        listOffset.left = self.offset().left + parseInt(list.css('marginLeft').replace('px', ''), 10);
      }

      var verticalOrientation;

      if (settings.orientation.match(/t/)) {
        verticalOrientation = 't';
      } else if (settings.orientation.match(/b/)) {
        verticalOrientation = 'b';
      } else if (self.offset().top + self.outerHeight(true) + list.outerHeight() > $(window).height() + $(window).scrollTop()) {
        verticalOrientation = 't';
      } else {
        verticalOrientation = 'b';
      }

      if (verticalOrientation == 't') {
        // position the dropdown on top
        list.addClass('ui-timepicker-positioned-top');
        listOffset.top = self.offset().top - list.outerHeight() + parseInt(list.css('marginTop').replace('px', ''), 10);
      } else {
        // put it under the input
        list.removeClass('ui-timepicker-positioned-top');
        listOffset.top = self.offset().top + self.outerHeight() + parseInt(list.css('marginTop').replace('px', ''), 10);
      }

      list.offset(listOffset); // position scrolling

      var selected = list.find('.ui-timepicker-selected');

      if (!selected.length) {
        var timeInt = _time2int(_getTimeValue(self));

        if (timeInt !== null) {
          selected = _findRow(self, list, timeInt);
        } else if (settings.scrollDefault) {
          selected = _findRow(self, list, settings.scrollDefault());
        }
      }

      if (selected && selected.length) {
        var topOffset = list.scrollTop() + selected.position().top - selected.outerHeight();
        list.scrollTop(topOffset);
      } else {
        list.scrollTop(0);
      } // prevent scroll propagation


      if (settings.stopScrollPropagation) {
        $(document).on('wheel.ui-timepicker', '.ui-timepicker-wrapper', function (e) {
          e.preventDefault();
          var currentScroll = $(this).scrollTop();
          $(this).scrollTop(currentScroll + e.originalEvent.deltaY);
        });
      } // attach close handlers


      $(document).on('touchstart.ui-timepicker mousedown.ui-timepicker', _closeHandler);
      $(window).on('resize.ui-timepicker', _closeHandler);

      if (settings.closeOnWindowScroll) {
        $(document).on('scroll.ui-timepicker', _closeHandler);
      }

      self.trigger('showTimepicker');
      return this;
    },
    hide: function hide(e) {
      var self = $(this);
      var settings = self.data('timepicker-settings');

      if (settings && settings.useSelect) {
        self.blur();
      }

      $('.ui-timepicker-wrapper').each(function () {
        var list = $(this);

        if (!_isVisible(list)) {
          return;
        }

        var self = list.data('timepicker-input');
        var settings = self.data('timepicker-settings');

        if (settings && settings.selectOnBlur) {
          _selectValue(self);
        }

        list.hide();
        self.trigger('hideTimepicker');
      });
      return this;
    },
    option: function option(key, value) {
      if (typeof key == 'string' && typeof value == 'undefined') {
        return $(this).data('timepicker-settings')[key];
      }

      return this.each(function () {
        var self = $(this);
        var settings = self.data('timepicker-settings');
        var list = self.data('timepicker-list');

        if (_typeof(key) == 'object') {
          settings = $.extend(settings, key);
        } else if (typeof key == 'string') {
          settings[key] = value;
        }

        settings = _parseSettings(settings);
        self.data('timepicker-settings', settings);

        if (list) {
          list.remove();
          self.data('timepicker-list', false);
        }

        if (settings.useSelect) {
          _render(self);
        }
      });
    },
    getSecondsFromMidnight: function getSecondsFromMidnight() {
      return _time2int(_getTimeValue(this));
    },
    getTime: function getTime(relative_date) {
      var self = this;

      var time_string = _getTimeValue(self);

      if (!time_string) {
        return null;
      }

      var offset = _time2int(time_string);

      if (offset === null) {
        return null;
      }

      if (!relative_date) {
        relative_date = new Date();
      } // construct a Date from relative date, and offset's time


      var time = new Date(relative_date);
      time.setHours(offset / 3600);
      time.setMinutes(offset % 3600 / 60);
      time.setSeconds(offset % 60);
      time.setMilliseconds(0);
      return time;
    },
    isVisible: function isVisible() {
      var self = this;
      var list = self.data('timepicker-list');
      return !!(list && _isVisible(list));
    },
    setTime: function setTime(value) {
      var self = this;
      var settings = self.data('timepicker-settings');

      if (settings.forceRoundTime) {
        var prettyTime = _roundAndFormatTime(_time2int(value), settings);
      } else {
        var prettyTime = _int2time(_time2int(value), settings);
      }

      if (value && prettyTime === null && settings.noneOption) {
        prettyTime = value;
      }

      _setTimeValue(self, prettyTime);

      if (self.data('timepicker-list')) {
        _setSelected(self, self.data('timepicker-list'));
      }

      return this;
    },
    remove: function remove() {
      var self = this; // check if this element is a timepicker

      if (!self.hasClass('ui-timepicker-input')) {
        return;
      }

      var settings = self.data('timepicker-settings');
      self.removeAttr('autocomplete', 'off');
      self.removeClass('ui-timepicker-input');
      self.removeData('timepicker-settings');
      self.off('.timepicker'); // timepicker-list won't be present unless the user has interacted with this timepicker

      if (self.data('timepicker-list')) {
        self.data('timepicker-list').remove();
      }

      if (settings.useSelect) {
        self.show();
      }

      self.removeData('timepicker-list');
      return this;
    }
  }; // private methods

  function _isVisible(elem) {
    var el = elem[0];
    return el.offsetWidth > 0 && el.offsetHeight > 0;
  }

  function _parseSettings(settings) {
    if (settings.minTime) {
      settings.minTime = _time2int(settings.minTime);
    }

    if (settings.maxTime) {
      settings.maxTime = _time2int(settings.maxTime);
    }

    if (settings.durationTime && typeof settings.durationTime !== 'function') {
      settings.durationTime = _time2int(settings.durationTime);
    }

    if (settings.scrollDefault == 'now') {
      settings.scrollDefault = function () {
        return settings.roundingFunction(_time2int(new Date()), settings);
      };
    } else if (settings.scrollDefault && typeof settings.scrollDefault != 'function') {
      var val = settings.scrollDefault;

      settings.scrollDefault = function () {
        return settings.roundingFunction(_time2int(val), settings);
      };
    } else if (settings.minTime) {
      settings.scrollDefault = function () {
        return settings.roundingFunction(settings.minTime, settings);
      };
    }

    if ($.type(settings.timeFormat) === "string" && settings.timeFormat.match(/[gh]/)) {
      settings._twelveHourTime = true;
    }

    if (settings.showOnFocus === false && settings.showOn.indexOf('focus') != -1) {
      settings.showOn.splice(settings.showOn.indexOf('focus'), 1);
    }

    if (settings.disableTimeRanges.length > 0) {
      // convert string times to integers
      for (var i in settings.disableTimeRanges) {
        settings.disableTimeRanges[i] = [_time2int(settings.disableTimeRanges[i][0]), _time2int(settings.disableTimeRanges[i][1])];
      } // sort by starting time


      settings.disableTimeRanges = settings.disableTimeRanges.sort(function (a, b) {
        return a[0] - b[0];
      }); // merge any overlapping ranges

      for (var i = settings.disableTimeRanges.length - 1; i > 0; i--) {
        if (settings.disableTimeRanges[i][0] <= settings.disableTimeRanges[i - 1][1]) {
          settings.disableTimeRanges[i - 1] = [Math.min(settings.disableTimeRanges[i][0], settings.disableTimeRanges[i - 1][0]), Math.max(settings.disableTimeRanges[i][1], settings.disableTimeRanges[i - 1][1])];
          settings.disableTimeRanges.splice(i, 1);
        }
      }
    }

    return settings;
  }

  function _render(self) {
    var settings = self.data('timepicker-settings');
    var list = self.data('timepicker-list');

    if (list && list.length) {
      list.remove();
      self.data('timepicker-list', false);
    }

    if (settings.useSelect) {
      list = $('<select />', {
        'class': 'ui-timepicker-select'
      });
      var wrapped_list = list;
    } else {
      list = $('<ul />', {
        'class': 'ui-timepicker-list'
      });
      var wrapped_list = $('<div />', {
        'class': 'ui-timepicker-wrapper',
        'tabindex': -1
      });
      wrapped_list.css({
        'display': 'none',
        'position': 'absolute'
      }).append(list);
    }

    if (settings.noneOption) {
      if (settings.noneOption === true) {
        settings.noneOption = settings.useSelect ? 'Time...' : 'None';
      }

      if ($.isArray(settings.noneOption)) {
        for (var i in settings.noneOption) {
          if (parseInt(i, 10) == i) {
            var noneElement = _generateNoneElement(settings.noneOption[i], settings.useSelect);

            list.append(noneElement);
          }
        }
      } else {
        var noneElement = _generateNoneElement(settings.noneOption, settings.useSelect);

        list.append(noneElement);
      }
    }

    if (settings.className) {
      wrapped_list.addClass(settings.className);
    }

    if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
      var stepval = typeof settings.step == 'function' ? 'function' : settings.step;
      wrapped_list.addClass('ui-timepicker-with-duration');
      wrapped_list.addClass('ui-timepicker-step-' + settings.step);
    }

    var durStart = settings.minTime;

    if (typeof settings.durationTime === 'function') {
      durStart = _time2int(settings.durationTime());
    } else if (settings.durationTime !== null) {
      durStart = settings.durationTime;
    }

    var start = settings.minTime !== null ? settings.minTime : 0;
    var end = settings.maxTime !== null ? settings.maxTime : start + _ONE_DAY - 1;

    if (end < start) {
      // make sure the end time is greater than start time, otherwise there will be no list to show
      end += _ONE_DAY;
    }

    if (end === _ONE_DAY - 1 && $.type(settings.timeFormat) === "string" && settings.show2400) {
      // show a 24:00 option when using military time
      end = _ONE_DAY;
    }

    var dr = settings.disableTimeRanges;
    var drCur = 0;
    var drLen = dr.length;
    var stepFunc = settings.step;

    if (typeof stepFunc != 'function') {
      stepFunc = function stepFunc() {
        return settings.step;
      };
    }

    for (var i = start, j = 0; i <= end; j++, i += stepFunc(j) * 60) {
      var timeInt = i;

      var timeString = _int2time(timeInt, settings);

      if (settings.useSelect) {
        var row = $('<option />', {
          'value': timeString
        });
        row.text(timeString);
      } else {
        var row = $('<li />');
        row.addClass(timeInt % 86400 < 43200 ? 'ui-timepicker-am' : 'ui-timepicker-pm');
        row.data('time', timeInt <= 86400 ? timeInt : timeInt % 86400);
        row.text(timeString);
      }

      if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
        var durationString = _int2duration(i - durStart, settings.step);

        if (settings.useSelect) {
          row.text(row.text() + ' (' + durationString + ')');
        } else {
          var duration = $('<span />', {
            'class': 'ui-timepicker-duration'
          });
          duration.text(' (' + durationString + ')');
          row.append(duration);
        }
      }

      if (drCur < drLen) {
        if (timeInt >= dr[drCur][1]) {
          drCur += 1;
        }

        if (dr[drCur] && timeInt >= dr[drCur][0] && timeInt < dr[drCur][1]) {
          if (settings.useSelect) {
            row.prop('disabled', true);
          } else {
            row.addClass('ui-timepicker-disabled');
          }
        }
      }

      list.append(row);
    }

    wrapped_list.data('timepicker-input', self);
    self.data('timepicker-list', wrapped_list);

    if (settings.useSelect) {
      if (self.val()) {
        list.val(_roundAndFormatTime(_time2int(self.val()), settings));
      }

      list.on('focus', function () {
        $(this).data('timepicker-input').trigger('showTimepicker');
      });
      list.on('blur', function () {
        $(this).data('timepicker-input').trigger('hideTimepicker');
      });
      list.on('change', function () {
        _setTimeValue(self, $(this).val(), 'select');
      });

      _setTimeValue(self, list.val(), 'initial');

      self.hide().after(list);
    } else {
      var appendTo = settings.appendTo;

      if (typeof appendTo === 'string') {
        appendTo = $(appendTo);
      } else if (typeof appendTo === 'function') {
        appendTo = appendTo(self);
      }

      appendTo.append(wrapped_list);

      _setSelected(self, list);

      list.on('mousedown click', 'li', function (e) {
        // hack: temporarily disable the focus handler
        // to deal with the fact that IE fires 'focus'
        // events asynchronously
        self.off('focus.timepicker');
        self.on('focus.timepicker-ie-hack', function () {
          self.off('focus.timepicker-ie-hack');
          self.on('focus.timepicker', methods.show);
        });

        if (!_hideKeyboard(self)) {
          self[0].focus();
        } // make sure only the clicked row is selected


        list.find('li').removeClass('ui-timepicker-selected');
        $(this).addClass('ui-timepicker-selected');

        if (_selectValue(self)) {
          self.trigger('hideTimepicker');
          list.on('mouseup.timepicker click.timepicker', 'li', function (e) {
            list.off('mouseup.timepicker click.timepicker');
            wrapped_list.hide();
          });
        }
      });
    }
  }

  function _generateNoneElement(optionValue, useSelect) {
    var label, className, value;

    if (_typeof(optionValue) == 'object') {
      label = optionValue.label;
      className = optionValue.className;
      value = optionValue.value;
    } else if (typeof optionValue == 'string') {
      label = optionValue;
    } else {
      $.error('Invalid noneOption value');
    }

    if (useSelect) {
      return $('<option />', {
        'value': value,
        'class': className,
        'text': label
      });
    } else {
      return $('<li />', {
        'class': className,
        'text': label
      }).data('time', String(value));
    }
  }

  function _roundAndFormatTime(seconds, settings) {
    seconds = settings.roundingFunction(seconds, settings);

    if (seconds !== null) {
      return _int2time(seconds, settings);
    }
  } // event handler to decide whether to close timepicker


  function _closeHandler(e) {
    if (e.target == window) {
      // mobile Chrome fires focus events against window for some reason
      return;
    }

    var target = $(e.target);

    if (target.closest('.ui-timepicker-input').length || target.closest('.ui-timepicker-wrapper').length) {
      // active timepicker was focused. ignore
      return;
    }

    methods.hide();
    $(document).unbind('.ui-timepicker');
    $(window).unbind('.ui-timepicker');
  }

  function _hideKeyboard(self) {
    var settings = self.data('timepicker-settings');
    return (window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && settings.disableTouchKeyboard;
  }

  function _findRow(self, list, value) {
    if (!value && value !== 0) {
      return false;
    }

    var settings = self.data('timepicker-settings');
    var out = false;
    var value = settings.roundingFunction(value, settings); // loop through the menu items

    list.find('li').each(function (i, obj) {
      var jObj = $(obj);

      if (typeof jObj.data('time') != 'number') {
        return;
      }

      if (jObj.data('time') == value) {
        out = jObj;
        return false;
      }
    });
    return out;
  }

  function _setSelected(self, list) {
    list.find('li').removeClass('ui-timepicker-selected');

    var timeValue = _time2int(_getTimeValue(self), self.data('timepicker-settings'));

    if (timeValue === null) {
      return;
    }

    var selected = _findRow(self, list, timeValue);

    if (selected) {
      var topDelta = selected.offset().top - list.offset().top;

      if (topDelta + selected.outerHeight() > list.outerHeight() || topDelta < 0) {
        list.scrollTop(list.scrollTop() + selected.position().top - selected.outerHeight());
      }

      selected.addClass('ui-timepicker-selected');
    }
  }

  function _formatValue(e, origin) {
    if (this.value === '' || origin == 'timepicker') {
      return;
    }

    var self = $(this);

    if (self.is(':focus') && (!e || e.type != 'change')) {
      return;
    }

    var settings = self.data('timepicker-settings');

    var seconds = _time2int(this.value, settings);

    if (seconds === null) {
      self.trigger('timeFormatError');
      return;
    }

    var rangeError = false; // check that the time in within bounds

    if (settings.minTime !== null && settings.maxTime !== null && (seconds < settings.minTime || seconds > settings.maxTime)) {
      rangeError = true;
    } // check that time isn't within disabled time ranges


    $.each(settings.disableTimeRanges, function () {
      if (seconds >= this[0] && seconds < this[1]) {
        rangeError = true;
        return false;
      }
    });

    if (settings.forceRoundTime) {
      var roundSeconds = settings.roundingFunction(seconds, settings);

      if (roundSeconds != seconds) {
        seconds = roundSeconds;
        origin = null;
      }
    }

    var prettyTime = _int2time(seconds, settings);

    if (rangeError) {
      if (_setTimeValue(self, prettyTime, 'error')) {
        self.trigger('timeRangeError');
      }
    } else {
      _setTimeValue(self, prettyTime, origin);
    }
  }

  function _getTimeValue(self) {
    if (self.is('input')) {
      return self.val();
    } else {
      // use the element's data attributes to store values
      return self.data('ui-timepicker-value');
    }
  }

  function _setTimeValue(self, value, source) {
    if (self.is('input')) {
      self.val(value);
      var settings = self.data('timepicker-settings');

      if (settings.useSelect && source != 'select' && source != 'initial') {
        self.data('timepicker-list').val(_roundAndFormatTime(_time2int(value), settings));
      }
    }

    if (self.data('ui-timepicker-value') != value) {
      self.data('ui-timepicker-value', value);

      if (source == 'select') {
        self.trigger('selectTime').trigger('changeTime').trigger('change', 'timepicker');
      } else if (['error', 'initial'].indexOf(source) == -1) {
        self.trigger('changeTime');
      }

      return true;
    } else {
      self.trigger('selectTime');
      return false;
    }
  }
  /*
   *  Filter freeform input
   */


  function _disableTextInputHandler(e) {
    switch (e.keyCode) {
      case 13: // return

      case 9:
        //tab
        return;

      default:
        e.preventDefault();
    }
  }
  /*
   *  Keyboard navigation via arrow keys
   */


  function _keydownhandler(e) {
    var self = $(this);
    var list = self.data('timepicker-list');

    if (!list || !_isVisible(list)) {
      if (e.keyCode == 40) {
        // show the list!
        methods.show.call(self.get(0));
        list = self.data('timepicker-list');

        if (!_hideKeyboard(self)) {
          self.focus();
        }
      } else {
        return true;
      }
    }

    switch (e.keyCode) {
      case 13:
        // return
        if (_selectValue(self)) {
          _formatValue.call(self.get(0), {
            'type': 'change'
          });

          methods.hide.apply(this);
        }

        e.preventDefault();
        return false;

      case 38:
        // up
        var selected = list.find('.ui-timepicker-selected');

        if (!selected.length) {
          list.find('li').each(function (i, obj) {
            if ($(obj).position().top > 0) {
              selected = $(obj);
              return false;
            }
          });
          selected.addClass('ui-timepicker-selected');
        } else if (!selected.is(':first-child')) {
          selected.removeClass('ui-timepicker-selected');
          selected.prev().addClass('ui-timepicker-selected');

          if (selected.prev().position().top < selected.outerHeight()) {
            list.scrollTop(list.scrollTop() - selected.outerHeight());
          }
        }

        return false;

      case 40:
        // down
        selected = list.find('.ui-timepicker-selected');

        if (selected.length === 0) {
          list.find('li').each(function (i, obj) {
            if ($(obj).position().top > 0) {
              selected = $(obj);
              return false;
            }
          });
          selected.addClass('ui-timepicker-selected');
        } else if (!selected.is(':last-child')) {
          selected.removeClass('ui-timepicker-selected');
          selected.next().addClass('ui-timepicker-selected');

          if (selected.next().position().top + 2 * selected.outerHeight() > list.outerHeight()) {
            list.scrollTop(list.scrollTop() + selected.outerHeight());
          }
        }

        return false;

      case 27:
        // escape
        list.find('li').removeClass('ui-timepicker-selected');
        methods.hide();
        break;

      case 9:
        //tab
        methods.hide();
        break;

      default:
        return true;
    }
  }
  /*
   *	Time typeahead
   */


  function _keyuphandler(e) {
    var self = $(this);
    var list = self.data('timepicker-list');
    var settings = self.data('timepicker-settings');

    if (!list || !_isVisible(list) || settings.disableTextInput) {
      return true;
    }

    switch (e.keyCode) {
      case 96: // numpad numerals

      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 48: // numerals

      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 65: // a

      case 77: // m

      case 80: // p

      case 186: // colon

      case 8: // backspace

      case 46:
        // delete
        if (settings.typeaheadHighlight) {
          _setSelected(self, list);
        } else {
          list.hide();
        }

        break;
    }
  }

  function _selectValue(self) {
    var settings = self.data('timepicker-settings');
    var list = self.data('timepicker-list');
    var timeValue = null;
    var cursor = list.find('.ui-timepicker-selected');

    if (cursor.hasClass('ui-timepicker-disabled')) {
      return false;
    }

    if (cursor.length) {
      // selected value found
      timeValue = cursor.data('time');
    }

    if (timeValue !== null) {
      if (typeof timeValue != 'string') {
        timeValue = _int2time(timeValue, settings);
      }

      _setTimeValue(self, timeValue, 'select');
    }

    return true;
  }

  function _int2duration(seconds, step) {
    seconds = Math.abs(seconds);
    var minutes = Math.round(seconds / 60),
        duration = [],
        hours,
        mins;

    if (minutes < 60) {
      // Only show (x mins) under 1 hour
      duration = [minutes, _lang.mins];
    } else {
      hours = Math.floor(minutes / 60);
      mins = minutes % 60; // Show decimal notation (eg: 1.5 hrs) for 30 minute steps

      if (step == 30 && mins == 30) {
        hours += _lang.decimal + 5;
      }

      duration.push(hours);
      duration.push(hours == 1 ? _lang.hr : _lang.hrs); // Show remainder minutes notation (eg: 1 hr 15 mins) for non-30 minute steps
      // and only if there are remainder minutes to show

      if (step != 30 && mins) {
        duration.push(mins);
        duration.push(_lang.mins);
      }
    }

    return duration.join(' ');
  }

  function _int2time(timeInt, settings) {
    if (typeof timeInt != 'number') {
      return null;
    }

    var seconds = parseInt(timeInt % 60),
        minutes = parseInt(timeInt / 60 % 60),
        hours = parseInt(timeInt / (60 * 60) % 24);
    var time = new Date(1970, 0, 2, hours, minutes, seconds, 0);

    if (isNaN(time.getTime())) {
      return null;
    }

    if ($.type(settings.timeFormat) === "function") {
      return settings.timeFormat(time);
    }

    var output = '';
    var hour, code;

    for (var i = 0; i < settings.timeFormat.length; i++) {
      code = settings.timeFormat.charAt(i);

      switch (code) {
        case 'a':
          output += time.getHours() > 11 ? _lang.pm : _lang.am;
          break;

        case 'A':
          output += time.getHours() > 11 ? _lang.PM : _lang.AM;
          break;

        case 'g':
          hour = time.getHours() % 12;
          output += hour === 0 ? '12' : hour;
          break;

        case 'G':
          hour = time.getHours();
          if (timeInt === _ONE_DAY) hour = settings.show2400 ? 24 : 0;
          output += hour;
          break;

        case 'h':
          hour = time.getHours() % 12;

          if (hour !== 0 && hour < 10) {
            hour = '0' + hour;
          }

          output += hour === 0 ? '12' : hour;
          break;

        case 'H':
          hour = time.getHours();
          if (timeInt === _ONE_DAY) hour = settings.show2400 ? 24 : 0;
          output += hour > 9 ? hour : '0' + hour;
          break;

        case 'i':
          var minutes = time.getMinutes();
          output += minutes > 9 ? minutes : '0' + minutes;
          break;

        case 's':
          seconds = time.getSeconds();
          output += seconds > 9 ? seconds : '0' + seconds;
          break;

        case '\\':
          // escape character; add the next character and skip ahead
          i++;
          output += settings.timeFormat.charAt(i);
          break;

        default:
          output += code;
      }
    }

    return output;
  }

  function _time2int(timeString, settings) {
    if (timeString === '' || timeString === null) return null;

    if (_typeof(timeString) == 'object') {
      return timeString.getHours() * 3600 + timeString.getMinutes() * 60 + timeString.getSeconds();
    }

    if (typeof timeString != 'string') {
      return timeString;
    }

    timeString = timeString.toLowerCase().replace(/[\s\.]/g, ''); // if the last character is an "a" or "p", add the "m"

    if (timeString.slice(-1) == 'a' || timeString.slice(-1) == 'p') {
      timeString += 'm';
    }

    var ampmRegex = '(' + _lang.am.replace('.', '') + '|' + _lang.pm.replace('.', '') + '|' + _lang.AM.replace('.', '') + '|' + _lang.PM.replace('.', '') + ')?'; // try to parse time input

    var pattern = new RegExp('^' + ampmRegex + '([0-9]?[0-9])\\W?([0-5][0-9])?\\W?([0-5][0-9])?' + ampmRegex + '$');
    var time = timeString.match(pattern);

    if (!time) {
      return null;
    }

    var hour = parseInt(time[2] * 1, 10);

    if (hour > 24) {
      if (settings && settings.wrapHours === false) {
        return null;
      } else {
        hour = hour % 24;
      }
    }

    var ampm = time[1] || time[5];
    var hours = hour;

    if (hour <= 12 && ampm) {
      var isPm = ampm == _lang.pm || ampm == _lang.PM;

      if (hour == 12) {
        hours = isPm ? 12 : 0;
      } else {
        hours = hour + (isPm ? 12 : 0);
      }
    }

    var minutes = time[3] * 1 || 0;
    var seconds = time[4] * 1 || 0;
    var timeInt = hours * 3600 + minutes * 60 + seconds; // if no am/pm provided, intelligently guess based on the scrollDefault

    if (hour < 12 && !ampm && settings && settings._twelveHourTime && settings.scrollDefault) {
      var delta = timeInt - settings.scrollDefault();

      if (delta < 0 && delta >= _ONE_DAY / -2) {
        timeInt = (timeInt + _ONE_DAY / 2) % _ONE_DAY;
      }
    }

    return timeInt;
  }

  function _pad2(n) {
    return ("0" + n).slice(-2);
  } // Plugin entry


  $.fn.timepicker = function (method) {
    if (!this.length) return this;

    if (methods[method]) {
      // check if this element is a timepicker
      if (!this.hasClass('ui-timepicker-input')) {
        return this;
      }

      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (_typeof(method) === "object" || !method) {
      return methods.init.apply(this, arguments);
    } else {
      $.error("Method " + method + " does not exist on jQuery.timepicker");
    }
  }; // Global defaults


  $.fn.timepicker.defaults = {
    appendTo: 'body',
    className: null,
    closeOnWindowScroll: false,
    disableTextInput: false,
    disableTimeRanges: [],
    disableTouchKeyboard: false,
    durationTime: null,
    forceRoundTime: false,
    maxTime: null,
    minTime: null,
    noneOption: false,
    orientation: 'l',
    roundingFunction: function roundingFunction(seconds, settings) {
      if (seconds === null) {
        return null;
      } else if (typeof settings.step !== "number") {
        // TODO: nearest fit irregular steps
        return seconds;
      } else {
        var offset = seconds % (settings.step * 60); // step is in minutes

        if (offset >= settings.step * 30) {
          // if offset is larger than a half step, round up
          seconds += settings.step * 60 - offset;
        } else {
          // round down
          seconds -= offset;
        }

        if (seconds == _ONE_DAY && settings.show2400) {
          return seconds;
        }

        return seconds % _ONE_DAY;
      }
    },
    scrollDefault: null,
    selectOnBlur: false,
    show2400: false,
    showDuration: false,
    showOn: ['click', 'focus'],
    showOnFocus: true,
    step: 30,
    stopScrollPropagation: false,
    timeFormat: 'g:ia',
    typeaheadHighlight: true,
    useSelect: false,
    wrapHours: true
  };
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)(module)))

/***/ }),
/* 448 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initGalleries;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__fancyapps_fancybox__ = __webpack_require__(449);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__fancyapps_fancybox___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__fancyapps_fancybox__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers__ = __webpack_require__(8);



function initGalleries() {
  __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.fancybox.defaults.i18n.fr = {
    CLOSE: 'Fermer',
    NEXT: 'Suivant',
    PREV: 'Précédent',
    ERROR: 'Le contenu demandé ne peut être chargé. <br/> Veuillez réessayer plus tard.',
    PLAY_START: 'Démarrer le diaporama',
    PLAY_STOP: 'Pause',
    FULL_SCREEN: 'Plein écran',
    THUMBS: 'Vignettes',
    DOWNLOAD: 'Télécharger',
    SHARE: 'Partager',
    ZOOM: 'Zoom'
  };
  __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.fancybox.defaults.lang = 'fr';
  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-fancybox]').fancybox({
    animationEffect: 'zoom',
    autoFocus: true,
    backFocus: true,
    trapFocus: true,
    clickOutside: 'close',
    buttons: [// 'zoom',
    // 'share',
    // 'slideShow',
    // 'fullScreen',
    // 'download',
    'thumbs', 'close'],
    btnTpl: {
      arrowLeft: '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}"><div><svg role="img" aria-label="{{PREV}}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>{{PREV}}</title><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div></button>',
      arrowRight: '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}"><div><svg role="img" aria-label="{{NEXT}}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>{{NEXT}}</title><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div></button>',
      thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}"><svg role="img" aria-label="{{THUMBS}}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>{{THUMBS}}</title><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg></button>',
      close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}"><svg role="img" aria-label="{{CLOSE}}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>{{CLOSE}}</title><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg></button>'
    },
    afterLoad: function afterLoad(instance, current) {
      var alt = current.opts.alt;
      setTimeout(function () {
        // Add custom attribute to iframe type fancybox
        if (typeof current.$iframe !== 'undefined' && instance.$trigger[0] && instance.$trigger[0].hasAttribute('data-title')) {
          current.$iframe[0].setAttribute('title', instance.$trigger[0].getAttribute('data-title'));
        }

        if (current.$image && current.$image.attr) {
          if (alt) {
            current.$image.attr('alt', alt);
          } else {
            current.$image.attr('alt', '');
          }
        }
      }, 500);
    }
  });
  var galleryList = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.gallery__list');
  galleryList.each(function (index, item) {
    var galleryListItemsCount = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(item).children().length;
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(item).attr('data-items', galleryListItemsCount);
  });
}

/***/ }),
/* 449 */
/***/ (function(module, exports) {

// ==================================================
// fancyBox v3.5.6
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2018 fancyApps
//
// ==================================================
(function (window, document, $, undefined) {
  "use strict";

  window.console = window.console || {
    info: function (stuff) {}
  }; // If there's no jQuery, fancyBox can't work
  // =========================================

  if (!$) {
    return;
  } // Check if fancyBox is already initialized
  // ========================================


  if ($.fn.fancybox) {
    console.info("fancyBox already initialized");
    return;
  } // Private default settings
  // ========================


  var defaults = {
    // Close existing modals
    // Set this to false if you do not need to stack multiple instances
    closeExisting: false,
    // Enable infinite gallery navigation
    loop: false,
    // Horizontal space between slides
    gutter: 50,
    // Enable keyboard navigation
    keyboard: true,
    // Should allow caption to overlap the content
    preventCaptionOverlap: true,
    // Should display navigation arrows at the screen edges
    arrows: true,
    // Should display counter at the top left corner
    infobar: true,
    // Should display close button (using `btnTpl.smallBtn` template) over the content
    // Can be true, false, "auto"
    // If "auto" - will be automatically enabled for "html", "inline" or "ajax" items
    smallBtn: "auto",
    // Should display toolbar (buttons at the top)
    // Can be true, false, "auto"
    // If "auto" - will be automatically hidden if "smallBtn" is enabled
    toolbar: "auto",
    // What buttons should appear in the top right corner.
    // Buttons will be created using templates from `btnTpl` option
    // and they will be placed into toolbar (class="fancybox-toolbar"` element)
    buttons: ["zoom", //"share",
    "slideShow", //"fullScreen",
    //"download",
    "thumbs", "close"],
    // Detect "idle" time in seconds
    idleTime: 3,
    // Disable right-click and use simple image protection for images
    protect: false,
    // Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc
    modal: false,
    image: {
      // Wait for images to load before displaying
      //   true  - wait for image to load and then display;
      //   false - display thumbnail and load the full-sized image over top,
      //           requires predefined image dimensions (`data-width` and `data-height` attributes)
      preload: false
    },
    ajax: {
      // Object containing settings for ajax request
      settings: {
        // This helps to indicate that request comes from the modal
        // Feel free to change naming
        data: {
          fancybox: true
        }
      }
    },
    iframe: {
      // Iframe template
      tpl: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',
      // Preload iframe before displaying it
      // This allows to calculate iframe content width and height
      // (note: Due to "Same Origin Policy", you can't get cross domain data).
      preload: true,
      // Custom CSS styling for iframe wrapping element
      // You can use this to set custom iframe dimensions
      css: {},
      // Iframe tag attributes
      attr: {
        scrolling: "auto"
      }
    },
    // For HTML5 video only
    video: {
      tpl: '<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}">' + '<source src="{{src}}" type="{{format}}" />' + 'Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!' + "</video>",
      format: "",
      // custom video format
      autoStart: true
    },
    // Default content type if cannot be detected automatically
    defaultType: "image",
    // Open/close animation type
    // Possible values:
    //   false            - disable
    //   "zoom"           - zoom images from/to thumbnail
    //   "fade"
    //   "zoom-in-out"
    //
    animationEffect: "zoom",
    // Duration in ms for open/close animation
    animationDuration: 366,
    // Should image change opacity while zooming
    // If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios
    zoomOpacity: "auto",
    // Transition effect between slides
    //
    // Possible values:
    //   false            - disable
    //   "fade'
    //   "slide'
    //   "circular'
    //   "tube'
    //   "zoom-in-out'
    //   "rotate'
    //
    transitionEffect: "fade",
    // Duration in ms for transition animation
    transitionDuration: 366,
    // Custom CSS class for slide element
    slideClass: "",
    // Custom CSS class for layout
    baseClass: "",
    // Base template for layout
    baseTpl: '<div class="fancybox-container" role="dialog" tabindex="-1">' + '<div class="fancybox-bg"></div>' + '<div class="fancybox-inner">' + '<div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div>' + '<div class="fancybox-toolbar">{{buttons}}</div>' + '<div class="fancybox-navigation">{{arrows}}</div>' + '<div class="fancybox-stage"></div>' + '<div class="fancybox-caption"><div class="fancybox-caption__body"></div></div>' + "</div>" + "</div>",
    // Loading indicator template
    spinnerTpl: '<div class="fancybox-loading"></div>',
    // Error message template
    errorTpl: '<div class="fancybox-error"><p>{{ERROR}}</p></div>',
    btnTpl: {
      download: '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg>' + "</a>",
      zoom: '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg>' + "</button>",
      close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg>' + "</button>",
      // Arrows
      arrowLeft: '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}">' + '<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div>' + "</button>",
      arrowRight: '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}">' + '<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div>' + "</button>",
      // This small close button will be appended to your html/inline/ajax content by default,
      // if "smallBtn" option is not set to false
      smallBtn: '<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}">' + '<svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg>' + "</button>"
    },
    // Container is injected into this element
    parentEl: "body",
    // Hide browser vertical scrollbars; use at your own risk
    hideScrollbar: true,
    // Focus handling
    // ==============
    // Try to focus on the first focusable element after opening
    autoFocus: true,
    // Put focus back to active element after closing
    backFocus: true,
    // Do not let user to focus on element outside modal content
    trapFocus: true,
    // Module specific options
    // =======================
    fullScreen: {
      autoStart: false
    },
    // Set `touch: false` to disable panning/swiping
    touch: {
      vertical: true,
      // Allow to drag content vertically
      momentum: true // Continue movement after releasing mouse/touch when panning

    },
    // Hash value when initializing manually,
    // set `false` to disable hash change
    hash: null,
    // Customize or add new media types
    // Example:

    /*
      media : {
        youtube : {
          params : {
            autoplay : 0
          }
        }
      }
    */
    media: {},
    slideShow: {
      autoStart: false,
      speed: 3000
    },
    thumbs: {
      autoStart: false,
      // Display thumbnails on opening
      hideOnClose: true,
      // Hide thumbnail grid when closing animation starts
      parentEl: ".fancybox-container",
      // Container is injected into this element
      axis: "y" // Vertical (y) or horizontal (x) scrolling

    },
    // Use mousewheel to navigate gallery
    // If 'auto' - enabled for images only
    wheel: "auto",
    // Callbacks
    //==========
    // See Documentation/API/Events for more information
    // Example:

    /*
      afterShow: function( instance, current ) {
        console.info( 'Clicked element:' );
        console.info( current.opts.$orig );
      }
    */
    onInit: $.noop,
    // When instance has been initialized
    beforeLoad: $.noop,
    // Before the content of a slide is being loaded
    afterLoad: $.noop,
    // When the content of a slide is done loading
    beforeShow: $.noop,
    // Before open animation starts
    afterShow: $.noop,
    // When content is done loading and animating
    beforeClose: $.noop,
    // Before the instance attempts to close. Return false to cancel the close.
    afterClose: $.noop,
    // After instance has been closed
    onActivate: $.noop,
    // When instance is brought to front
    onDeactivate: $.noop,
    // When other instance has been activated
    // Interaction
    // ===========
    // Use options below to customize taken action when user clicks or double clicks on the fancyBox area,
    // each option can be string or method that returns value.
    //
    // Possible values:
    //   "close"           - close instance
    //   "next"            - move to next gallery item
    //   "nextOrClose"     - move to next gallery item or close if gallery has only one item
    //   "toggleControls"  - show/hide controls
    //   "zoom"            - zoom image (if loaded)
    //   false             - do nothing
    // Clicked on the content
    clickContent: function (current, event) {
      return current.type === "image" ? "zoom" : false;
    },
    // Clicked on the slide
    clickSlide: "close",
    // Clicked on the background (backdrop) element;
    // if you have not changed the layout, then most likely you need to use `clickSlide` option
    clickOutside: "close",
    // Same as previous two, but for double click
    dblclickContent: false,
    dblclickSlide: false,
    dblclickOutside: false,
    // Custom options when mobile device is detected
    // =============================================
    mobile: {
      preventCaptionOverlap: false,
      idleTime: false,
      clickContent: function (current, event) {
        return current.type === "image" ? "toggleControls" : false;
      },
      clickSlide: function (current, event) {
        return current.type === "image" ? "toggleControls" : "close";
      },
      dblclickContent: function (current, event) {
        return current.type === "image" ? "zoom" : false;
      },
      dblclickSlide: function (current, event) {
        return current.type === "image" ? "zoom" : false;
      }
    },
    // Internationalization
    // ====================
    lang: "en",
    i18n: {
      en: {
        CLOSE: "Close",
        NEXT: "Next",
        PREV: "Previous",
        ERROR: "The requested content cannot be loaded. <br/> Please try again later.",
        PLAY_START: "Start slideshow",
        PLAY_STOP: "Pause slideshow",
        FULL_SCREEN: "Full screen",
        THUMBS: "Thumbnails",
        DOWNLOAD: "Download",
        SHARE: "Share",
        ZOOM: "Zoom"
      },
      de: {
        CLOSE: "Schlie&szlig;en",
        NEXT: "Weiter",
        PREV: "Zur&uuml;ck",
        ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",
        PLAY_START: "Diaschau starten",
        PLAY_STOP: "Diaschau beenden",
        FULL_SCREEN: "Vollbild",
        THUMBS: "Vorschaubilder",
        DOWNLOAD: "Herunterladen",
        SHARE: "Teilen",
        ZOOM: "Vergr&ouml;&szlig;ern"
      }
    }
  }; // Few useful variables and methods
  // ================================

  var $W = $(window);
  var $D = $(document);
  var called = 0; // Check if an object is a jQuery object and not a native JavaScript object
  // ========================================================================

  var isQuery = function (obj) {
    return obj && obj.hasOwnProperty && obj instanceof $;
  }; // Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"
  // ===============================================================================


  var requestAFrame = function () {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || // if all else fails, use setTimeout
    function (callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  }();

  var cancelAFrame = function () {
    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {
      window.clearTimeout(id);
    };
  }(); // Detect the supported transition-end event property name
  // =======================================================


  var transitionEnd = function () {
    var el = document.createElement("fakeelement"),
        t;
    var transitions = {
      transition: "transitionend",
      OTransition: "oTransitionEnd",
      MozTransition: "transitionend",
      WebkitTransition: "webkitTransitionEnd"
    };

    for (t in transitions) {
      if (el.style[t] !== undefined) {
        return transitions[t];
      }
    }

    return "transitionend";
  }(); // Force redraw on an element.
  // This helps in cases where the browser doesn't redraw an updated element properly
  // ================================================================================


  var forceRedraw = function ($el) {
    return $el && $el.length && $el[0].offsetHeight;
  }; // Exclude array (`buttons`) options from deep merging
  // ===================================================


  var mergeOpts = function (opts1, opts2) {
    var rez = $.extend(true, {}, opts1, opts2);
    $.each(opts2, function (key, value) {
      if ($.isArray(value)) {
        rez[key] = value;
      }
    });
    return rez;
  }; // How much of an element is visible in viewport
  // =============================================


  var inViewport = function (elem) {
    var elemCenter, rez;

    if (!elem || elem.ownerDocument !== document) {
      return false;
    }

    $(".fancybox-container").css("pointer-events", "none");
    elemCenter = {
      x: elem.getBoundingClientRect().left + elem.offsetWidth / 2,
      y: elem.getBoundingClientRect().top + elem.offsetHeight / 2
    };
    rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem;
    $(".fancybox-container").css("pointer-events", "");
    return rez;
  }; // Class definition
  // ================


  var FancyBox = function (content, opts, index) {
    var self = this;
    self.opts = mergeOpts({
      index: index
    }, $.fancybox.defaults);

    if ($.isPlainObject(opts)) {
      self.opts = mergeOpts(self.opts, opts);
    }

    if ($.fancybox.isMobile) {
      self.opts = mergeOpts(self.opts, self.opts.mobile);
    }

    self.id = self.opts.id || ++called;
    self.currIndex = parseInt(self.opts.index, 10) || 0;
    self.prevIndex = null;
    self.prevPos = null;
    self.currPos = 0;
    self.firstRun = true; // All group items

    self.group = []; // Existing slides (for current, next and previous gallery items)

    self.slides = {}; // Create group elements

    self.addContent(content);

    if (!self.group.length) {
      return;
    }

    self.init();
  };

  $.extend(FancyBox.prototype, {
    // Create DOM structure
    // ====================
    init: function () {
      var self = this,
          firstItem = self.group[self.currIndex],
          firstItemOpts = firstItem.opts,
          $container,
          buttonStr;

      if (firstItemOpts.closeExisting) {
        $.fancybox.close(true);
      } // Hide scrollbars
      // ===============


      $("body").addClass("fancybox-active");

      if (!$.fancybox.getInstance() && firstItemOpts.hideScrollbar !== false && !$.fancybox.isMobile && document.body.scrollHeight > window.innerHeight) {
        $("head").append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:' + (window.innerWidth - document.documentElement.clientWidth) + "px;}</style>");
        $("body").addClass("compensate-for-scrollbar");
      } // Build html markup and set references
      // ====================================
      // Build html code for buttons and insert into main template


      buttonStr = "";
      $.each(firstItemOpts.buttons, function (index, value) {
        buttonStr += firstItemOpts.btnTpl[value] || "";
      }); // Create markup from base template, it will be initially hidden to
      // avoid unnecessary work like painting while initializing is not complete

      $container = $(self.translate(self, firstItemOpts.baseTpl.replace("{{buttons}}", buttonStr).replace("{{arrows}}", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight))).attr("id", "fancybox-container-" + self.id).addClass(firstItemOpts.baseClass).data("FancyBox", self).appendTo(firstItemOpts.parentEl); // Create object holding references to jQuery wrapped nodes

      self.$refs = {
        container: $container
      };
      ["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function (item) {
        self.$refs[item] = $container.find(".fancybox-" + item);
      });
      self.trigger("onInit"); // Enable events, deactive previous instances

      self.activate(); // Build slides, load and reveal content

      self.jumpTo(self.currIndex);
    },
    // Simple i18n support - replaces object keys found in template
    // with corresponding values
    // ============================================================
    translate: function (obj, str) {
      var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en;
      return str.replace(/\{\{(\w+)\}\}/g, function (match, n) {
        return arr[n] === undefined ? match : arr[n];
      });
    },
    // Populate current group with fresh content
    // Check if each object has valid type and content
    // ===============================================
    addContent: function (content) {
      var self = this,
          items = $.makeArray(content),
          thumbs;
      $.each(items, function (i, item) {
        var obj = {},
            opts = {},
            $item,
            type,
            found,
            src,
            srcParts; // Step 1 - Make sure we have an object
        // ====================================

        if ($.isPlainObject(item)) {
          // We probably have manual usage here, something like
          // $.fancybox.open( [ { src : "image.jpg", type : "image" } ] )
          obj = item;
          opts = item.opts || item;
        } else if ($.type(item) === "object" && $(item).length) {
          // Here we probably have jQuery collection returned by some selector
          $item = $(item); // Support attributes like `data-options='{"touch" : false}'` and `data-touch='false'`

          opts = $item.data() || {};
          opts = $.extend(true, {}, opts, opts.options); // Here we store clicked element

          opts.$orig = $item;
          obj.src = self.opts.src || opts.src || $item.attr("href"); // Assume that simple syntax is used, for example:
          //   `$.fancybox.open( $("#test"), {} );`

          if (!obj.type && !obj.src) {
            obj.type = "inline";
            obj.src = item;
          }
        } else {
          // Assume we have a simple html code, for example:
          //   $.fancybox.open( '<div><h1>Hi!</h1></div>' );
          obj = {
            type: "html",
            src: item + ""
          };
        } // Each gallery object has full collection of options


        obj.opts = $.extend(true, {}, self.opts, opts); // Do not merge buttons array

        if ($.isArray(opts.buttons)) {
          obj.opts.buttons = opts.buttons;
        }

        if ($.fancybox.isMobile && obj.opts.mobile) {
          obj.opts = mergeOpts(obj.opts, obj.opts.mobile);
        } // Step 2 - Make sure we have content type, if not - try to guess
        // ==============================================================


        type = obj.type || obj.opts.type;
        src = obj.src || "";

        if (!type && src) {
          if (found = src.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) {
            type = "video";

            if (!obj.opts.video.format) {
              obj.opts.video.format = "video/" + (found[1] === "ogv" ? "ogg" : found[1]);
            }
          } else if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
            type = "image";
          } else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
            type = "iframe";
            obj = $.extend(true, obj, {
              contentType: "pdf",
              opts: {
                iframe: {
                  preload: false
                }
              }
            });
          } else if (src.charAt(0) === "#") {
            type = "inline";
          }
        }

        if (type) {
          obj.type = type;
        } else {
          self.trigger("objectNeedsType", obj);
        }

        if (!obj.contentType) {
          obj.contentType = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1 ? "html" : obj.type;
        } // Step 3 - Some adjustments
        // =========================


        obj.index = self.group.length;

        if (obj.opts.smallBtn == "auto") {
          obj.opts.smallBtn = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1;
        }

        if (obj.opts.toolbar === "auto") {
          obj.opts.toolbar = !obj.opts.smallBtn;
        } // Find thumbnail image, check if exists and if is in the viewport


        obj.$thumb = obj.opts.$thumb || null;

        if (obj.opts.$trigger && obj.index === self.opts.index) {
          obj.$thumb = obj.opts.$trigger.find("img:first");

          if (obj.$thumb.length) {
            obj.opts.$orig = obj.opts.$trigger;
          }
        }

        if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) {
          obj.$thumb = obj.opts.$orig.find("img:first");
        }

        if (obj.$thumb && !obj.$thumb.length) {
          obj.$thumb = null;
        }

        obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null); // "caption" is a "special" option, it can be used to customize caption per gallery item

        if ($.type(obj.opts.caption) === "function") {
          obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
        }

        if ($.type(self.opts.caption) === "function") {
          obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
        } // Make sure we have caption as a string or jQuery object


        if (!(obj.opts.caption instanceof $)) {
          obj.opts.caption = obj.opts.caption === undefined ? "" : obj.opts.caption + "";
        } // Check if url contains "filter" used to filter the content
        // Example: "ajax.html #something"


        if (obj.type === "ajax") {
          srcParts = src.split(/\s+/, 2);

          if (srcParts.length > 1) {
            obj.src = srcParts.shift();
            obj.opts.filter = srcParts.shift();
          }
        } // Hide all buttons and disable interactivity for modal items


        if (obj.opts.modal) {
          obj.opts = $.extend(true, obj.opts, {
            trapFocus: true,
            // Remove buttons
            infobar: 0,
            toolbar: 0,
            smallBtn: 0,
            // Disable keyboard navigation
            keyboard: 0,
            // Disable some modules
            slideShow: 0,
            fullScreen: 0,
            thumbs: 0,
            touch: 0,
            // Disable click event handlers
            clickContent: false,
            clickSlide: false,
            clickOutside: false,
            dblclickContent: false,
            dblclickSlide: false,
            dblclickOutside: false
          });
        } // Step 4 - Add processed object to group
        // ======================================


        self.group.push(obj);
      }); // Update controls if gallery is already opened

      if (Object.keys(self.slides).length) {
        self.updateControls(); // Update thumbnails, if needed

        thumbs = self.Thumbs;

        if (thumbs && thumbs.isActive) {
          thumbs.create();
          thumbs.focus();
        }
      }
    },
    // Attach an event handler functions for:
    //   - navigation buttons
    //   - browser scrolling, resizing;
    //   - focusing
    //   - keyboard
    //   - detecting inactivity
    // ======================================
    addEvents: function () {
      var self = this;
      self.removeEvents(); // Make navigation elements clickable
      // ==================================

      self.$refs.container.on("click.fb-close", "[data-fancybox-close]", function (e) {
        e.stopPropagation();
        e.preventDefault();
        self.close(e);
      }).on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function (e) {
        e.stopPropagation();
        e.preventDefault();
        self.previous();
      }).on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function (e) {
        e.stopPropagation();
        e.preventDefault();
        self.next();
      }).on("click.fb", "[data-fancybox-zoom]", function (e) {
        // Click handler for zoom button
        self[self.isScaledDown() ? "scaleToActual" : "scaleToFit"]();
      }); // Handle page scrolling and browser resizing
      // ==========================================

      $W.on("orientationchange.fb resize.fb", function (e) {
        if (e && e.originalEvent && e.originalEvent.type === "resize") {
          if (self.requestId) {
            cancelAFrame(self.requestId);
          }

          self.requestId = requestAFrame(function () {
            self.update(e);
          });
        } else {
          if (self.current && self.current.type === "iframe") {
            self.$refs.stage.hide();
          }

          setTimeout(function () {
            self.$refs.stage.show();
            self.update(e);
          }, $.fancybox.isMobile ? 600 : 250);
        }
      });
      $D.on("keydown.fb", function (e) {
        var instance = $.fancybox ? $.fancybox.getInstance() : null,
            current = instance.current,
            keycode = e.keyCode || e.which; // Trap keyboard focus inside of the modal
        // =======================================

        if (keycode == 9) {
          if (current.opts.trapFocus) {
            self.focus(e);
          }

          return;
        } // Enable keyboard navigation
        // ==========================


        if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is("input,textarea,video,audio")) {
          return;
        } // Backspace and Esc keys


        if (keycode === 8 || keycode === 27) {
          e.preventDefault();
          self.close(e);
          return;
        } // Left arrow and Up arrow


        if (keycode === 37 || keycode === 38) {
          e.preventDefault();
          self.previous();
          return;
        } // Righ arrow and Down arrow


        if (keycode === 39 || keycode === 40) {
          e.preventDefault();
          self.next();
          return;
        }

        self.trigger("afterKeydown", e, keycode);
      }); // Hide controls after some inactivity period

      if (self.group[self.currIndex].opts.idleTime) {
        self.idleSecondsCounter = 0;
        $D.on("mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle", function (e) {
          self.idleSecondsCounter = 0;

          if (self.isIdle) {
            self.showControls();
          }

          self.isIdle = false;
        });
        self.idleInterval = window.setInterval(function () {
          self.idleSecondsCounter++;

          if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {
            self.isIdle = true;
            self.idleSecondsCounter = 0;
            self.hideControls();
          }
        }, 1000);
      }
    },
    // Remove events added by the core
    // ===============================
    removeEvents: function () {
      var self = this;
      $W.off("orientationchange.fb resize.fb");
      $D.off("keydown.fb .fb-idle");
      this.$refs.container.off(".fb-close .fb-prev .fb-next");

      if (self.idleInterval) {
        window.clearInterval(self.idleInterval);
        self.idleInterval = null;
      }
    },
    // Change to previous gallery item
    // ===============================
    previous: function (duration) {
      return this.jumpTo(this.currPos - 1, duration);
    },
    // Change to next gallery item
    // ===========================
    next: function (duration) {
      return this.jumpTo(this.currPos + 1, duration);
    },
    // Switch to selected gallery item
    // ===============================
    jumpTo: function (pos, duration) {
      var self = this,
          groupLen = self.group.length,
          firstRun,
          isMoved,
          loop,
          current,
          previous,
          slidePos,
          stagePos,
          prop,
          diff;

      if (self.isDragging || self.isClosing || self.isAnimating && self.firstRun) {
        return;
      } // Should loop?


      pos = parseInt(pos, 10);
      loop = self.current ? self.current.opts.loop : self.opts.loop;

      if (!loop && (pos < 0 || pos >= groupLen)) {
        return false;
      } // Check if opening for the first time; this helps to speed things up


      firstRun = self.firstRun = !Object.keys(self.slides).length; // Create slides

      previous = self.current;
      self.prevIndex = self.currIndex;
      self.prevPos = self.currPos;
      current = self.createSlide(pos);

      if (groupLen > 1) {
        if (loop || current.index < groupLen - 1) {
          self.createSlide(pos + 1);
        }

        if (loop || current.index > 0) {
          self.createSlide(pos - 1);
        }
      }

      self.current = current;
      self.currIndex = current.index;
      self.currPos = current.pos;
      self.trigger("beforeShow", firstRun);
      self.updateControls(); // Validate duration length

      current.forcedDuration = undefined;

      if ($.isNumeric(duration)) {
        current.forcedDuration = duration;
      } else {
        duration = current.opts[firstRun ? "animationDuration" : "transitionDuration"];
      }

      duration = parseInt(duration, 10); // Check if user has swiped the slides or if still animating

      isMoved = self.isMoved(current); // Make sure current slide is visible

      current.$slide.addClass("fancybox-slide--current"); // Fresh start - reveal container, current slide and start loading content

      if (firstRun) {
        if (current.opts.animationEffect && duration) {
          self.$refs.container.css("transition-duration", duration + "ms");
        }

        self.$refs.container.addClass("fancybox-is-open").trigger("focus"); // Attempt to load content into slide
        // This will later call `afterLoad` -> `revealContent`

        self.loadSlide(current);
        self.preload("image");
        return;
      } // Get actual slide/stage positions (before cleaning up)


      slidePos = $.fancybox.getTranslate(previous.$slide);
      stagePos = $.fancybox.getTranslate(self.$refs.stage); // Clean up all slides

      $.each(self.slides, function (index, slide) {
        $.fancybox.stop(slide.$slide, true);
      });

      if (previous.pos !== current.pos) {
        previous.isComplete = false;
      }

      previous.$slide.removeClass("fancybox-slide--complete fancybox-slide--current"); // If slides are out of place, then animate them to correct position

      if (isMoved) {
        // Calculate horizontal swipe distance
        diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter);
        $.each(self.slides, function (index, slide) {
          slide.$slide.removeClass("fancybox-animated").removeClass(function (index, className) {
            return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
          }); // Make sure that each slide is in equal distance
          // This is mostly needed for freshly added slides, because they are not yet positioned

          var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter;
          $.fancybox.setTranslate(slide.$slide, {
            top: 0,
            left: leftPos - stagePos.left + diff
          });

          if (slide.pos !== current.pos) {
            slide.$slide.addClass("fancybox-slide--" + (slide.pos > current.pos ? "next" : "previous"));
          } // Redraw to make sure that transition will start


          forceRedraw(slide.$slide); // Animate the slide

          $.fancybox.animate(slide.$slide, {
            top: 0,
            left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter
          }, duration, function () {
            slide.$slide.css({
              transform: "",
              opacity: ""
            }).removeClass("fancybox-slide--next fancybox-slide--previous");

            if (slide.pos === self.currPos) {
              self.complete();
            }
          });
        });
      } else if (duration && current.opts.transitionEffect) {
        // Set transition effect for previously active slide
        prop = "fancybox-animated fancybox-fx-" + current.opts.transitionEffect;
        previous.$slide.addClass("fancybox-slide--" + (previous.pos > current.pos ? "next" : "previous"));
        $.fancybox.animate(previous.$slide, prop, duration, function () {
          previous.$slide.removeClass(prop).removeClass("fancybox-slide--next fancybox-slide--previous");
        }, false);
      }

      if (current.isLoaded) {
        self.revealContent(current);
      } else {
        self.loadSlide(current);
      }

      self.preload("image");
    },
    // Create new "slide" element
    // These are gallery items  that are actually added to DOM
    // =======================================================
    createSlide: function (pos) {
      var self = this,
          $slide,
          index;
      index = pos % self.group.length;
      index = index < 0 ? self.group.length + index : index;

      if (!self.slides[pos] && self.group[index]) {
        $slide = $('<div class="fancybox-slide"></div>').appendTo(self.$refs.stage);
        self.slides[pos] = $.extend(true, {}, self.group[index], {
          pos: pos,
          $slide: $slide,
          isLoaded: false
        });
        self.updateSlide(self.slides[pos]);
      }

      return self.slides[pos];
    },
    // Scale image to the actual size of the image;
    // x and y values should be relative to the slide
    // ==============================================
    scaleToActual: function (x, y, duration) {
      var self = this,
          current = self.current,
          $content = current.$content,
          canvasWidth = $.fancybox.getTranslate(current.$slide).width,
          canvasHeight = $.fancybox.getTranslate(current.$slide).height,
          newImgWidth = current.width,
          newImgHeight = current.height,
          imgPos,
          posX,
          posY,
          scaleX,
          scaleY;

      if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
        return;
      }

      self.isAnimating = true;
      $.fancybox.stop($content);
      x = x === undefined ? canvasWidth * 0.5 : x;
      y = y === undefined ? canvasHeight * 0.5 : y;
      imgPos = $.fancybox.getTranslate($content);
      imgPos.top -= $.fancybox.getTranslate(current.$slide).top;
      imgPos.left -= $.fancybox.getTranslate(current.$slide).left;
      scaleX = newImgWidth / imgPos.width;
      scaleY = newImgHeight / imgPos.height; // Get center position for original image

      posX = canvasWidth * 0.5 - newImgWidth * 0.5;
      posY = canvasHeight * 0.5 - newImgHeight * 0.5; // Make sure image does not move away from edges

      if (newImgWidth > canvasWidth) {
        posX = imgPos.left * scaleX - (x * scaleX - x);

        if (posX > 0) {
          posX = 0;
        }

        if (posX < canvasWidth - newImgWidth) {
          posX = canvasWidth - newImgWidth;
        }
      }

      if (newImgHeight > canvasHeight) {
        posY = imgPos.top * scaleY - (y * scaleY - y);

        if (posY > 0) {
          posY = 0;
        }

        if (posY < canvasHeight - newImgHeight) {
          posY = canvasHeight - newImgHeight;
        }
      }

      self.updateCursor(newImgWidth, newImgHeight);
      $.fancybox.animate($content, {
        top: posY,
        left: posX,
        scaleX: scaleX,
        scaleY: scaleY
      }, duration || 366, function () {
        self.isAnimating = false;
      }); // Stop slideshow

      if (self.SlideShow && self.SlideShow.isActive) {
        self.SlideShow.stop();
      }
    },
    // Scale image to fit inside parent element
    // ========================================
    scaleToFit: function (duration) {
      var self = this,
          current = self.current,
          $content = current.$content,
          end;

      if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
        return;
      }

      self.isAnimating = true;
      $.fancybox.stop($content);
      end = self.getFitPos(current);
      self.updateCursor(end.width, end.height);
      $.fancybox.animate($content, {
        top: end.top,
        left: end.left,
        scaleX: end.width / $content.width(),
        scaleY: end.height / $content.height()
      }, duration || 366, function () {
        self.isAnimating = false;
      });
    },
    // Calculate image size to fit inside viewport
    // ===========================================
    getFitPos: function (slide) {
      var self = this,
          $content = slide.$content,
          $slide = slide.$slide,
          width = slide.width || slide.opts.width,
          height = slide.height || slide.opts.height,
          maxWidth,
          maxHeight,
          minRatio,
          aspectRatio,
          rez = {};

      if (!slide.isLoaded || !$content || !$content.length) {
        return false;
      }

      maxWidth = $.fancybox.getTranslate(self.$refs.stage).width;
      maxHeight = $.fancybox.getTranslate(self.$refs.stage).height;
      maxWidth -= parseFloat($slide.css("paddingLeft")) + parseFloat($slide.css("paddingRight")) + parseFloat($content.css("marginLeft")) + parseFloat($content.css("marginRight"));
      maxHeight -= parseFloat($slide.css("paddingTop")) + parseFloat($slide.css("paddingBottom")) + parseFloat($content.css("marginTop")) + parseFloat($content.css("marginBottom"));

      if (!width || !height) {
        width = maxWidth;
        height = maxHeight;
      }

      minRatio = Math.min(1, maxWidth / width, maxHeight / height);
      width = minRatio * width;
      height = minRatio * height; // Adjust width/height to precisely fit into container

      if (width > maxWidth - 0.5) {
        width = maxWidth;
      }

      if (height > maxHeight - 0.5) {
        height = maxHeight;
      }

      if (slide.type === "image") {
        rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css("paddingTop"));
        rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css("paddingLeft"));
      } else if (slide.contentType === "video") {
        // Force aspect ratio for the video
        // "I say the whole world must learn of our peaceful ways… by force!"
        aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9;

        if (height > width / aspectRatio) {
          height = width / aspectRatio;
        } else if (width > height * aspectRatio) {
          width = height * aspectRatio;
        }
      }

      rez.width = width;
      rez.height = height;
      return rez;
    },
    // Update content size and position for all slides
    // ==============================================
    update: function (e) {
      var self = this;
      $.each(self.slides, function (key, slide) {
        self.updateSlide(slide, e);
      });
    },
    // Update slide content position and size
    // ======================================
    updateSlide: function (slide, e) {
      var self = this,
          $content = slide && slide.$content,
          width = slide.width || slide.opts.width,
          height = slide.height || slide.opts.height,
          $slide = slide.$slide; // First, prevent caption overlap, if needed

      self.adjustCaption(slide); // Then resize content to fit inside the slide

      if ($content && (width || height || slide.contentType === "video") && !slide.hasError) {
        $.fancybox.stop($content);
        $.fancybox.setTranslate($content, self.getFitPos(slide));

        if (slide.pos === self.currPos) {
          self.isAnimating = false;
          self.updateCursor();
        }
      } // Then some adjustments


      self.adjustLayout(slide);

      if ($slide.length) {
        $slide.trigger("refresh");

        if (slide.pos === self.currPos) {
          self.$refs.toolbar.add(self.$refs.navigation.find(".fancybox-button--arrow_right")).toggleClass("compensate-for-scrollbar", $slide.get(0).scrollHeight > $slide.get(0).clientHeight);
        }
      }

      self.trigger("onUpdate", slide, e);
    },
    // Horizontally center slide
    // =========================
    centerSlide: function (duration) {
      var self = this,
          current = self.current,
          $slide = current.$slide;

      if (self.isClosing || !current) {
        return;
      }

      $slide.siblings().css({
        transform: "",
        opacity: ""
      });
      $slide.parent().children().removeClass("fancybox-slide--previous fancybox-slide--next");
      $.fancybox.animate($slide, {
        top: 0,
        left: 0,
        opacity: 1
      }, duration === undefined ? 0 : duration, function () {
        // Clean up
        $slide.css({
          transform: "",
          opacity: ""
        });

        if (!current.isComplete) {
          self.complete();
        }
      }, false);
    },
    // Check if current slide is moved (swiped)
    // ========================================
    isMoved: function (slide) {
      var current = slide || this.current,
          slidePos,
          stagePos;

      if (!current) {
        return false;
      }

      stagePos = $.fancybox.getTranslate(this.$refs.stage);
      slidePos = $.fancybox.getTranslate(current.$slide);
      return !current.$slide.hasClass("fancybox-animated") && (Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5);
    },
    // Update cursor style depending if content can be zoomed
    // ======================================================
    updateCursor: function (nextWidth, nextHeight) {
      var self = this,
          current = self.current,
          $container = self.$refs.container,
          canPan,
          isZoomable;

      if (!current || self.isClosing || !self.Guestures) {
        return;
      }

      $container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan");
      canPan = self.canPan(nextWidth, nextHeight);
      isZoomable = canPan ? true : self.isZoomable();
      $container.toggleClass("fancybox-is-zoomable", isZoomable);
      $("[data-fancybox-zoom]").prop("disabled", !isZoomable);

      if (canPan) {
        $container.addClass("fancybox-can-pan");
      } else if (isZoomable && (current.opts.clickContent === "zoom" || $.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == "zoom")) {
        $container.addClass("fancybox-can-zoomIn");
      } else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== "video") {
        $container.addClass("fancybox-can-swipe");
      }
    },
    // Check if current slide is zoomable
    // ==================================
    isZoomable: function () {
      var self = this,
          current = self.current,
          fitPos; // Assume that slide is zoomable if:
      //   - image is still loading
      //   - actual size of the image is smaller than available area

      if (current && !self.isClosing && current.type === "image" && !current.hasError) {
        if (!current.isLoaded) {
          return true;
        }

        fitPos = self.getFitPos(current);

        if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) {
          return true;
        }
      }

      return false;
    },
    // Check if current image dimensions are smaller than actual
    // =========================================================
    isScaledDown: function (nextWidth, nextHeight) {
      var self = this,
          rez = false,
          current = self.current,
          $content = current.$content;

      if (nextWidth !== undefined && nextHeight !== undefined) {
        rez = nextWidth < current.width && nextHeight < current.height;
      } else if ($content) {
        rez = $.fancybox.getTranslate($content);
        rez = rez.width < current.width && rez.height < current.height;
      }

      return rez;
    },
    // Check if image dimensions exceed parent element
    // ===============================================
    canPan: function (nextWidth, nextHeight) {
      var self = this,
          current = self.current,
          pos = null,
          rez = false;

      if (current.type === "image" && (current.isComplete || nextWidth && nextHeight) && !current.hasError) {
        rez = self.getFitPos(current);

        if (nextWidth !== undefined && nextHeight !== undefined) {
          pos = {
            width: nextWidth,
            height: nextHeight
          };
        } else if (current.isComplete) {
          pos = $.fancybox.getTranslate(current.$content);
        }

        if (pos && rez) {
          rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5;
        }
      }

      return rez;
    },
    // Load content into the slide
    // ===========================
    loadSlide: function (slide) {
      var self = this,
          type,
          $slide,
          ajaxLoad;

      if (slide.isLoading || slide.isLoaded) {
        return;
      }

      slide.isLoading = true;

      if (self.trigger("beforeLoad", slide) === false) {
        slide.isLoading = false;
        return false;
      }

      type = slide.type;
      $slide = slide.$slide;
      $slide.off("refresh").trigger("onReset").addClass(slide.opts.slideClass); // Create content depending on the type

      switch (type) {
        case "image":
          self.setImage(slide);
          break;

        case "iframe":
          self.setIframe(slide);
          break;

        case "html":
          self.setContent(slide, slide.src || slide.content);
          break;

        case "video":
          self.setContent(slide, slide.opts.video.tpl.replace(/\{\{src\}\}/gi, slide.src).replace("{{format}}", slide.opts.videoFormat || slide.opts.video.format || "").replace("{{poster}}", slide.thumb || ""));
          break;

        case "inline":
          if ($(slide.src).length) {
            self.setContent(slide, $(slide.src));
          } else {
            self.setError(slide);
          }

          break;

        case "ajax":
          self.showLoading(slide);
          ajaxLoad = $.ajax($.extend({}, slide.opts.ajax.settings, {
            url: slide.src,
            success: function (data, textStatus) {
              if (textStatus === "success") {
                self.setContent(slide, data);
              }
            },
            error: function (jqXHR, textStatus) {
              if (jqXHR && textStatus !== "abort") {
                self.setError(slide);
              }
            }
          }));
          $slide.one("onReset", function () {
            ajaxLoad.abort();
          });
          break;

        default:
          self.setError(slide);
          break;
      }

      return true;
    },
    // Use thumbnail image, if possible
    // ================================
    setImage: function (slide) {
      var self = this,
          ghost; // Check if need to show loading icon

      setTimeout(function () {
        var $img = slide.$image;

        if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) {
          self.showLoading(slide);
        }
      }, 50); //Check if image has srcset

      self.checkSrcset(slide); // This will be wrapper containing both ghost and actual image

      slide.$content = $('<div class="fancybox-content"></div>').addClass("fancybox-is-hidden").appendTo(slide.$slide.addClass("fancybox-slide--image")); // If we have a thumbnail, we can display it while actual image is loading
      // Users will not stare at black screen and actual image will appear gradually

      if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) {
        slide.width = slide.opts.width;
        slide.height = slide.opts.height;
        ghost = document.createElement("img");

        ghost.onerror = function () {
          $(this).remove();
          slide.$ghost = null;
        };

        ghost.onload = function () {
          self.afterLoad(slide);
        };

        slide.$ghost = $(ghost).addClass("fancybox-image").appendTo(slide.$content).attr("src", slide.thumb);
      } // Start loading actual image


      self.setBigImage(slide);
    },
    // Check if image has srcset and get the source
    // ============================================
    checkSrcset: function (slide) {
      var srcset = slide.opts.srcset || slide.opts.image.srcset,
          found,
          temp,
          pxRatio,
          windowWidth; // If we have "srcset", then we need to find first matching "src" value.
      // This is necessary, because when you set an src attribute, the browser will preload the image
      // before any javascript or even CSS is applied.

      if (srcset) {
        pxRatio = window.devicePixelRatio || 1;
        windowWidth = window.innerWidth * pxRatio;
        temp = srcset.split(",").map(function (el) {
          var ret = {};
          el.trim().split(/\s+/).forEach(function (el, i) {
            var value = parseInt(el.substring(0, el.length - 1), 10);

            if (i === 0) {
              return ret.url = el;
            }

            if (value) {
              ret.value = value;
              ret.postfix = el[el.length - 1];
            }
          });
          return ret;
        }); // Sort by value

        temp.sort(function (a, b) {
          return a.value - b.value;
        }); // Ok, now we have an array of all srcset values

        for (var j = 0; j < temp.length; j++) {
          var el = temp[j];

          if (el.postfix === "w" && el.value >= windowWidth || el.postfix === "x" && el.value >= pxRatio) {
            found = el;
            break;
          }
        } // If not found, take the last one


        if (!found && temp.length) {
          found = temp[temp.length - 1];
        }

        if (found) {
          slide.src = found.url; // If we have default width/height values, we can calculate height for matching source

          if (slide.width && slide.height && found.postfix == "w") {
            slide.height = slide.width / slide.height * found.value;
            slide.width = found.value;
          }

          slide.opts.srcset = srcset;
        }
      }
    },
    // Create full-size image
    // ======================
    setBigImage: function (slide) {
      var self = this,
          img = document.createElement("img"),
          $img = $(img);
      slide.$image = $img.one("error", function () {
        self.setError(slide);
      }).one("load", function () {
        var sizes;

        if (!slide.$ghost) {
          self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);
          self.afterLoad(slide);
        }

        if (self.isClosing) {
          return;
        }

        if (slide.opts.srcset) {
          sizes = slide.opts.sizes;

          if (!sizes || sizes === "auto") {
            sizes = (slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? "100" : Math.round(slide.width / slide.height * 100)) + "vw";
          }

          $img.attr("sizes", sizes).attr("srcset", slide.opts.srcset);
        } // Hide temporary image after some delay


        if (slide.$ghost) {
          setTimeout(function () {
            if (slide.$ghost && !self.isClosing) {
              slide.$ghost.hide();
            }
          }, Math.min(300, Math.max(1000, slide.height / 1600)));
        }

        self.hideLoading(slide);
      }).addClass("fancybox-image").attr("src", slide.src).appendTo(slide.$content);

      if ((img.complete || img.readyState == "complete") && $img.naturalWidth && $img.naturalHeight) {
        $img.trigger("load");
      } else if (img.error) {
        $img.trigger("error");
      }
    },
    // Computes the slide size from image size and maxWidth/maxHeight
    // ==============================================================
    resolveImageSlideSize: function (slide, imgWidth, imgHeight) {
      var maxWidth = parseInt(slide.opts.width, 10),
          maxHeight = parseInt(slide.opts.height, 10); // Sets the default values from the image

      slide.width = imgWidth;
      slide.height = imgHeight;

      if (maxWidth > 0) {
        slide.width = maxWidth;
        slide.height = Math.floor(maxWidth * imgHeight / imgWidth);
      }

      if (maxHeight > 0) {
        slide.width = Math.floor(maxHeight * imgWidth / imgHeight);
        slide.height = maxHeight;
      }
    },
    // Create iframe wrapper, iframe and bindings
    // ==========================================
    setIframe: function (slide) {
      var self = this,
          opts = slide.opts.iframe,
          $slide = slide.$slide,
          $iframe;
      slide.$content = $('<div class="fancybox-content' + (opts.preload ? " fancybox-is-hidden" : "") + '"></div>').css(opts.css).appendTo($slide);
      $slide.addClass("fancybox-slide--" + slide.contentType);
      slide.$iframe = $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime())).attr(opts.attr).appendTo(slide.$content);

      if (opts.preload) {
        self.showLoading(slide); // Unfortunately, it is not always possible to determine if iframe is successfully loaded
        // (due to browser security policy)

        $iframe.on("load.fb error.fb", function (e) {
          this.isReady = 1;
          slide.$slide.trigger("refresh");
          self.afterLoad(slide);
        }); // Recalculate iframe content size
        // ===============================

        $slide.on("refresh.fb", function () {
          var $content = slide.$content,
              frameWidth = opts.css.width,
              frameHeight = opts.css.height,
              $contents,
              $body;

          if ($iframe[0].isReady !== 1) {
            return;
          }

          try {
            $contents = $iframe.contents();
            $body = $contents.find("body");
          } catch (ignore) {} // Calculate content dimensions, if it is accessible


          if ($body && $body.length && $body.children().length) {
            // Avoid scrolling to top (if multiple instances)
            $slide.css("overflow", "visible");
            $content.css({
              width: "100%",
              "max-width": "100%",
              height: "9999px"
            });

            if (frameWidth === undefined) {
              frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));
            }

            $content.css("width", frameWidth ? frameWidth : "").css("max-width", "");

            if (frameHeight === undefined) {
              frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));
            }

            $content.css("height", frameHeight ? frameHeight : "");
            $slide.css("overflow", "auto");
          }

          $content.removeClass("fancybox-is-hidden");
        });
      } else {
        self.afterLoad(slide);
      }

      $iframe.attr("src", slide.src); // Remove iframe if closing or changing gallery item

      $slide.one("onReset", function () {
        // This helps IE not to throw errors when closing
        try {
          $(this).find("iframe").hide().unbind().attr("src", "//about:blank");
        } catch (ignore) {}

        $(this).off("refresh.fb").empty();
        slide.isLoaded = false;
        slide.isRevealed = false;
      });
    },
    // Wrap and append content to the slide
    // ======================================
    setContent: function (slide, content) {
      var self = this;

      if (self.isClosing) {
        return;
      }

      self.hideLoading(slide);

      if (slide.$content) {
        $.fancybox.stop(slide.$content);
      }

      slide.$slide.empty(); // If content is a jQuery object, then it will be moved to the slide.
      // The placeholder is created so we will know where to put it back.

      if (isQuery(content) && content.parent().length) {
        // Make sure content is not already moved to fancyBox
        if (content.hasClass("fancybox-content") || content.parent().hasClass("fancybox-content")) {
          content.parents(".fancybox-slide").trigger("onReset");
        } // Create temporary element marking original place of the content


        slide.$placeholder = $("<div>").hide().insertAfter(content); // Make sure content is visible

        content.css("display", "inline-block");
      } else if (!slide.hasError) {
        // If content is just a plain text, try to convert it to html
        if ($.type(content) === "string") {
          content = $("<div>").append($.trim(content)).contents();
        } // If "filter" option is provided, then filter content


        if (slide.opts.filter) {
          content = $("<div>").html(content).find(slide.opts.filter);
        }
      }

      slide.$slide.one("onReset", function () {
        // Pause all html5 video/audio
        $(this).find("video,audio").trigger("pause"); // Put content back

        if (slide.$placeholder) {
          slide.$placeholder.after(content.removeClass("fancybox-content").hide()).remove();
          slide.$placeholder = null;
        } // Remove custom close button


        if (slide.$smallBtn) {
          slide.$smallBtn.remove();
          slide.$smallBtn = null;
        } // Remove content and mark slide as not loaded


        if (!slide.hasError) {
          $(this).empty();
          slide.isLoaded = false;
          slide.isRevealed = false;
        }
      });
      $(content).appendTo(slide.$slide);

      if ($(content).is("video,audio")) {
        $(content).addClass("fancybox-video");
        $(content).wrap("<div></div>");
        slide.contentType = "video";
        slide.opts.width = slide.opts.width || $(content).attr("width");
        slide.opts.height = slide.opts.height || $(content).attr("height");
      }

      slide.$content = slide.$slide.children().filter("div,form,main,video,audio,article,.fancybox-content").first();
      slide.$content.siblings().hide(); // Re-check if there is a valid content
      // (in some cases, ajax response can contain various elements or plain text)

      if (!slide.$content.length) {
        slide.$content = slide.$slide.wrapInner("<div></div>").children().first();
      }

      slide.$content.addClass("fancybox-content");
      slide.$slide.addClass("fancybox-slide--" + slide.contentType);
      self.afterLoad(slide);
    },
    // Display error message
    // =====================
    setError: function (slide) {
      slide.hasError = true;
      slide.$slide.trigger("onReset").removeClass("fancybox-slide--" + slide.contentType).addClass("fancybox-slide--error");
      slide.contentType = "html";
      this.setContent(slide, this.translate(slide, slide.opts.errorTpl));

      if (slide.pos === this.currPos) {
        this.isAnimating = false;
      }
    },
    // Show loading icon inside the slide
    // ==================================
    showLoading: function (slide) {
      var self = this;
      slide = slide || self.current;

      if (slide && !slide.$spinner) {
        slide.$spinner = $(self.translate(self, self.opts.spinnerTpl)).appendTo(slide.$slide).hide().fadeIn("fast");
      }
    },
    // Remove loading icon from the slide
    // ==================================
    hideLoading: function (slide) {
      var self = this;
      slide = slide || self.current;

      if (slide && slide.$spinner) {
        slide.$spinner.stop().remove();
        delete slide.$spinner;
      }
    },
    // Adjustments after slide content has been loaded
    // ===============================================
    afterLoad: function (slide) {
      var self = this;

      if (self.isClosing) {
        return;
      }

      slide.isLoading = false;
      slide.isLoaded = true;
      self.trigger("afterLoad", slide);
      self.hideLoading(slide); // Add small close button

      if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {
        slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content);
      } // Disable right click


      if (slide.opts.protect && slide.$content && !slide.hasError) {
        slide.$content.on("contextmenu.fb", function (e) {
          if (e.button == 2) {
            e.preventDefault();
          }

          return true;
        }); // Add fake element on top of the image
        // This makes a bit harder for user to select image

        if (slide.type === "image") {
          $('<div class="fancybox-spaceball"></div>').appendTo(slide.$content);
        }
      }

      self.adjustCaption(slide);
      self.adjustLayout(slide);

      if (slide.pos === self.currPos) {
        self.updateCursor();
      }

      self.revealContent(slide);
    },
    // Prevent caption overlap,
    // fix css inconsistency across browsers
    // =====================================
    adjustCaption: function (slide) {
      var self = this,
          current = slide || self.current,
          caption = current.opts.caption,
          preventOverlap = current.opts.preventCaptionOverlap,
          $caption = self.$refs.caption,
          $clone,
          captionH = false;
      $caption.toggleClass("fancybox-caption--separate", preventOverlap);

      if (preventOverlap && caption && caption.length) {
        if (current.pos !== self.currPos) {
          $clone = $caption.clone().appendTo($caption.parent());
          $clone.children().eq(0).empty().html(caption);
          captionH = $clone.outerHeight(true);
          $clone.empty().remove();
        } else if (self.$caption) {
          captionH = self.$caption.outerHeight(true);
        }

        current.$slide.css("padding-bottom", captionH || "");
      }
    },
    // Simple hack to fix inconsistency across browsers, described here (affects Edge, too):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=748518
    // ====================================================================================
    adjustLayout: function (slide) {
      var self = this,
          current = slide || self.current,
          scrollHeight,
          marginBottom,
          inlinePadding,
          actualPadding;

      if (current.isLoaded && current.opts.disableLayoutFix !== true) {
        current.$content.css("margin-bottom", ""); // If we would always set margin-bottom for the content,
        // then it would potentially break vertical align

        if (current.$content.outerHeight() > current.$slide.height() + 0.5) {
          inlinePadding = current.$slide[0].style["padding-bottom"];
          actualPadding = current.$slide.css("padding-bottom");

          if (parseFloat(actualPadding) > 0) {
            scrollHeight = current.$slide[0].scrollHeight;
            current.$slide.css("padding-bottom", 0);

            if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) {
              marginBottom = actualPadding;
            }

            current.$slide.css("padding-bottom", inlinePadding);
          }
        }

        current.$content.css("margin-bottom", marginBottom);
      }
    },
    // Make content visible
    // This method is called right after content has been loaded or
    // user navigates gallery and transition should start
    // ============================================================
    revealContent: function (slide) {
      var self = this,
          $slide = slide.$slide,
          end = false,
          start = false,
          isMoved = self.isMoved(slide),
          isRevealed = slide.isRevealed,
          effect,
          effectClassName,
          duration,
          opacity;
      slide.isRevealed = true;
      effect = slide.opts[self.firstRun ? "animationEffect" : "transitionEffect"];
      duration = slide.opts[self.firstRun ? "animationDuration" : "transitionDuration"];
      duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);

      if (isMoved || slide.pos !== self.currPos || !duration) {
        effect = false;
      } // Check if can zoom


      if (effect === "zoom") {
        if (slide.pos === self.currPos && duration && slide.type === "image" && !slide.hasError && (start = self.getThumbPos(slide))) {
          end = self.getFitPos(slide);
        } else {
          effect = "fade";
        }
      } // Zoom animation
      // ==============


      if (effect === "zoom") {
        self.isAnimating = true;
        end.scaleX = end.width / start.width;
        end.scaleY = end.height / start.height; // Check if we need to animate opacity

        opacity = slide.opts.zoomOpacity;

        if (opacity == "auto") {
          opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;
        }

        if (opacity) {
          start.opacity = 0.1;
          end.opacity = 1;
        } // Draw image at start position


        $.fancybox.setTranslate(slide.$content.removeClass("fancybox-is-hidden"), start);
        forceRedraw(slide.$content); // Start animation

        $.fancybox.animate(slide.$content, end, duration, function () {
          self.isAnimating = false;
          self.complete();
        });
        return;
      }

      self.updateSlide(slide); // Simply show content if no effect
      // ================================

      if (!effect) {
        slide.$content.removeClass("fancybox-is-hidden");

        if (!isRevealed && isMoved && slide.type === "image" && !slide.hasError) {
          slide.$content.hide().fadeIn("fast");
        }

        if (slide.pos === self.currPos) {
          self.complete();
        }

        return;
      } // Prepare for CSS transiton
      // =========================


      $.fancybox.stop($slide); //effectClassName = "fancybox-animated fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-fx-" + effect;

      effectClassName = "fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-animated fancybox-fx-" + effect;
      $slide.addClass(effectClassName).removeClass("fancybox-slide--current"); //.addClass(effectClassName);

      slide.$content.removeClass("fancybox-is-hidden"); // Force reflow

      forceRedraw($slide);

      if (slide.type !== "image") {
        slide.$content.hide().show(0);
      }

      $.fancybox.animate($slide, "fancybox-slide--current", duration, function () {
        $slide.removeClass(effectClassName).css({
          transform: "",
          opacity: ""
        });

        if (slide.pos === self.currPos) {
          self.complete();
        }
      }, true);
    },
    // Check if we can and have to zoom from thumbnail
    //================================================
    getThumbPos: function (slide) {
      var rez = false,
          $thumb = slide.$thumb,
          thumbPos,
          btw,
          brw,
          bbw,
          blw;

      if (!$thumb || !inViewport($thumb[0])) {
        return false;
      }

      thumbPos = $.fancybox.getTranslate($thumb);
      btw = parseFloat($thumb.css("border-top-width") || 0);
      brw = parseFloat($thumb.css("border-right-width") || 0);
      bbw = parseFloat($thumb.css("border-bottom-width") || 0);
      blw = parseFloat($thumb.css("border-left-width") || 0);
      rez = {
        top: thumbPos.top + btw,
        left: thumbPos.left + blw,
        width: thumbPos.width - brw - blw,
        height: thumbPos.height - btw - bbw,
        scaleX: 1,
        scaleY: 1
      };
      return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false;
    },
    // Final adjustments after current gallery item is moved to position
    // and it`s content is loaded
    // ==================================================================
    complete: function () {
      var self = this,
          current = self.current,
          slides = {},
          $el;

      if (self.isMoved() || !current.isLoaded) {
        return;
      }

      if (!current.isComplete) {
        current.isComplete = true;
        current.$slide.siblings().trigger("onReset");
        self.preload("inline"); // Trigger any CSS transiton inside the slide

        forceRedraw(current.$slide);
        current.$slide.addClass("fancybox-slide--complete"); // Remove unnecessary slides

        $.each(self.slides, function (key, slide) {
          if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
            slides[slide.pos] = slide;
          } else if (slide) {
            $.fancybox.stop(slide.$slide);
            slide.$slide.off().remove();
          }
        });
        self.slides = slides;
      }

      self.isAnimating = false;
      self.updateCursor();
      self.trigger("afterShow"); // Autoplay first html5 video/audio

      if (!!current.opts.video.autoStart) {
        current.$slide.find("video,audio").filter(":visible:first").trigger("play").one("ended", function () {
          if (this.webkitExitFullscreen) {
            this.webkitExitFullscreen();
          }

          self.next();
        });
      } // Try to focus on the first focusable element


      if (current.opts.autoFocus && current.contentType === "html") {
        // Look for the first input with autofocus attribute
        $el = current.$content.find("input[autofocus]:enabled:visible:first");

        if ($el.length) {
          $el.trigger("focus");
        } else {
          self.focus(null, true);
        }
      } // Avoid jumping


      current.$slide.scrollTop(0).scrollLeft(0);
    },
    // Preload next and previous slides
    // ================================
    preload: function (type) {
      var self = this,
          prev,
          next;

      if (self.group.length < 2) {
        return;
      }

      next = self.slides[self.currPos + 1];
      prev = self.slides[self.currPos - 1];

      if (prev && prev.type === type) {
        self.loadSlide(prev);
      }

      if (next && next.type === type) {
        self.loadSlide(next);
      }
    },
    // Try to find and focus on the first focusable element
    // ====================================================
    focus: function (e, firstRun) {
      var self = this,
          focusableStr = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'].join(","),
          focusableItems,
          focusedItemIndex;

      if (self.isClosing) {
        return;
      }

      if (e || !self.current || !self.current.isComplete) {
        // Focus on any element inside fancybox
        focusableItems = self.$refs.container.find("*:visible");
      } else {
        // Focus inside current slide
        focusableItems = self.current.$slide.find("*:visible" + (firstRun ? ":not(.fancybox-close-small)" : ""));
      }

      focusableItems = focusableItems.filter(focusableStr).filter(function () {
        return $(this).css("visibility") !== "hidden" && !$(this).hasClass("disabled");
      });

      if (focusableItems.length) {
        focusedItemIndex = focusableItems.index(document.activeElement);

        if (e && e.shiftKey) {
          // Back tab
          if (focusedItemIndex < 0 || focusedItemIndex == 0) {
            e.preventDefault();
            focusableItems.eq(focusableItems.length - 1).trigger("focus");
          }
        } else {
          // Outside or Forward tab
          if (focusedItemIndex < 0 || focusedItemIndex == focusableItems.length - 1) {
            if (e) {
              e.preventDefault();
            }

            focusableItems.eq(0).trigger("focus");
          }
        }
      } else {
        self.$refs.container.trigger("focus");
      }
    },
    // Activates current instance - brings container to the front and enables keyboard,
    // notifies other instances about deactivating
    // =================================================================================
    activate: function () {
      var self = this; // Deactivate all instances

      $(".fancybox-container").each(function () {
        var instance = $(this).data("FancyBox"); // Skip self and closing instances

        if (instance && instance.id !== self.id && !instance.isClosing) {
          instance.trigger("onDeactivate");
          instance.removeEvents();
          instance.isVisible = false;
        }
      });
      self.isVisible = true;

      if (self.current || self.isIdle) {
        self.update();
        self.updateControls();
      }

      self.trigger("onActivate");
      self.addEvents();
    },
    // Start closing procedure
    // This will start "zoom-out" animation if needed and clean everything up afterwards
    // =================================================================================
    close: function (e, d) {
      var self = this,
          current = self.current,
          effect,
          duration,
          $content,
          domRect,
          opacity,
          start,
          end;

      var done = function () {
        self.cleanUp(e);
      };

      if (self.isClosing) {
        return false;
      }

      self.isClosing = true; // If beforeClose callback prevents closing, make sure content is centered

      if (self.trigger("beforeClose", e) === false) {
        self.isClosing = false;
        requestAFrame(function () {
          self.update();
        });
        return false;
      } // Remove all events
      // If there are multiple instances, they will be set again by "activate" method


      self.removeEvents();
      $content = current.$content;
      effect = current.opts.animationEffect;
      duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;
      current.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated");

      if (e !== true) {
        $.fancybox.stop(current.$slide);
      } else {
        effect = false;
      } // Remove other slides


      current.$slide.siblings().trigger("onReset").remove(); // Trigger animations

      if (duration) {
        self.$refs.container.removeClass("fancybox-is-open").addClass("fancybox-is-closing").css("transition-duration", duration + "ms");
      } // Clean up


      self.hideLoading(current);
      self.hideControls(true);
      self.updateCursor(); // Check if possible to zoom-out

      if (effect === "zoom" && !($content && duration && current.type === "image" && !self.isMoved() && !current.hasError && (end = self.getThumbPos(current)))) {
        effect = "fade";
      }

      if (effect === "zoom") {
        $.fancybox.stop($content);
        domRect = $.fancybox.getTranslate($content);
        start = {
          top: domRect.top,
          left: domRect.left,
          scaleX: domRect.width / end.width,
          scaleY: domRect.height / end.height,
          width: end.width,
          height: end.height
        }; // Check if we need to animate opacity

        opacity = current.opts.zoomOpacity;

        if (opacity == "auto") {
          opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;
        }

        if (opacity) {
          end.opacity = 0;
        }

        $.fancybox.setTranslate($content, start);
        forceRedraw($content);
        $.fancybox.animate($content, end, duration, done);
        return true;
      }

      if (effect && duration) {
        $.fancybox.animate(current.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"), "fancybox-animated fancybox-fx-" + effect, duration, done);
      } else {
        // If skip animation
        if (e === true) {
          setTimeout(done, duration);
        } else {
          done();
        }
      }

      return true;
    },
    // Final adjustments after removing the instance
    // =============================================
    cleanUp: function (e) {
      var self = this,
          instance,
          $focus = self.current.opts.$orig,
          x,
          y;
      self.current.$slide.trigger("onReset");
      self.$refs.container.empty().remove();
      self.trigger("afterClose", e); // Place back focus

      if (!!self.current.opts.backFocus) {
        if (!$focus || !$focus.length || !$focus.is(":visible")) {
          $focus = self.$trigger;
        }

        if ($focus && $focus.length) {
          x = window.scrollX;
          y = window.scrollY;
          $focus.trigger("focus");
          $("html, body").scrollTop(y).scrollLeft(x);
        }
      }

      self.current = null; // Check if there are other instances

      instance = $.fancybox.getInstance();

      if (instance) {
        instance.activate();
      } else {
        $("body").removeClass("fancybox-active compensate-for-scrollbar");
        $("#fancybox-style-noscroll").remove();
      }
    },
    // Call callback and trigger an event
    // ==================================
    trigger: function (name, slide) {
      var args = Array.prototype.slice.call(arguments, 1),
          self = this,
          obj = slide && slide.opts ? slide : self.current,
          rez;

      if (obj) {
        args.unshift(obj);
      } else {
        obj = self;
      }

      args.unshift(self);

      if ($.isFunction(obj.opts[name])) {
        rez = obj.opts[name].apply(obj, args);
      }

      if (rez === false) {
        return rez;
      }

      if (name === "afterClose" || !self.$refs) {
        $D.trigger(name + ".fb", args);
      } else {
        self.$refs.container.trigger(name + ".fb", args);
      }
    },
    // Update infobar values, navigation button states and reveal caption
    // ==================================================================
    updateControls: function () {
      var self = this,
          current = self.current,
          index = current.index,
          $container = self.$refs.container,
          $caption = self.$refs.caption,
          caption = current.opts.caption; // Recalculate content dimensions

      current.$slide.trigger("refresh"); // Set caption

      if (caption && caption.length) {
        self.$caption = $caption;
        $caption.children().eq(0).html(caption);
      } else {
        self.$caption = null;
      }

      if (!self.hasHiddenControls && !self.isIdle) {
        self.showControls();
      } // Update info and navigation elements


      $container.find("[data-fancybox-count]").html(self.group.length);
      $container.find("[data-fancybox-index]").html(index + 1);
      $container.find("[data-fancybox-prev]").prop("disabled", !current.opts.loop && index <= 0);
      $container.find("[data-fancybox-next]").prop("disabled", !current.opts.loop && index >= self.group.length - 1);

      if (current.type === "image") {
        // Re-enable buttons; update download button source
        $container.find("[data-fancybox-zoom]").show().end().find("[data-fancybox-download]").attr("href", current.opts.image.src || current.src).show();
      } else if (current.opts.toolbar) {
        $container.find("[data-fancybox-download],[data-fancybox-zoom]").hide();
      } // Make sure focus is not on disabled button/element


      if ($(document.activeElement).is(":hidden,[disabled]")) {
        self.$refs.container.trigger("focus");
      }
    },
    // Hide toolbar and caption
    // ========================
    hideControls: function (andCaption) {
      var self = this,
          arr = ["infobar", "toolbar", "nav"];

      if (andCaption || !self.current.opts.preventCaptionOverlap) {
        arr.push("caption");
      }

      this.$refs.container.removeClass(arr.map(function (i) {
        return "fancybox-show-" + i;
      }).join(" "));
      this.hasHiddenControls = true;
    },
    showControls: function () {
      var self = this,
          opts = self.current ? self.current.opts : self.opts,
          $container = self.$refs.container;
      self.hasHiddenControls = false;
      self.idleSecondsCounter = 0;
      $container.toggleClass("fancybox-show-toolbar", !!(opts.toolbar && opts.buttons)).toggleClass("fancybox-show-infobar", !!(opts.infobar && self.group.length > 1)).toggleClass("fancybox-show-caption", !!self.$caption).toggleClass("fancybox-show-nav", !!(opts.arrows && self.group.length > 1)).toggleClass("fancybox-is-modal", !!opts.modal);
    },
    // Toggle toolbar and caption
    // ==========================
    toggleControls: function () {
      if (this.hasHiddenControls) {
        this.showControls();
      } else {
        this.hideControls();
      }
    }
  });
  $.fancybox = {
    version: "3.5.6",
    defaults: defaults,
    // Get current instance and execute a command.
    //
    // Examples of usage:
    //
    //   $instance = $.fancybox.getInstance();
    //   $.fancybox.getInstance().jumpTo( 1 );
    //   $.fancybox.getInstance( 'jumpTo', 1 );
    //   $.fancybox.getInstance( function() {
    //       console.info( this.currIndex );
    //   });
    // ======================================================
    getInstance: function (command) {
      var instance = $('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),
          args = Array.prototype.slice.call(arguments, 1);

      if (instance instanceof FancyBox) {
        if ($.type(command) === "string") {
          instance[command].apply(instance, args);
        } else if ($.type(command) === "function") {
          command.apply(instance, args);
        }

        return instance;
      }

      return false;
    },
    // Create new instance
    // ===================
    open: function (items, opts, index) {
      return new FancyBox(items, opts, index);
    },
    // Close current or all instances
    // ==============================
    close: function (all) {
      var instance = this.getInstance();

      if (instance) {
        instance.close(); // Try to find and close next instance

        if (all === true) {
          this.close(all);
        }
      }
    },
    // Close all instances and unbind all events
    // =========================================
    destroy: function () {
      this.close(true);
      $D.add("body").off("click.fb-start", "**");
    },
    // Try to detect mobile devices
    // ============================
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    // Detect if 'translate3d' support is available
    // ============================================
    use3d: function () {
      var div = document.createElement("div");
      return window.getComputedStyle && window.getComputedStyle(div) && window.getComputedStyle(div).getPropertyValue("transform") && !(document.documentMode && document.documentMode < 11);
    }(),
    // Helper function to get current visual state of an element
    // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]
    // =====================================================================
    getTranslate: function ($el) {
      var domRect;

      if (!$el || !$el.length) {
        return false;
      }

      domRect = $el[0].getBoundingClientRect();
      return {
        top: domRect.top || 0,
        left: domRect.left || 0,
        width: domRect.width,
        height: domRect.height,
        opacity: parseFloat($el.css("opacity"))
      };
    },
    // Shortcut for setting "translate3d" properties for element
    // Can set be used to set opacity, too
    // ========================================================
    setTranslate: function ($el, props) {
      var str = "",
          css = {};

      if (!$el || !props) {
        return;
      }

      if (props.left !== undefined || props.top !== undefined) {
        str = (props.left === undefined ? $el.position().left : props.left) + "px, " + (props.top === undefined ? $el.position().top : props.top) + "px";

        if (this.use3d) {
          str = "translate3d(" + str + ", 0px)";
        } else {
          str = "translate(" + str + ")";
        }
      }

      if (props.scaleX !== undefined && props.scaleY !== undefined) {
        str += " scale(" + props.scaleX + ", " + props.scaleY + ")";
      } else if (props.scaleX !== undefined) {
        str += " scaleX(" + props.scaleX + ")";
      }

      if (str.length) {
        css.transform = str;
      }

      if (props.opacity !== undefined) {
        css.opacity = props.opacity;
      }

      if (props.width !== undefined) {
        css.width = props.width;
      }

      if (props.height !== undefined) {
        css.height = props.height;
      }

      return $el.css(css);
    },
    // Simple CSS transition handler
    // =============================
    animate: function ($el, to, duration, callback, leaveAnimationName) {
      var self = this,
          from;

      if ($.isFunction(duration)) {
        callback = duration;
        duration = null;
      }

      self.stop($el);
      from = self.getTranslate($el);
      $el.on(transitionEnd, function (e) {
        // Skip events from child elements and z-index change
        if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == "z-index")) {
          return;
        }

        self.stop($el);

        if ($.isNumeric(duration)) {
          $el.css("transition-duration", "");
        }

        if ($.isPlainObject(to)) {
          if (to.scaleX !== undefined && to.scaleY !== undefined) {
            self.setTranslate($el, {
              top: to.top,
              left: to.left,
              width: from.width * to.scaleX,
              height: from.height * to.scaleY,
              scaleX: 1,
              scaleY: 1
            });
          }
        } else if (leaveAnimationName !== true) {
          $el.removeClass(to);
        }

        if ($.isFunction(callback)) {
          callback(e);
        }
      });

      if ($.isNumeric(duration)) {
        $el.css("transition-duration", duration + "ms");
      } // Start animation by changing CSS properties or class name


      if ($.isPlainObject(to)) {
        if (to.scaleX !== undefined && to.scaleY !== undefined) {
          delete to.width;
          delete to.height;

          if ($el.parent().hasClass("fancybox-slide--image")) {
            $el.parent().addClass("fancybox-is-scaling");
          }
        }

        $.fancybox.setTranslate($el, to);
      } else {
        $el.addClass(to);
      } // Make sure that `transitionend` callback gets fired


      $el.data("timer", setTimeout(function () {
        $el.trigger(transitionEnd);
      }, duration + 33));
    },
    stop: function ($el, callCallback) {
      if ($el && $el.length) {
        clearTimeout($el.data("timer"));

        if (callCallback) {
          $el.trigger(transitionEnd);
        }

        $el.off(transitionEnd).css("transition-duration", "");
        $el.parent().removeClass("fancybox-is-scaling");
      }
    }
  }; // Default click handler for "fancyboxed" links
  // ============================================

  function _run(e, opts) {
    var items = [],
        index = 0,
        $target,
        value,
        instance; // Avoid opening multiple times

    if (e && e.isDefaultPrevented()) {
      return;
    }

    e.preventDefault();
    opts = opts || {};

    if (e && e.data) {
      opts = mergeOpts(e.data.options, opts);
    }

    $target = opts.$target || $(e.currentTarget).trigger("blur");
    instance = $.fancybox.getInstance();

    if (instance && instance.$trigger && instance.$trigger.is($target)) {
      return;
    }

    if (opts.selector) {
      items = $(opts.selector);
    } else {
      // Get all related items and find index for clicked one
      value = $target.attr("data-fancybox") || "";

      if (value) {
        items = e.data ? e.data.items : [];
        items = items.length ? items.filter('[data-fancybox="' + value + '"]') : $('[data-fancybox="' + value + '"]');
      } else {
        items = [$target];
      }
    }

    index = $(items).index($target); // Sometimes current item can not be found

    if (index < 0) {
      index = 0;
    }

    instance = $.fancybox.open(items, opts, index); // Save last active element

    instance.$trigger = $target;
  } // Create a jQuery plugin
  // ======================


  $.fn.fancybox = function (options) {
    var selector;
    options = options || {};
    selector = options.selector || false;

    if (selector) {
      // Use body element instead of document so it executes first
      $("body").off("click.fb-start", selector).on("click.fb-start", selector, {
        options: options
      }, _run);
    } else {
      this.off("click.fb-start").on("click.fb-start", {
        items: this,
        options: options
      }, _run);
    }

    return this;
  }; // Self initializing plugin for all elements having `data-fancybox` attribute
  // ==========================================================================


  $D.on("click.fb-start", "[data-fancybox]", _run); // Enable "trigger elements"
  // =========================

  $D.on("click.fb-start", "[data-fancybox-trigger]", function (e) {
    $('[data-fancybox="' + $(this).attr("data-fancybox-trigger") + '"]').eq($(this).attr("data-fancybox-index") || 0).trigger("click.fb-start", {
      $trigger: $(this)
    });
  }); // Track focus event for better accessibility styling
  // ==================================================

  (function () {
    var buttonStr = ".fancybox-button",
        focusStr = "fancybox-focus",
        $pressed = null;
    $D.on("mousedown mouseup focus blur", buttonStr, function (e) {
      switch (e.type) {
        case "mousedown":
          $pressed = $(this);
          break;

        case "mouseup":
          $pressed = null;
          break;

        case "focusin":
          $(buttonStr).removeClass(focusStr);

          if (!$(this).is($pressed) && !$(this).is("[disabled]")) {
            $(this).addClass(focusStr);
          }

          break;

        case "focusout":
          $(buttonStr).removeClass(focusStr);
          break;
      }
    });
  })();
})(window, document, jQuery); // ==========================================================================
//
// Media
// Adds additional media type support
//
// ==========================================================================


(function ($) {
  "use strict"; // Object containing properties for each media type

  var defaults = {
    youtube: {
      matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
      params: {
        autoplay: 1,
        autohide: 1,
        fs: 1,
        rel: 0,
        hd: 1,
        wmode: "transparent",
        enablejsapi: 1,
        html5: 1
      },
      paramPlace: 8,
      type: "iframe",
      url: "https://www.youtube-nocookie.com/embed/$4",
      thumb: "https://img.youtube.com/vi/$4/hqdefault.jpg"
    },
    vimeo: {
      matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
      params: {
        autoplay: 1,
        hd: 1,
        show_title: 1,
        show_byline: 1,
        show_portrait: 0,
        fullscreen: 1
      },
      paramPlace: 3,
      type: "iframe",
      url: "//player.vimeo.com/video/$2"
    },
    instagram: {
      matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
      type: "image",
      url: "//$1/p/$2/media/?size=l"
    },
    // Examples:
    // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16
    // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z
    // https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en
    // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572
    gmap_place: {
      matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
      type: "iframe",
      url: function (rez) {
        return "//maps.google." + rez[2] + "/?ll=" + (rez[9] ? rez[9] + "&z=" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : "") : rez[12] + "").replace(/\?/, "&") + "&output=" + (rez[12] && rez[12].indexOf("layer=c") > 0 ? "svembed" : "embed");
      }
    },
    // Examples:
    // https://www.google.com/maps/search/Empire+State+Building/
    // https://www.google.com/maps/search/?api=1&query=centurylink+field
    // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393
    gmap_search: {
      matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
      type: "iframe",
      url: function (rez) {
        return "//maps.google." + rez[2] + "/maps?q=" + rez[5].replace("query=", "q=").replace("api=1", "") + "&output=embed";
      }
    }
  }; // Formats matching url to final form

  var format = function (url, rez, params) {
    if (!url) {
      return;
    }

    params = params || "";

    if ($.type(params) === "object") {
      params = $.param(params, true);
    }

    $.each(rez, function (key, value) {
      url = url.replace("$" + key, value || "");
    });

    if (params.length) {
      url += (url.indexOf("?") > 0 ? "&" : "?") + params;
    }

    return url;
  };

  $(document).on("objectNeedsType.fb", function (e, instance, item) {
    var url = item.src || "",
        type = false,
        media,
        thumb,
        rez,
        params,
        urlParams,
        paramObj,
        provider;
    media = $.extend(true, {}, defaults, item.opts.media); // Look for any matching media type

    $.each(media, function (providerName, providerOpts) {
      rez = url.match(providerOpts.matcher);

      if (!rez) {
        return;
      }

      type = providerOpts.type;
      provider = providerName;
      paramObj = {};

      if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
        urlParams = rez[providerOpts.paramPlace];

        if (urlParams[0] == "?") {
          urlParams = urlParams.substring(1);
        }

        urlParams = urlParams.split("&");

        for (var m = 0; m < urlParams.length; ++m) {
          var p = urlParams[m].split("=", 2);

          if (p.length == 2) {
            paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
          }
        }
      }

      params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);
      url = $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);
      thumb = $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);

      if (providerName === "youtube") {
        url = url.replace(/&t=((\d+)m)?(\d+)s/, function (match, p1, m, s) {
          return "&start=" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));
        });
      } else if (providerName === "vimeo") {
        url = url.replace("&%23", "#");
      }

      return false;
    }); // If it is found, then change content type and update the url

    if (type) {
      if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
        item.opts.thumb = thumb;
      }

      if (type === "iframe") {
        item.opts = $.extend(true, item.opts, {
          iframe: {
            preload: false,
            attr: {
              scrolling: "no"
            }
          }
        });
      }

      $.extend(item, {
        type: type,
        src: url,
        origSrc: item.src,
        contentSource: provider,
        contentType: type === "image" ? "image" : provider == "gmap_place" || provider == "gmap_search" ? "map" : "video"
      });
    } else if (url) {
      item.type = item.opts.defaultType;
    }
  }); // Load YouTube/Video API on request to detect when video finished playing

  var VideoAPILoader = {
    youtube: {
      src: "https://www.youtube.com/iframe_api",
      class: "YT",
      loading: false,
      loaded: false
    },
    vimeo: {
      src: "https://player.vimeo.com/api/player.js",
      class: "Vimeo",
      loading: false,
      loaded: false
    },
    load: function (vendor) {
      var _this = this,
          script;

      if (this[vendor].loaded) {
        setTimeout(function () {
          _this.done(vendor);
        });
        return;
      }

      if (this[vendor].loading) {
        return;
      }

      this[vendor].loading = true;
      script = document.createElement("script");
      script.type = "text/javascript";
      script.src = this[vendor].src;

      if (vendor === "youtube") {
        window.onYouTubeIframeAPIReady = function () {
          _this[vendor].loaded = true;

          _this.done(vendor);
        };
      } else {
        script.onload = function () {
          _this[vendor].loaded = true;

          _this.done(vendor);
        };
      }

      document.body.appendChild(script);
    },
    done: function (vendor) {
      var instance, $el, player;

      if (vendor === "youtube") {
        delete window.onYouTubeIframeAPIReady;
      }

      instance = $.fancybox.getInstance();

      if (instance) {
        $el = instance.current.$content.find("iframe");

        if (vendor === "youtube" && YT !== undefined && YT) {
          player = new YT.Player($el.attr("id"), {
            events: {
              onStateChange: function (e) {
                if (e.data == 0) {
                  instance.next();
                }
              }
            }
          });
        } else if (vendor === "vimeo" && Vimeo !== undefined && Vimeo) {
          player = new Vimeo.Player($el);
          player.on("ended", function () {
            instance.next();
          });
        }
      }
    }
  };
  $(document).on({
    "afterShow.fb": function (e, instance, current) {
      if (instance.group.length > 1 && (current.contentSource === "youtube" || current.contentSource === "vimeo")) {
        VideoAPILoader.load(current.contentSource);
      }
    }
  });
})(jQuery); // ==========================================================================
//
// Guestures
// Adds touch guestures, handles click and tap events
//
// ==========================================================================


(function (window, document, $) {
  "use strict";

  var requestAFrame = function () {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || // if all else fails, use setTimeout
    function (callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  }();

  var cancelAFrame = function () {
    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {
      window.clearTimeout(id);
    };
  }();

  var getPointerXY = function (e) {
    var result = [];
    e = e.originalEvent || e || window.e;
    e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];

    for (var key in e) {
      if (e[key].pageX) {
        result.push({
          x: e[key].pageX,
          y: e[key].pageY
        });
      } else if (e[key].clientX) {
        result.push({
          x: e[key].clientX,
          y: e[key].clientY
        });
      }
    }

    return result;
  };

  var distance = function (point2, point1, what) {
    if (!point1 || !point2) {
      return 0;
    }

    if (what === "x") {
      return point2.x - point1.x;
    } else if (what === "y") {
      return point2.y - point1.y;
    }

    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
  };

  var isClickable = function ($el) {
    if ($el.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe') || $.isFunction($el.get(0).onclick) || $el.data("selectable")) {
      return true;
    } // Check for attributes like data-fancybox-next or data-fancybox-close


    for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
      if (atts[i].nodeName.substr(0, 14) === "data-fancybox-") {
        return true;
      }
    }

    return false;
  };

  var hasScrollbars = function (el) {
    var overflowY = window.getComputedStyle(el)["overflow-y"],
        overflowX = window.getComputedStyle(el)["overflow-x"],
        vertical = (overflowY === "scroll" || overflowY === "auto") && el.scrollHeight > el.clientHeight,
        horizontal = (overflowX === "scroll" || overflowX === "auto") && el.scrollWidth > el.clientWidth;
    return vertical || horizontal;
  };

  var isScrollable = function ($el) {
    var rez = false;

    while (true) {
      rez = hasScrollbars($el.get(0));

      if (rez) {
        break;
      }

      $el = $el.parent();

      if (!$el.length || $el.hasClass("fancybox-stage") || $el.is("body")) {
        break;
      }
    }

    return rez;
  };

  var Guestures = function (instance) {
    var self = this;
    self.instance = instance;
    self.$bg = instance.$refs.bg;
    self.$stage = instance.$refs.stage;
    self.$container = instance.$refs.container;
    self.destroy();
    self.$container.on("touchstart.fb.touch mousedown.fb.touch", $.proxy(self, "ontouchstart"));
  };

  Guestures.prototype.destroy = function () {
    var self = this;
    self.$container.off(".fb.touch");
    $(document).off(".fb.touch");

    if (self.requestId) {
      cancelAFrame(self.requestId);
      self.requestId = null;
    }

    if (self.tapped) {
      clearTimeout(self.tapped);
      self.tapped = null;
    }
  };

  Guestures.prototype.ontouchstart = function (e) {
    var self = this,
        $target = $(e.target),
        instance = self.instance,
        current = instance.current,
        $slide = current.$slide,
        $content = current.$content,
        isTouchDevice = e.type == "touchstart"; // Do not respond to both (touch and mouse) events

    if (isTouchDevice) {
      self.$container.off("mousedown.fb.touch");
    } // Ignore right click


    if (e.originalEvent && e.originalEvent.button == 2) {
      return;
    } // Ignore taping on links, buttons, input elements


    if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) {
      return;
    } // Ignore clicks on the scrollbar


    if (!$target.is("img") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
      return;
    } // Ignore clicks while zooming or closing


    if (!current || instance.isAnimating || current.$slide.hasClass("fancybox-animated")) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }

    self.realPoints = self.startPoints = getPointerXY(e);

    if (!self.startPoints.length) {
      return;
    } // Allow other scripts to catch touch event if "touch" is set to false


    if (current.touch) {
      e.stopPropagation();
    }

    self.startEvent = e;
    self.canTap = true;
    self.$target = $target;
    self.$content = $content;
    self.opts = current.opts.touch;
    self.isPanning = false;
    self.isSwiping = false;
    self.isZooming = false;
    self.isScrolling = false;
    self.canPan = instance.canPan();
    self.startTime = new Date().getTime();
    self.distanceX = self.distanceY = self.distance = 0;
    self.canvasWidth = Math.round($slide[0].clientWidth);
    self.canvasHeight = Math.round($slide[0].clientHeight);
    self.contentLastPos = null;
    self.contentStartPos = $.fancybox.getTranslate(self.$content) || {
      top: 0,
      left: 0
    };
    self.sliderStartPos = $.fancybox.getTranslate($slide); // Since position will be absolute, but we need to make it relative to the stage

    self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);
    self.sliderStartPos.top -= self.stagePos.top;
    self.sliderStartPos.left -= self.stagePos.left;
    self.contentStartPos.top -= self.stagePos.top;
    self.contentStartPos.left -= self.stagePos.left;
    $(document).off(".fb.touch").on(isTouchDevice ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", $.proxy(self, "ontouchend")).on(isTouchDevice ? "touchmove.fb.touch" : "mousemove.fb.touch", $.proxy(self, "ontouchmove"));

    if ($.fancybox.isMobile) {
      document.addEventListener("scroll", self.onscroll, true);
    } // Skip if clicked outside the sliding area


    if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) {
      if ($target.is(".fancybox-image")) {
        e.preventDefault();
      }

      if (!($.fancybox.isMobile && $target.parents(".fancybox-caption").length)) {
        return;
      }
    }

    self.isScrollable = isScrollable($target) || isScrollable($target.parent()); // Check if element is scrollable and try to prevent default behavior (scrolling)

    if (!($.fancybox.isMobile && self.isScrollable)) {
      e.preventDefault();
    } // One finger or mouse click - swipe or pan an image


    if (self.startPoints.length === 1 || current.hasError) {
      if (self.canPan) {
        $.fancybox.stop(self.$content);
        self.isPanning = true;
      } else {
        self.isSwiping = true;
      }

      self.$container.addClass("fancybox-is-grabbing");
    } // Two fingers - zoom image


    if (self.startPoints.length === 2 && current.type === "image" && (current.isLoaded || current.$ghost)) {
      self.canTap = false;
      self.isSwiping = false;
      self.isPanning = false;
      self.isZooming = true;
      $.fancybox.stop(self.$content);
      self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();
      self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();
      self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;
      self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;
      self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
    }
  };

  Guestures.prototype.onscroll = function (e) {
    var self = this;
    self.isScrolling = true;
    document.removeEventListener("scroll", self.onscroll, true);
  };

  Guestures.prototype.ontouchmove = function (e) {
    var self = this; // Make sure user has not released over iframe or disabled element

    if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {
      self.ontouchend(e);
      return;
    }

    if (self.isScrolling) {
      self.canTap = false;
      return;
    }

    self.newPoints = getPointerXY(e);

    if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) {
      return;
    }

    if (!(self.isSwiping && self.isSwiping === true)) {
      e.preventDefault();
    }

    self.distanceX = distance(self.newPoints[0], self.startPoints[0], "x");
    self.distanceY = distance(self.newPoints[0], self.startPoints[0], "y");
    self.distance = distance(self.newPoints[0], self.startPoints[0]); // Skip false ontouchmove events (Chrome)

    if (self.distance > 0) {
      if (self.isSwiping) {
        self.onSwipe(e);
      } else if (self.isPanning) {
        self.onPan();
      } else if (self.isZooming) {
        self.onZoom();
      }
    }
  };

  Guestures.prototype.onSwipe = function (e) {
    var self = this,
        instance = self.instance,
        swiping = self.isSwiping,
        left = self.sliderStartPos.left || 0,
        angle; // If direction is not yet determined

    if (swiping === true) {
      // We need at least 10px distance to correctly calculate an angle
      if (Math.abs(self.distance) > 10) {
        self.canTap = false;

        if (instance.group.length < 2 && self.opts.vertical) {
          self.isSwiping = "y";
        } else if (instance.isDragging || self.opts.vertical === false || self.opts.vertical === "auto" && $(window).width() > 800) {
          self.isSwiping = "x";
        } else {
          angle = Math.abs(Math.atan2(self.distanceY, self.distanceX) * 180 / Math.PI);
          self.isSwiping = angle > 45 && angle < 135 ? "y" : "x";
        }

        if (self.isSwiping === "y" && $.fancybox.isMobile && self.isScrollable) {
          self.isScrolling = true;
          return;
        }

        instance.isDragging = self.isSwiping; // Reset points to avoid jumping, because we dropped first swipes to calculate the angle

        self.startPoints = self.newPoints;
        $.each(instance.slides, function (index, slide) {
          var slidePos, stagePos;
          $.fancybox.stop(slide.$slide);
          slidePos = $.fancybox.getTranslate(slide.$slide);
          stagePos = $.fancybox.getTranslate(instance.$refs.stage);
          slide.$slide.css({
            transform: "",
            opacity: "",
            "transition-duration": ""
          }).removeClass("fancybox-animated").removeClass(function (index, className) {
            return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
          });

          if (slide.pos === instance.current.pos) {
            self.sliderStartPos.top = slidePos.top - stagePos.top;
            self.sliderStartPos.left = slidePos.left - stagePos.left;
          }

          $.fancybox.setTranslate(slide.$slide, {
            top: slidePos.top - stagePos.top,
            left: slidePos.left - stagePos.left
          });
        }); // Stop slideshow

        if (instance.SlideShow && instance.SlideShow.isActive) {
          instance.SlideShow.stop();
        }
      }

      return;
    } // Sticky edges


    if (swiping == "x") {
      if (self.distanceX > 0 && (self.instance.group.length < 2 || self.instance.current.index === 0 && !self.instance.current.opts.loop)) {
        left = left + Math.pow(self.distanceX, 0.8);
      } else if (self.distanceX < 0 && (self.instance.group.length < 2 || self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop)) {
        left = left - Math.pow(-self.distanceX, 0.8);
      } else {
        left = left + self.distanceX;
      }
    }

    self.sliderLastPos = {
      top: swiping == "x" ? 0 : self.sliderStartPos.top + self.distanceY,
      left: left
    };

    if (self.requestId) {
      cancelAFrame(self.requestId);
      self.requestId = null;
    }

    self.requestId = requestAFrame(function () {
      if (self.sliderLastPos) {
        $.each(self.instance.slides, function (index, slide) {
          var pos = slide.pos - self.instance.currPos;
          $.fancybox.setTranslate(slide.$slide, {
            top: self.sliderLastPos.top,
            left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter
          });
        });
        self.$container.addClass("fancybox-is-sliding");
      }
    });
  };

  Guestures.prototype.onPan = function () {
    var self = this; // Prevent accidental movement (sometimes, when tapping casually, finger can move a bit)

    if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {
      self.startPoints = self.newPoints;
      return;
    }

    self.canTap = false;
    self.contentLastPos = self.limitMovement();

    if (self.requestId) {
      cancelAFrame(self.requestId);
    }

    self.requestId = requestAFrame(function () {
      $.fancybox.setTranslate(self.$content, self.contentLastPos);
    });
  }; // Make panning sticky to the edges


  Guestures.prototype.limitMovement = function () {
    var self = this;
    var canvasWidth = self.canvasWidth;
    var canvasHeight = self.canvasHeight;
    var distanceX = self.distanceX;
    var distanceY = self.distanceY;
    var contentStartPos = self.contentStartPos;
    var currentOffsetX = contentStartPos.left;
    var currentOffsetY = contentStartPos.top;
    var currentWidth = contentStartPos.width;
    var currentHeight = contentStartPos.height;
    var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;

    if (currentWidth > canvasWidth) {
      newOffsetX = currentOffsetX + distanceX;
    } else {
      newOffsetX = currentOffsetX;
    }

    newOffsetY = currentOffsetY + distanceY; // Slow down proportionally to traveled distance

    minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);
    minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);
    maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);
    maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5); //   ->

    if (distanceX > 0 && newOffsetX > minTranslateX) {
      newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
    } //    <-


    if (distanceX < 0 && newOffsetX < maxTranslateX) {
      newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
    } //   \/


    if (distanceY > 0 && newOffsetY > minTranslateY) {
      newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
    } //   /\


    if (distanceY < 0 && newOffsetY < maxTranslateY) {
      newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
    }

    return {
      top: newOffsetY,
      left: newOffsetX
    };
  };

  Guestures.prototype.limitPosition = function (newOffsetX, newOffsetY, newWidth, newHeight) {
    var self = this;
    var canvasWidth = self.canvasWidth;
    var canvasHeight = self.canvasHeight;

    if (newWidth > canvasWidth) {
      newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
      newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;
    } else {
      // Center horizontally
      newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);
    }

    if (newHeight > canvasHeight) {
      newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
      newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;
    } else {
      // Center vertically
      newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);
    }

    return {
      top: newOffsetY,
      left: newOffsetX
    };
  };

  Guestures.prototype.onZoom = function () {
    var self = this; // Calculate current distance between points to get pinch ratio and new width and height

    var contentStartPos = self.contentStartPos;
    var currentWidth = contentStartPos.width;
    var currentHeight = contentStartPos.height;
    var currentOffsetX = contentStartPos.left;
    var currentOffsetY = contentStartPos.top;
    var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);
    var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;
    var newWidth = Math.floor(currentWidth * pinchRatio);
    var newHeight = Math.floor(currentHeight * pinchRatio); // This is the translation due to pinch-zooming

    var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
    var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY; // Point between the two touches

    var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft();
    var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop(); // And this is the translation due to translation of the centerpoint
    // between the two fingers

    var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
    var translateFromTranslatingY = centerPointEndY - self.centerPointStartY; // The new offset is the old/current one plus the total translation

    var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
    var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);
    var newPos = {
      top: newOffsetY,
      left: newOffsetX,
      scaleX: pinchRatio,
      scaleY: pinchRatio
    };
    self.canTap = false;
    self.newWidth = newWidth;
    self.newHeight = newHeight;
    self.contentLastPos = newPos;

    if (self.requestId) {
      cancelAFrame(self.requestId);
    }

    self.requestId = requestAFrame(function () {
      $.fancybox.setTranslate(self.$content, self.contentLastPos);
    });
  };

  Guestures.prototype.ontouchend = function (e) {
    var self = this;
    var swiping = self.isSwiping;
    var panning = self.isPanning;
    var zooming = self.isZooming;
    var scrolling = self.isScrolling;
    self.endPoints = getPointerXY(e);
    self.dMs = Math.max(new Date().getTime() - self.startTime, 1);
    self.$container.removeClass("fancybox-is-grabbing");
    $(document).off(".fb.touch");
    document.removeEventListener("scroll", self.onscroll, true);

    if (self.requestId) {
      cancelAFrame(self.requestId);
      self.requestId = null;
    }

    self.isSwiping = false;
    self.isPanning = false;
    self.isZooming = false;
    self.isScrolling = false;
    self.instance.isDragging = false;

    if (self.canTap) {
      return self.onTap(e);
    }

    self.speed = 100; // Speed in px/ms

    self.velocityX = self.distanceX / self.dMs * 0.5;
    self.velocityY = self.distanceY / self.dMs * 0.5;

    if (panning) {
      self.endPanning();
    } else if (zooming) {
      self.endZooming();
    } else {
      self.endSwiping(swiping, scrolling);
    }

    return;
  };

  Guestures.prototype.endSwiping = function (swiping, scrolling) {
    var self = this,
        ret = false,
        len = self.instance.group.length,
        distanceX = Math.abs(self.distanceX),
        canAdvance = swiping == "x" && len > 1 && (self.dMs > 130 && distanceX > 10 || distanceX > 50),
        speedX = 300;
    self.sliderLastPos = null; // Close if swiped vertically / navigate if horizontally

    if (swiping == "y" && !scrolling && Math.abs(self.distanceY) > 50) {
      // Continue vertical movement
      $.fancybox.animate(self.instance.current.$slide, {
        top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,
        opacity: 0
      }, 200);
      ret = self.instance.close(true, 250);
    } else if (canAdvance && self.distanceX > 0) {
      ret = self.instance.previous(speedX);
    } else if (canAdvance && self.distanceX < 0) {
      ret = self.instance.next(speedX);
    }

    if (ret === false && (swiping == "x" || swiping == "y")) {
      self.instance.centerSlide(200);
    }

    self.$container.removeClass("fancybox-is-sliding");
  }; // Limit panning from edges
  // ========================


  Guestures.prototype.endPanning = function () {
    var self = this,
        newOffsetX,
        newOffsetY,
        newPos;

    if (!self.contentLastPos) {
      return;
    }

    if (self.opts.momentum === false || self.dMs > 350) {
      newOffsetX = self.contentLastPos.left;
      newOffsetY = self.contentLastPos.top;
    } else {
      // Continue movement
      newOffsetX = self.contentLastPos.left + self.velocityX * 500;
      newOffsetY = self.contentLastPos.top + self.velocityY * 500;
    }

    newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);
    newPos.width = self.contentStartPos.width;
    newPos.height = self.contentStartPos.height;
    $.fancybox.animate(self.$content, newPos, 366);
  };

  Guestures.prototype.endZooming = function () {
    var self = this;
    var current = self.instance.current;
    var newOffsetX, newOffsetY, newPos, reset;
    var newWidth = self.newWidth;
    var newHeight = self.newHeight;

    if (!self.contentLastPos) {
      return;
    }

    newOffsetX = self.contentLastPos.left;
    newOffsetY = self.contentLastPos.top;
    reset = {
      top: newOffsetY,
      left: newOffsetX,
      width: newWidth,
      height: newHeight,
      scaleX: 1,
      scaleY: 1
    }; // Reset scalex/scaleY values; this helps for perfomance and does not break animation

    $.fancybox.setTranslate(self.$content, reset);

    if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
      self.instance.scaleToFit(150);
    } else if (newWidth > current.width || newHeight > current.height) {
      self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);
    } else {
      newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);
      $.fancybox.animate(self.$content, newPos, 150);
    }
  };

  Guestures.prototype.onTap = function (e) {
    var self = this;
    var $target = $(e.target);
    var instance = self.instance;
    var current = instance.current;
    var endPoints = e && getPointerXY(e) || self.startPoints;
    var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;
    var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;
    var where;

    var process = function (prefix) {
      var action = current.opts[prefix];

      if ($.isFunction(action)) {
        action = action.apply(instance, [current, e]);
      }

      if (!action) {
        return;
      }

      switch (action) {
        case "close":
          instance.close(self.startEvent);
          break;

        case "toggleControls":
          instance.toggleControls();
          break;

        case "next":
          instance.next();
          break;

        case "nextOrClose":
          if (instance.group.length > 1) {
            instance.next();
          } else {
            instance.close(self.startEvent);
          }

          break;

        case "zoom":
          if (current.type == "image" && (current.isLoaded || current.$ghost)) {
            if (instance.canPan()) {
              instance.scaleToFit();
            } else if (instance.isScaledDown()) {
              instance.scaleToActual(tapX, tapY);
            } else if (instance.group.length < 2) {
              instance.close(self.startEvent);
            }
          }

          break;
      }
    }; // Ignore right click


    if (e.originalEvent && e.originalEvent.button == 2) {
      return;
    } // Skip if clicked on the scrollbar


    if (!$target.is("img") && tapX > $target[0].clientWidth + $target.offset().left) {
      return;
    } // Check where is clicked


    if ($target.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) {
      where = "Outside";
    } else if ($target.is(".fancybox-slide")) {
      where = "Slide";
    } else if (instance.current.$content && instance.current.$content.find($target).addBack().filter($target).length) {
      where = "Content";
    } else {
      return;
    } // Check if this is a double tap


    if (self.tapped) {
      // Stop previously created single tap
      clearTimeout(self.tapped);
      self.tapped = null; // Skip if distance between taps is too big

      if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {
        return this;
      } // OK, now we assume that this is a double-tap


      process("dblclick" + where);
    } else {
      // Single tap will be processed if user has not clicked second time within 300ms
      // or there is no need to wait for double-tap
      self.tapX = tapX;
      self.tapY = tapY;

      if (current.opts["dblclick" + where] && current.opts["dblclick" + where] !== current.opts["click" + where]) {
        self.tapped = setTimeout(function () {
          self.tapped = null;

          if (!instance.isAnimating) {
            process("click" + where);
          }
        }, 500);
      } else {
        process("click" + where);
      }
    }

    return this;
  };

  $(document).on("onActivate.fb", function (e, instance) {
    if (instance && !instance.Guestures) {
      instance.Guestures = new Guestures(instance);
    }
  }).on("beforeClose.fb", function (e, instance) {
    if (instance && instance.Guestures) {
      instance.Guestures.destroy();
    }
  });
})(window, document, jQuery); // ==========================================================================
//
// SlideShow
// Enables slideshow functionality
//
// Example of usage:
// $.fancybox.getInstance().SlideShow.start()
//
// ==========================================================================


(function (document, $) {
  "use strict";

  $.extend(true, $.fancybox.defaults, {
    btnTpl: {
      slideShow: '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg>' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg>' + "</button>"
    },
    slideShow: {
      autoStart: false,
      speed: 3000,
      progress: true
    }
  });

  var SlideShow = function (instance) {
    this.instance = instance;
    this.init();
  };

  $.extend(SlideShow.prototype, {
    timer: null,
    isActive: false,
    $button: null,
    init: function () {
      var self = this,
          instance = self.instance,
          opts = instance.group[instance.currIndex].opts.slideShow;
      self.$button = instance.$refs.toolbar.find("[data-fancybox-play]").on("click", function () {
        self.toggle();
      });

      if (instance.group.length < 2 || !opts) {
        self.$button.hide();
      } else if (opts.progress) {
        self.$progress = $('<div class="fancybox-progress"></div>').appendTo(instance.$refs.inner);
      }
    },
    set: function (force) {
      var self = this,
          instance = self.instance,
          current = instance.current; // Check if reached last element

      if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) {
        if (self.isActive && current.contentType !== "video") {
          if (self.$progress) {
            $.fancybox.animate(self.$progress.show(), {
              scaleX: 1
            }, current.opts.slideShow.speed);
          }

          self.timer = setTimeout(function () {
            if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) {
              instance.jumpTo(0);
            } else {
              instance.next();
            }
          }, current.opts.slideShow.speed);
        }
      } else {
        self.stop();
        instance.idleSecondsCounter = 0;
        instance.showControls();
      }
    },
    clear: function () {
      var self = this;
      clearTimeout(self.timer);
      self.timer = null;

      if (self.$progress) {
        self.$progress.removeAttr("style").hide();
      }
    },
    start: function () {
      var self = this,
          current = self.instance.current;

      if (current) {
        self.$button.attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP).removeClass("fancybox-button--play").addClass("fancybox-button--pause");
        self.isActive = true;

        if (current.isComplete) {
          self.set(true);
        }

        self.instance.trigger("onSlideShowChange", true);
      }
    },
    stop: function () {
      var self = this,
          current = self.instance.current;
      self.clear();
      self.$button.attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START).removeClass("fancybox-button--pause").addClass("fancybox-button--play");
      self.isActive = false;
      self.instance.trigger("onSlideShowChange", false);

      if (self.$progress) {
        self.$progress.removeAttr("style").hide();
      }
    },
    toggle: function () {
      var self = this;

      if (self.isActive) {
        self.stop();
      } else {
        self.start();
      }
    }
  });
  $(document).on({
    "onInit.fb": function (e, instance) {
      if (instance && !instance.SlideShow) {
        instance.SlideShow = new SlideShow(instance);
      }
    },
    "beforeShow.fb": function (e, instance, current, firstRun) {
      var SlideShow = instance && instance.SlideShow;

      if (firstRun) {
        if (SlideShow && current.opts.slideShow.autoStart) {
          SlideShow.start();
        }
      } else if (SlideShow && SlideShow.isActive) {
        SlideShow.clear();
      }
    },
    "afterShow.fb": function (e, instance, current) {
      var SlideShow = instance && instance.SlideShow;

      if (SlideShow && SlideShow.isActive) {
        SlideShow.set();
      }
    },
    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {
      var SlideShow = instance && instance.SlideShow; // "P" or Spacebar

      if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is("button,a,input")) {
        keypress.preventDefault();
        SlideShow.toggle();
      }
    },
    "beforeClose.fb onDeactivate.fb": function (e, instance) {
      var SlideShow = instance && instance.SlideShow;

      if (SlideShow) {
        SlideShow.stop();
      }
    }
  }); // Page Visibility API to pause slideshow when window is not active

  $(document).on("visibilitychange", function () {
    var instance = $.fancybox.getInstance(),
        SlideShow = instance && instance.SlideShow;

    if (SlideShow && SlideShow.isActive) {
      if (document.hidden) {
        SlideShow.clear();
      } else {
        SlideShow.set();
      }
    }
  });
})(document, jQuery); // ==========================================================================
//
// FullScreen
// Adds fullscreen functionality
//
// ==========================================================================


(function (document, $) {
  "use strict"; // Collection of methods supported by user browser

  var fn = function () {
    var fnMap = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], // new WebKit
    ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], // old WebKit (Safari 5.1)
    ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]];
    var ret = {};

    for (var i = 0; i < fnMap.length; i++) {
      var val = fnMap[i];

      if (val && val[1] in document) {
        for (var j = 0; j < val.length; j++) {
          ret[fnMap[0][j]] = val[j];
        }

        return ret;
      }
    }

    return false;
  }();

  if (fn) {
    var FullScreen = {
      request: function (elem) {
        elem = elem || document.documentElement;
        elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);
      },
      exit: function () {
        document[fn.exitFullscreen]();
      },
      toggle: function (elem) {
        elem = elem || document.documentElement;

        if (this.isFullscreen()) {
          this.exit();
        } else {
          this.request(elem);
        }
      },
      isFullscreen: function () {
        return Boolean(document[fn.fullscreenElement]);
      },
      enabled: function () {
        return Boolean(document[fn.fullscreenEnabled]);
      }
    };
    $.extend(true, $.fancybox.defaults, {
      btnTpl: {
        fullScreen: '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg>' + "</button>"
      },
      fullScreen: {
        autoStart: false
      }
    });
    $(document).on(fn.fullscreenchange, function () {
      var isFullscreen = FullScreen.isFullscreen(),
          instance = $.fancybox.getInstance();

      if (instance) {
        // If image is zooming, then force to stop and reposition properly
        if (instance.current && instance.current.type === "image" && instance.isAnimating) {
          instance.isAnimating = false;
          instance.update(true, true, 0);

          if (!instance.isComplete) {
            instance.complete();
          }
        }

        instance.trigger("onFullscreenChange", isFullscreen);
        instance.$refs.container.toggleClass("fancybox-is-fullscreen", isFullscreen);
        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").toggleClass("fancybox-button--fsenter", !isFullscreen).toggleClass("fancybox-button--fsexit", isFullscreen);
      }
    });
  }

  $(document).on({
    "onInit.fb": function (e, instance) {
      var $container;

      if (!fn) {
        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();
        return;
      }

      if (instance && instance.group[instance.currIndex].opts.fullScreen) {
        $container = instance.$refs.container;
        $container.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function (e) {
          e.stopPropagation();
          e.preventDefault();
          FullScreen.toggle();
        });

        if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
          FullScreen.request();
        } // Expose API


        instance.FullScreen = FullScreen;
      } else if (instance) {
        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").hide();
      }
    },
    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {
      // "F"
      if (instance && instance.FullScreen && keycode === 70) {
        keypress.preventDefault();
        instance.FullScreen.toggle();
      }
    },
    "beforeClose.fb": function (e, instance) {
      if (instance && instance.FullScreen && instance.$refs.container.hasClass("fancybox-is-fullscreen")) {
        FullScreen.exit();
      }
    }
  });
})(document, jQuery); // ==========================================================================
//
// Thumbs
// Displays thumbnails in a grid
//
// ==========================================================================


(function (document, $) {
  "use strict";

  var CLASS = "fancybox-thumbs",
      CLASS_ACTIVE = CLASS + "-active"; // Make sure there are default values

  $.fancybox.defaults = $.extend(true, {
    btnTpl: {
      thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg>' + "</button>"
    },
    thumbs: {
      autoStart: false,
      // Display thumbnails on opening
      hideOnClose: true,
      // Hide thumbnail grid when closing animation starts
      parentEl: ".fancybox-container",
      // Container is injected into this element
      axis: "y" // Vertical (y) or horizontal (x) scrolling

    }
  }, $.fancybox.defaults);

  var FancyThumbs = function (instance) {
    this.init(instance);
  };

  $.extend(FancyThumbs.prototype, {
    $button: null,
    $grid: null,
    $list: null,
    isVisible: false,
    isActive: false,
    init: function (instance) {
      var self = this,
          group = instance.group,
          enabled = 0;
      self.instance = instance;
      self.opts = group[instance.currIndex].opts.thumbs;
      instance.Thumbs = self;
      self.$button = instance.$refs.toolbar.find("[data-fancybox-thumbs]"); // Enable thumbs if at least two group items have thumbnails

      for (var i = 0, len = group.length; i < len; i++) {
        if (group[i].thumb) {
          enabled++;
        }

        if (enabled > 1) {
          break;
        }
      }

      if (enabled > 1 && !!self.opts) {
        self.$button.removeAttr("style").on("click", function () {
          self.toggle();
        });
        self.isActive = true;
      } else {
        self.$button.hide();
      }
    },
    create: function () {
      var self = this,
          instance = self.instance,
          parentEl = self.opts.parentEl,
          list = [],
          src;

      if (!self.$grid) {
        // Create main element
        self.$grid = $('<div class="' + CLASS + " " + CLASS + "-" + self.opts.axis + '"></div>').appendTo(instance.$refs.container.find(parentEl).addBack().filter(parentEl)); // Add "click" event that performs gallery navigation

        self.$grid.on("click", "a", function () {
          instance.jumpTo($(this).attr("data-index"));
        });
      } // Build the list


      if (!self.$list) {
        self.$list = $('<div class="' + CLASS + '__list">').appendTo(self.$grid);
      }

      $.each(instance.group, function (i, item) {
        src = item.thumb;

        if (!src && item.type === "image") {
          src = item.src;
        }

        list.push('<a href="javascript:;" tabindex="0" data-index="' + i + '"' + (src && src.length ? ' style="background-image:url(' + src + ')"' : 'class="fancybox-thumbs-missing"') + "></a>");
      });
      self.$list[0].innerHTML = list.join("");

      if (self.opts.axis === "x") {
        // Set fixed width for list element to enable horizontal scrolling
        self.$list.width(parseInt(self.$grid.css("padding-right"), 10) + instance.group.length * self.$list.children().eq(0).outerWidth(true));
      }
    },
    focus: function (duration) {
      var self = this,
          $list = self.$list,
          $grid = self.$grid,
          thumb,
          thumbPos;

      if (!self.instance.current) {
        return;
      }

      thumb = $list.children().removeClass(CLASS_ACTIVE).filter('[data-index="' + self.instance.current.index + '"]').addClass(CLASS_ACTIVE);
      thumbPos = thumb.position(); // Check if need to scroll to make current thumb visible

      if (self.opts.axis === "y" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {
        $list.stop().animate({
          scrollTop: $list.scrollTop() + thumbPos.top
        }, duration);
      } else if (self.opts.axis === "x" && (thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))) {
        $list.parent().stop().animate({
          scrollLeft: thumbPos.left
        }, duration);
      }
    },
    update: function () {
      var that = this;
      that.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible);

      if (that.isVisible) {
        if (!that.$grid) {
          that.create();
        }

        that.instance.trigger("onThumbsShow");
        that.focus(0);
      } else if (that.$grid) {
        that.instance.trigger("onThumbsHide");
      } // Update content position


      that.instance.update();
    },
    hide: function () {
      this.isVisible = false;
      this.update();
    },
    show: function () {
      this.isVisible = true;
      this.update();
    },
    toggle: function () {
      this.isVisible = !this.isVisible;
      this.update();
    }
  });
  $(document).on({
    "onInit.fb": function (e, instance) {
      var Thumbs;

      if (instance && !instance.Thumbs) {
        Thumbs = new FancyThumbs(instance);

        if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
          Thumbs.show();
        }
      }
    },
    "beforeShow.fb": function (e, instance, item, firstRun) {
      var Thumbs = instance && instance.Thumbs;

      if (Thumbs && Thumbs.isVisible) {
        Thumbs.focus(firstRun ? 0 : 250);
      }
    },
    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {
      var Thumbs = instance && instance.Thumbs; // "G"

      if (Thumbs && Thumbs.isActive && keycode === 71) {
        keypress.preventDefault();
        Thumbs.toggle();
      }
    },
    "beforeClose.fb": function (e, instance) {
      var Thumbs = instance && instance.Thumbs;

      if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
        Thumbs.$grid.hide();
      }
    }
  });
})(document, jQuery); //// ==========================================================================
//
// Share
// Displays simple form for sharing current url
//
// ==========================================================================


(function (document, $) {
  "use strict";

  $.extend(true, $.fancybox.defaults, {
    btnTpl: {
      share: '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">' + '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg>' + "</button>"
    },
    share: {
      url: function (instance, item) {
        return (!instance.currentHash && !(item.type === "inline" || item.type === "html") ? item.origSrc || item.src : false) || window.location;
      },
      tpl: '<div class="fancybox-share">' + "<h1>{{SHARE}}</h1>" + "<p>" + '<a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}">' + '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg>' + "<span>Facebook</span>" + "</a>" + '<a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}">' + '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg>' + "<span>Twitter</span>" + "</a>" + '<a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}">' + '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>' + "<span>Pinterest</span>" + "</a>" + "</p>" + '<p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p>' + "</div>"
    }
  });

  function escapeHtml(string) {
    var entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    return String(string).replace(/[&<>"'`=\/]/g, function (s) {
      return entityMap[s];
    });
  }

  $(document).on("click", "[data-fancybox-share]", function () {
    var instance = $.fancybox.getInstance(),
        current = instance.current || null,
        url,
        tpl;

    if (!current) {
      return;
    }

    if ($.type(current.opts.share.url) === "function") {
      url = current.opts.share.url.apply(current, [instance, current]);
    }

    tpl = current.opts.share.tpl.replace(/\{\{media\}\}/g, current.type === "image" ? encodeURIComponent(current.src) : "").replace(/\{\{url\}\}/g, encodeURIComponent(url)).replace(/\{\{url_raw\}\}/g, escapeHtml(url)).replace(/\{\{descr\}\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : "");
    $.fancybox.open({
      src: instance.translate(instance, tpl),
      type: "html",
      opts: {
        touch: false,
        animationEffect: false,
        afterLoad: function (shareInstance, shareCurrent) {
          // Close self if parent instance is closing
          instance.$refs.container.one("beforeClose.fb", function () {
            shareInstance.close(null, 0);
          }); // Opening links in a popup window

          shareCurrent.$content.find(".fancybox-share__button").click(function () {
            window.open(this.href, "Share", "width=550, height=450");
            return false;
          });
        },
        mobile: {
          autoFocus: false
        }
      }
    });
  });
})(document, jQuery); // ==========================================================================
//
// Hash
// Enables linking to each modal
//
// ==========================================================================


(function (window, document, $) {
  "use strict"; // Simple $.escapeSelector polyfill (for jQuery prior v3)

  if (!$.escapeSelector) {
    $.escapeSelector = function (sel) {
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

      var fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          } // Control characters and (dependent upon position) numbers get escaped as code points


          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        } // Other potentially-special ASCII characters get backslash-escaped


        return "\\" + ch;
      };

      return (sel + "").replace(rcssescape, fcssescape);
    };
  } // Get info about gallery name and current index from url


  function parseUrl() {
    var hash = window.location.hash.substr(1),
        rez = hash.split("-"),
        index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,
        gallery = rez.join("-");
    return {
      hash: hash,

      /* Index is starting from 1 */
      index: index < 1 ? 1 : index,
      gallery: gallery
    };
  } // Trigger click evnt on links to open new fancyBox instance


  function triggerFromUrl(url) {
    if (url.gallery !== "") {
      // If we can find element matching 'data-fancybox' atribute,
      // then triggering click event should start fancyBox
      $("[data-fancybox='" + $.escapeSelector(url.gallery) + "']").eq(url.index - 1).focus().trigger("click.fb-start");
    }
  } // Get gallery name from current instance


  function getGalleryID(instance) {
    var opts, ret;

    if (!instance) {
      return false;
    }

    opts = instance.current ? instance.current.opts : instance.opts;
    ret = opts.hash || (opts.$orig ? opts.$orig.data("fancybox") || opts.$orig.data("fancybox-trigger") : "");
    return ret === "" ? false : ret;
  } // Start when DOM becomes ready


  $(function () {
    // Check if user has disabled this module
    if ($.fancybox.defaults.hash === false) {
      return;
    } // Update hash when opening/closing fancyBox


    $(document).on({
      "onInit.fb": function (e, instance) {
        var url, gallery;

        if (instance.group[instance.currIndex].opts.hash === false) {
          return;
        }

        url = parseUrl();
        gallery = getGalleryID(instance); // Make sure gallery start index matches index from hash

        if (gallery && url.gallery && gallery == url.gallery) {
          instance.currIndex = url.index - 1;
        }
      },
      "beforeShow.fb": function (e, instance, current, firstRun) {
        var gallery;

        if (!current || current.opts.hash === false) {
          return;
        } // Check if need to update window hash


        gallery = getGalleryID(instance);

        if (!gallery) {
          return;
        } // Variable containing last hash value set by fancyBox
        // It will be used to determine if fancyBox needs to close after hash change is detected


        instance.currentHash = gallery + (instance.group.length > 1 ? "-" + (current.index + 1) : ""); // If current hash is the same (this instance most likely is opened by hashchange), then do nothing

        if (window.location.hash === "#" + instance.currentHash) {
          return;
        }

        if (firstRun && !instance.origHash) {
          instance.origHash = window.location.hash;
        }

        if (instance.hashTimer) {
          clearTimeout(instance.hashTimer);
        } // Update hash


        instance.hashTimer = setTimeout(function () {
          if ("replaceState" in window.history) {
            window.history[firstRun ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + "#" + instance.currentHash);

            if (firstRun) {
              instance.hasCreatedHistory = true;
            }
          } else {
            window.location.hash = instance.currentHash;
          }

          instance.hashTimer = null;
        }, 300);
      },
      "beforeClose.fb": function (e, instance, current) {
        if (!current || current.opts.hash === false) {
          return;
        }

        clearTimeout(instance.hashTimer); // Goto previous history entry

        if (instance.currentHash && instance.hasCreatedHistory) {
          window.history.back();
        } else if (instance.currentHash) {
          if ("replaceState" in window.history) {
            window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || ""));
          } else {
            window.location.hash = instance.origHash;
          }
        }

        instance.currentHash = null;
      }
    }); // Check if need to start/close after url has changed

    $(window).on("hashchange.fb", function () {
      var url = parseUrl(),
          fb = null; // Find last fancyBox instance that has "hash"

      $.each($(".fancybox-container").get().reverse(), function (index, value) {
        var tmp = $(value).data("FancyBox");

        if (tmp && tmp.currentHash) {
          fb = tmp;
          return false;
        }
      });

      if (fb) {
        // Now, compare hash values
        if (fb.currentHash !== url.gallery + "-" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {
          fb.currentHash = null;
          fb.close();
        }
      } else if (url.gallery !== "") {
        triggerFromUrl(url);
      }
    }); // Check current hash and trigger click event on matching element to start fancyBox, if needed

    setTimeout(function () {
      if (!$.fancybox.getInstance()) {
        triggerFromUrl(parseUrl());
      }
    }, 50);
  });
})(window, document, jQuery); // ==========================================================================
//
// Wheel
// Basic mouse weheel support for gallery navigation
//
// ==========================================================================


(function (document, $) {
  "use strict";

  var prevTime = new Date().getTime();
  $(document).on({
    "onInit.fb": function (e, instance, current) {
      instance.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function (e) {
        var current = instance.current,
            currTime = new Date().getTime();

        if (instance.group.length < 2 || current.opts.wheel === false || current.opts.wheel === "auto" && current.type !== "image") {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (current.$slide.hasClass("fancybox-animated")) {
          return;
        }

        e = e.originalEvent || e;

        if (currTime - prevTime < 250) {
          return;
        }

        prevTime = currTime;
        instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? "next" : "previous"]();
      });
    }
  });
})(document, jQuery);

/***/ }),
/* 450 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = toTop;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_helpers__ = __webpack_require__(8);

function toTop() {
  var btnToTop = document.querySelector('.go-to-top');

  if (btnToTop === null) {
    return;
  }

  var btnToTopLink = btnToTop.querySelector('a');
  var newsletter = document.querySelector('.newsletter'); // sets the button position

  function setBtnPosition(scroll, btnHeight) {
    var newsletterHeight = __WEBPACK_IMPORTED_MODULE_0__js_helpers__["t" /* outerHeight */](newsletter);

    if (scroll) {
      btnToTop.style.position = 'fixed';
      btnToTop.style.bottom = "".concat(btnHeight, "px");
    } else {
      btnToTop.style.position = 'absolute';
      btnToTop.style.bottom = "".concat(newsletterHeight + btnHeight / 2, "px");
    }
  } // smooth scroll to top


  function runScrollAnimation(scrollDuration) {
    var scrollStep = -window.pageYOffset / (scrollDuration / 10);
    var scrollInterval = setInterval(function () {
      if (window.pageYOffset !== 0) {
        window.scrollBy(0, scrollStep);
      } else clearInterval(scrollInterval);
    }, 15);
  } // hides the button if the scroll is at the top


  function setBtnDisplay(style) {
    if (style) {
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](btnToTop, '-is-hide');
    } else {
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](btnToTop, '-is-hide');
    }
  }

  function setGoToTop() {
    var documentHeight = document.body.clientHeight;
    var scrollPosition = window.pageYOffset + window.innerHeight;
    var newsletterHeight = __WEBPACK_IMPORTED_MODULE_0__js_helpers__["t" /* outerHeight */](newsletter);
    var btnHeight = __WEBPACK_IMPORTED_MODULE_0__js_helpers__["t" /* outerHeight */](btnToTopLink);

    if (window.pageYOffset) {
      setBtnDisplay(true);
    } else {
      setBtnDisplay(false);
    }

    if (scrollPosition < documentHeight - (newsletterHeight - btnHeight / 2)) {
      setBtnPosition(true, btnHeight);
    } else {
      setBtnPosition(false, btnHeight);
    }
  }

  if (btnToTop) {
    window.addEventListener('scroll', __WEBPACK_IMPORTED_MODULE_0__js_helpers__["C" /* throttle */](function () {
      setGoToTop();
    }, 150));
    window.addEventListener('resize', __WEBPACK_IMPORTED_MODULE_0__js_helpers__["C" /* throttle */](function () {
      setGoToTop();
    }, 150));
    btnToTop.addEventListener('click', function (event) {
      event.preventDefault();
      runScrollAnimation(500);
    });
  }
}

/***/ }),
/* 451 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = flashInfoLocalstorage;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_helpers__ = __webpack_require__(8);

function flashInfoLocalstorage() {
  var flashInfo = document.querySelector('.flash-info');

  if (flashInfo === null) {
    return;
  }

  var flashInfoItems = flashInfo.querySelectorAll('.flash-info__item');
  var convertedString = '';

  for (var i = 0; i < flashInfoItems.length; i++) {
    var content = flashInfoItems[i].querySelector('.flash-info__content');

    if (content !== null) {
      convertedString += content.textContent.replace(/\n/g, ' ').replace(/\s/g, '');
    }
  }

  if (convertedString.length < 1) {
    return;
  }

  var btnClose = document.querySelector('.flash-info__button.-close');
  var hash = __WEBPACK_IMPORTED_MODULE_0__js_helpers__["h" /* generateHash */](convertedString);
  var flashInfoModal = document.querySelector('.flash-info__modal');

  if (localStorage.getItem('flash') === null || Number(localStorage.getItem('flash')) !== hash) {
    flashInfo.style.display = 'block';
  }

  if (flashInfoModal) {
    var radioYes = flashInfoModal.getElementsByTagName('input')[0];
    var flashInfoModalSubmit = flashInfoModal.querySelector('.flash-info__modal-btn');
    flashInfoModalSubmit.addEventListener('click', function () {
      var flashInfoModalClose = document.querySelector('.fancybox-close-small');
      flashInfoModalClose.click();
      flashInfo.style.display = 'none';

      if (!radioYes.checked) {
        localStorage.setItem('flash', hash);
      }
    });
  } else {
    btnClose.addEventListener('click', function () {
      flashInfo.style.display = 'none';
      localStorage.setItem('flash', hash);
    });
  }
}

/***/ }),
/* 452 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = managePageImage;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_helpers__ = __webpack_require__(8);

function managePageImage() {
  var header = document.querySelector('.site-header');

  if (header === null) {
    return;
  }

  var pageImage = header.querySelector('.page-image');
  var headerBar = header.querySelector('.header-bar');

  if (pageImage !== null) {
    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](header, '-has-image');
    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](headerBar, '-absolute');
  }
}

/***/ }),
/* 453 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initStratisMenu;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_helpers__ = __webpack_require__(8);

function initStratisMenu() {
  var nav = document.querySelector('.stratis-menu');

  if (nav === null) {
    return;
  }

  var outsideToggle = document.querySelector('.stratis-menu-trigger');
  var menu = nav.querySelector('.stratis-menu__list');
  var toggleBtn = [].slice.call(menu.querySelectorAll('.stratis-menu__toggle'));
  var a11yReport = document.querySelector('.a11y-report');
  var toogleReport = menu.querySelector('.stratis-menu__toggle-report');

  var openMenu = function openMenu(event) {
    var element = event.target;
    var parent = element.tagName.toLowerCase() === 'button' ? element.parentElement : element.parentElement.parentElement;
    var ariaToggle = element.tagName.toLowerCase() === 'button' ? element : element.parentElement;
    var ariaTarget = parent.querySelector('.stratis-menu__submenu');
    var listItems = element.tagName.toLowerCase() === 'button' ? element.parentElement.parentElement.querySelectorAll('.stratis-menu__item') : element.parentElement.parentElement.parentElement.querySelectorAll('.stratis-menu__item');

    for (var i = 0; i < listItems.length; i++) {
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](listItems[i], '-is-active');
    }

    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](parent, '-is-active');
    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["x" /* setAriaControls */](ariaToggle, ariaTarget, 'opened');
  };

  var closeMenu = function closeMenu(event) {
    var element = event.target;
    var ariaToggle = element.tagName.toLowerCase() === 'button' ? element : element.parentElement;
    var parent = element.tagName.toLowerCase() === 'button' ? element.parentElement : element.parentElement.parentElement;
    var ariaTarget = parent.querySelector('.stratis-menu__submenu');
    var listItems = element.tagName.toLowerCase() === 'button' ? element.parentElement.parentElement.querySelectorAll('.stratis-menu__item') : element.parentElement.parentElement.parentElement.querySelectorAll('.stratis-menu__item');

    for (var i = 0; i < listItems.length; i++) {
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](listItems[i], '-is-active');
    }

    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["x" /* setAriaControls */](ariaToggle, ariaTarget, 'closed');
  };

  var manageMenu = function manageMenu(event) {
    var element = event.target;
    var parent = element.tagName.toLowerCase() === 'button' ? element.parentElement : element.parentElement.parentElement;

    if (__WEBPACK_IMPORTED_MODULE_0__js_helpers__["m" /* hasClass */](parent, '-is-active')) {
      closeMenu(event);
    } else {
      openMenu(event);
    }
  };

  outsideToggle.addEventListener('click', function () {
    var state = __WEBPACK_IMPORTED_MODULE_0__js_helpers__["m" /* hasClass */](nav, '-is-visible') ? __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](nav, '-is-visible') : __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](nav, '-is-visible');

    if (a11yReport && __WEBPACK_IMPORTED_MODULE_0__js_helpers__["m" /* hasClass */](a11yReport, '-is-visible')) {
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](a11yReport, '-is-visible');
    }
  });
  toggleBtn.forEach(function (elem) {
    var submenu = elem.parentElement.querySelector('.stratis-menu__submenu');
    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["o" /* initAriaControls */](elem, submenu);
    elem.addEventListener('click', function (e) {
      manageMenu(e);
    });
  });

  if (toogleReport) {
    toogleReport.addEventListener('click', function () {
      if (a11yReport) {
        var state = __WEBPACK_IMPORTED_MODULE_0__js_helpers__["m" /* hasClass */](a11yReport, '-is-visible') ? __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](a11yReport, '-is-visible') : __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](a11yReport, '-is-visible');
      }
    });
  }

  document.addEventListener('click', function (event) {
    var isClickInside = nav.contains(event.target);
    var activeElement = menu.querySelector('.stratis-menu__item.-is-active .stratis-menu__toggle');

    if (!isClickInside && activeElement !== null) {
      activeElement.click();
    }
  });
}

/***/ }),
/* 454 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = drawChart;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_chart_js__ = __webpack_require__(455);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_chart_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_chart_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_whatwg_fetch__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_url_polyfill__ = __webpack_require__(498);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_url_polyfill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_url_polyfill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers__ = __webpack_require__(8);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }






function getChartData(element) {
  var chartDataContainer = element.querySelector('[data-chart-data]');
  var chartData = {};

  if (chartDataContainer === null) {
    return;
  }

  var chartDataItems = _toConsumableArray(chartDataContainer.querySelectorAll('.chart-data__item')); // Create empty arrays for data;


  var chartDataLabels = [];
  var chartDataBackgrounds = [];
  var chartDataValues = [];
  chartDataItems.forEach(function (chartItem) {
    var colorboxStyles = getComputedStyle(chartItem.querySelector('.chart-data__colorbox'));
    chartDataBackgrounds.push(colorboxStyles.backgroundColor);
    chartDataLabels.push(chartItem.textContent);
    chartDataValues.push(Number(chartItem.dataset.value));
  }); // Set options for object

  chartData.labels = chartDataLabels;
  chartData.backgroundColors = chartDataBackgrounds;
  chartData.values = chartDataValues; // return chartDataObject

  return chartData;
}

function setChartFormHandler(id, chart) {
  var form = document.querySelector("[data-chart-form-id=\"".concat(id, "\"]"));
  var results = document.querySelector("[data-chart-id=\"".concat(id, "\"]"));
  var resultsContainer = null;

  if (form === null) {
    return;
  }

  if (results) {
    resultsContainer = __WEBPACK_IMPORTED_MODULE_3__helpers__["g" /* findAncestor */](results, 'interests-block__results');
  }

  form.addEventListener('submit', function (e) {
    e.preventDefault();
    var formData = new FormData(form); // const url = new URL(window.location.origin + form.dataset.url);

    var url = form.dataset.url;
    var formQuery = new URLSearchParams(formData);
    fetch("".concat(url, "?").concat(formQuery), {
      method: 'GET',
      credentials: 'include'
    }).then(function (response) {
      if (response.status >= 200 && response.status < 300) {
        return response;
      }

      var error = new Error(response.statusText);
      error.response = response;
      throw error;
    }).then(function (response) {
      return response.text();
    }).then(function (data) {
      if (resultsContainer) {
        var chartDataContainer = resultsContainer.querySelector('.interests-results__chart-data');

        if (__WEBPACK_IMPORTED_MODULE_3__helpers__["m" /* hasClass */](resultsContainer, '-is-hidden')) {
          __WEBPACK_IMPORTED_MODULE_3__helpers__["w" /* removeClass */](resultsContainer, '-is-hidden');
          var formContainer = __WEBPACK_IMPORTED_MODULE_3__helpers__["g" /* findAncestor */](form, 'interests-block__vote');

          if (formContainer) {
            __WEBPACK_IMPORTED_MODULE_3__helpers__["a" /* addClass */](formContainer, '-is-hidden');
          }
        }

        chartDataContainer.innerHTML = data;
        var chartData = getChartData(resultsContainer);
        chart.data = {
          labels: chartData.labels,
          datasets: [{
            data: chartData.values,
            backgroundColor: chartData.backgroundColors,
            borderWidth: 0
          }]
        };
        chart.update();
      }
    });
  });
}

function drawChart(chartSelector) {
  var chartElements = _toConsumableArray(document.querySelectorAll(chartSelector));

  chartElements.forEach(function (chartElement) {
    var chartId = chartElement.dataset.chartId;
    var cnvs = chartElement.querySelector('canvas');

    if (cnvs) {
      var ctx = cnvs.getContext('2d');
      var chartData = getChartData(chartElement);
      var chart = new __WEBPACK_IMPORTED_MODULE_0_chart_js___default.a(ctx, {
        // The type of chart we want to create
        type: 'doughnut',
        // The data for our dataset
        data: {
          labels: chartData.labels,
          datasets: [{
            data: chartData.values,
            backgroundColor: chartData.backgroundColors,
            borderWidth: 0
          }]
        },
        // Configuration options go here
        options: {
          responsive: true,
          maintainAspectRatio: false,
          legend: false,
          cutoutPercentage: 65
        }
      });

      if (chartId) {
        setChartFormHandler(chartId, chart);
      }
    }
  });
}

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @namespace Chart
 */
var Chart = __webpack_require__(456)();

Chart.helpers = __webpack_require__(2); // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

__webpack_require__(460)(Chart);

Chart.Animation = __webpack_require__(133);
Chart.animationService = __webpack_require__(134);
Chart.defaults = __webpack_require__(7);
Chart.Element = __webpack_require__(25);
Chart.elements = __webpack_require__(35);
Chart.Interaction = __webpack_require__(135);
Chart.layouts = __webpack_require__(55);
Chart.platform = __webpack_require__(136);
Chart.plugins = __webpack_require__(137);
Chart.Scale = __webpack_require__(56);
Chart.scaleService = __webpack_require__(34);
Chart.Ticks = __webpack_require__(57);
Chart.Tooltip = __webpack_require__(138);

__webpack_require__(471)(Chart);

__webpack_require__(472)(Chart);

__webpack_require__(473)(Chart);

__webpack_require__(474)(Chart);

__webpack_require__(475)(Chart);

__webpack_require__(476)(Chart);

__webpack_require__(477)(Chart);

__webpack_require__(478)(Chart); // Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType


__webpack_require__(480)(Chart);

__webpack_require__(481)(Chart);

__webpack_require__(482)(Chart);

__webpack_require__(483)(Chart);

__webpack_require__(484)(Chart);

__webpack_require__(485)(Chart);

__webpack_require__(486)(Chart);

__webpack_require__(487)(Chart);

__webpack_require__(488)(Chart);

__webpack_require__(489)(Chart);

__webpack_require__(490)(Chart);

__webpack_require__(491)(Chart);

__webpack_require__(492)(Chart);

__webpack_require__(493)(Chart); // Loading built-in plugins


var plugins = __webpack_require__(494);

for (var k in plugins) {
  if (plugins.hasOwnProperty(k)) {
    Chart.plugins.register(plugins[k]);
  }
}

Chart.platform.initialize();
module.exports = Chart;

if (typeof window !== 'undefined') {
  window.Chart = Chart;
} // DEPRECATIONS

/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Legend
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */


Chart.Legend = plugins.legend._element;
/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Title
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */

Chart.Title = plugins.title._element;
/**
 * Provided for backward compatibility, use Chart.plugins instead
 * @namespace Chart.pluginService
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */

Chart.pluginService = Chart.plugins;
/**
 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
 * effect, instead simply create/register plugins via plain JavaScript objects.
 * @interface Chart.PluginBase
 * @deprecated since version 2.5.0
 * @todo remove at version 3
 * @private
 */

Chart.PluginBase = Chart.Element.extend({});
/**
 * Provided for backward compatibility, use Chart.helpers.canvas instead.
 * @namespace Chart.canvasHelpers
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */

Chart.canvasHelpers = Chart.helpers.canvas;
/**
 * Provided for backward compatibility, use Chart.layouts instead.
 * @namespace Chart.layoutService
 * @deprecated since version 2.8.0
 * @todo remove at version 3
 * @private
 */

Chart.layoutService = Chart.layouts;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

defaults._set('global', {
  responsive: true,
  responsiveAnimationDuration: 0,
  maintainAspectRatio: true,
  events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
  hover: {
    onHover: null,
    mode: 'nearest',
    intersect: true,
    animationDuration: 400
  },
  onClick: null,
  defaultColor: 'rgba(0,0,0,0.1)',
  defaultFontColor: '#666',
  defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
  defaultFontSize: 12,
  defaultFontStyle: 'normal',
  showLines: true,
  // Element defaults defined in element extensions
  elements: {},
  // Layout options such as padding
  layout: {
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  }
});

module.exports = function () {
  // Occupy the global variable of Chart, and create a simple base class
  var Chart = function (item, config) {
    this.construct(item, config);
    return this;
  };

  Chart.Chart = Chart;
  return Chart;
};

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(69);
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easingEffects
 * @see http://www.robertpenner.com/easing/
 */


var effects = {
  linear: function (t) {
    return t;
  },
  easeInQuad: function (t) {
    return t * t;
  },
  easeOutQuad: function (t) {
    return -t * (t - 2);
  },
  easeInOutQuad: function (t) {
    if ((t /= 0.5) < 1) {
      return 0.5 * t * t;
    }

    return -0.5 * (--t * (t - 2) - 1);
  },
  easeInCubic: function (t) {
    return t * t * t;
  },
  easeOutCubic: function (t) {
    return (t = t - 1) * t * t + 1;
  },
  easeInOutCubic: function (t) {
    if ((t /= 0.5) < 1) {
      return 0.5 * t * t * t;
    }

    return 0.5 * ((t -= 2) * t * t + 2);
  },
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  easeOutQuart: function (t) {
    return -((t = t - 1) * t * t * t - 1);
  },
  easeInOutQuart: function (t) {
    if ((t /= 0.5) < 1) {
      return 0.5 * t * t * t * t;
    }

    return -0.5 * ((t -= 2) * t * t * t - 2);
  },
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  easeOutQuint: function (t) {
    return (t = t - 1) * t * t * t * t + 1;
  },
  easeInOutQuint: function (t) {
    if ((t /= 0.5) < 1) {
      return 0.5 * t * t * t * t * t;
    }

    return 0.5 * ((t -= 2) * t * t * t * t + 2);
  },
  easeInSine: function (t) {
    return -Math.cos(t * (Math.PI / 2)) + 1;
  },
  easeOutSine: function (t) {
    return Math.sin(t * (Math.PI / 2));
  },
  easeInOutSine: function (t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  },
  easeInExpo: function (t) {
    return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
  },
  easeOutExpo: function (t) {
    return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
  },
  easeInOutExpo: function (t) {
    if (t === 0) {
      return 0;
    }

    if (t === 1) {
      return 1;
    }

    if ((t /= 0.5) < 1) {
      return 0.5 * Math.pow(2, 10 * (t - 1));
    }

    return 0.5 * (-Math.pow(2, -10 * --t) + 2);
  },
  easeInCirc: function (t) {
    if (t >= 1) {
      return t;
    }

    return -(Math.sqrt(1 - t * t) - 1);
  },
  easeOutCirc: function (t) {
    return Math.sqrt(1 - (t = t - 1) * t);
  },
  easeInOutCirc: function (t) {
    if ((t /= 0.5) < 1) {
      return -0.5 * (Math.sqrt(1 - t * t) - 1);
    }

    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  },
  easeInElastic: function (t) {
    var s = 1.70158;
    var p = 0;
    var a = 1;

    if (t === 0) {
      return 0;
    }

    if (t === 1) {
      return 1;
    }

    if (!p) {
      p = 0.3;
    }

    if (a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(1 / a);
    }

    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
  },
  easeOutElastic: function (t) {
    var s = 1.70158;
    var p = 0;
    var a = 1;

    if (t === 0) {
      return 0;
    }

    if (t === 1) {
      return 1;
    }

    if (!p) {
      p = 0.3;
    }

    if (a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(1 / a);
    }

    return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
  },
  easeInOutElastic: function (t) {
    var s = 1.70158;
    var p = 0;
    var a = 1;

    if (t === 0) {
      return 0;
    }

    if ((t /= 0.5) === 2) {
      return 1;
    }

    if (!p) {
      p = 0.45;
    }

    if (a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(1 / a);
    }

    if (t < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
    }

    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  easeInBack: function (t) {
    var s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack: function (t) {
    var s = 1.70158;
    return (t = t - 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack: function (t) {
    var s = 1.70158;

    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }

    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: function (t) {
    return 1 - effects.easeOutBounce(1 - t);
  },
  easeOutBounce: function (t) {
    if (t < 1 / 2.75) {
      return 7.5625 * t * t;
    }

    if (t < 2 / 2.75) {
      return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    }

    if (t < 2.5 / 2.75) {
      return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    }

    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  },
  easeInOutBounce: function (t) {
    if (t < 0.5) {
      return effects.easeInBounce(t * 2) * 0.5;
    }

    return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
  }
};
module.exports = {
  effects: effects
}; // DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
 * @function Chart.helpers.easingEffects
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.easingEffects = effects;

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(69);
/**
 * @namespace Chart.helpers.canvas
 */


var exports = module.exports = {
  /**
   * Clears the entire canvas associated to the given `chart`.
   * @param {Chart} chart - The chart for which to clear the canvas.
   */
  clear: function (chart) {
    chart.ctx.clearRect(0, 0, chart.width, chart.height);
  },

  /**
   * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
   * given size (width, height) and the same `radius` for all corners.
   * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
   * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
   * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
   * @param {Number} width - The rectangle's width.
   * @param {Number} height - The rectangle's height.
   * @param {Number} radius - The rounded amount (in pixels) for the four corners.
   * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
   */
  roundedRect: function (ctx, x, y, width, height, radius) {
    if (radius) {
      // NOTE(SB) `epsilon` helps to prevent minor artifacts appearing
      // on Chrome when `r` is exactly half the height or the width.
      var epsilon = 0.0000001;
      var r = Math.min(radius, height / 2 - epsilon, width / 2 - epsilon);
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + width - r, y);
      ctx.arcTo(x + width, y, x + width, y + r, r);
      ctx.lineTo(x + width, y + height - r);
      ctx.arcTo(x + width, y + height, x + width - r, y + height, r);
      ctx.lineTo(x + r, y + height);
      ctx.arcTo(x, y + height, x, y + height - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
      ctx.moveTo(x, y);
    } else {
      ctx.rect(x, y, width, height);
    }
  },
  drawPoint: function (ctx, style, radius, x, y, rotation) {
    var type, edgeLength, xOffset, yOffset, height, size;
    rotation = rotation || 0;

    if (style && typeof style === 'object') {
      type = style.toString();

      if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
        ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
        return;
      }
    }

    if (isNaN(radius) || radius <= 0) {
      return;
    }

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.beginPath();

    switch (style) {
      // Default includes circle
      default:
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.closePath();
        break;

      case 'triangle':
        edgeLength = 3 * radius / Math.sqrt(3);
        height = edgeLength * Math.sqrt(3) / 2;
        ctx.moveTo(-edgeLength / 2, height / 3);
        ctx.lineTo(edgeLength / 2, height / 3);
        ctx.lineTo(0, -2 * height / 3);
        ctx.closePath();
        break;

      case 'rect':
        size = 1 / Math.SQRT2 * radius;
        ctx.rect(-size, -size, 2 * size, 2 * size);
        break;

      case 'rectRounded':
        var offset = radius / Math.SQRT2;
        var leftX = -offset;
        var topY = -offset;
        var sideSize = Math.SQRT2 * radius; // NOTE(SB) the rounded rect implementation changed to use `arcTo`
        // instead of `quadraticCurveTo` since it generates better results
        // when rect is almost a circle. 0.425 (instead of 0.5) produces
        // results visually closer to the previous impl.

        this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius * 0.425);
        break;

      case 'rectRot':
        size = 1 / Math.SQRT2 * radius;
        ctx.moveTo(-size, 0);
        ctx.lineTo(0, size);
        ctx.lineTo(size, 0);
        ctx.lineTo(0, -size);
        ctx.closePath();
        break;

      case 'cross':
        ctx.moveTo(0, radius);
        ctx.lineTo(0, -radius);
        ctx.moveTo(-radius, 0);
        ctx.lineTo(radius, 0);
        break;

      case 'crossRot':
        xOffset = Math.cos(Math.PI / 4) * radius;
        yOffset = Math.sin(Math.PI / 4) * radius;
        ctx.moveTo(-xOffset, -yOffset);
        ctx.lineTo(xOffset, yOffset);
        ctx.moveTo(-xOffset, yOffset);
        ctx.lineTo(xOffset, -yOffset);
        break;

      case 'star':
        ctx.moveTo(0, radius);
        ctx.lineTo(0, -radius);
        ctx.moveTo(-radius, 0);
        ctx.lineTo(radius, 0);
        xOffset = Math.cos(Math.PI / 4) * radius;
        yOffset = Math.sin(Math.PI / 4) * radius;
        ctx.moveTo(-xOffset, -yOffset);
        ctx.lineTo(xOffset, yOffset);
        ctx.moveTo(-xOffset, yOffset);
        ctx.lineTo(xOffset, -yOffset);
        break;

      case 'line':
        ctx.moveTo(-radius, 0);
        ctx.lineTo(radius, 0);
        break;

      case 'dash':
        ctx.moveTo(0, 0);
        ctx.lineTo(radius, 0);
        break;
    }

    ctx.fill();
    ctx.stroke();
    ctx.restore();
  },
  clipArea: function (ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  },
  unclipArea: function (ctx) {
    ctx.restore();
  },
  lineTo: function (ctx, previous, target, flip) {
    if (target.steppedLine) {
      if (target.steppedLine === 'after' && !flip || target.steppedLine !== 'after' && flip) {
        ctx.lineTo(previous.x, target.y);
      } else {
        ctx.lineTo(target.x, previous.y);
      }

      ctx.lineTo(target.x, target.y);
      return;
    }

    if (!target.tension) {
      ctx.lineTo(target.x, target.y);
      return;
    }

    ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
  }
}; // DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
 * @namespace Chart.helpers.clear
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.clear = exports.clear;
/**
 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
 * @namespace Chart.helpers.drawRoundedRectangle
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.drawRoundedRectangle = function (ctx) {
  ctx.beginPath();
  exports.roundedRect.apply(exports, arguments);
};

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(69);
/**
 * @alias Chart.helpers.options
 * @namespace
 */


module.exports = {
  /**
   * Converts the given line height `value` in pixels for a specific font `size`.
   * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
   * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
   * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
   * @since 2.7.0
   */
  toLineHeight: function (value, size) {
    var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

    if (!matches || matches[1] === 'normal') {
      return size * 1.2;
    }

    value = +matches[2];

    switch (matches[3]) {
      case 'px':
        return value;

      case '%':
        value /= 100;
        break;

      default:
        break;
    }

    return size * value;
  },

  /**
   * Converts the given value into a padding object with pre-computed width/height.
   * @param {Number|Object} value - If a number, set the value to all TRBL component,
   *  else, if and object, use defined properties and sets undefined ones to 0.
   * @returns {Object} The padding values (top, right, bottom, left, width, height)
   * @since 2.7.0
   */
  toPadding: function (value) {
    var t, r, b, l;

    if (helpers.isObject(value)) {
      t = +value.top || 0;
      r = +value.right || 0;
      b = +value.bottom || 0;
      l = +value.left || 0;
    } else {
      t = r = b = l = +value || 0;
    }

    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      height: t + b,
      width: l + r
    };
  },

  /**
   * Evaluates the given `inputs` sequentially and returns the first defined value.
   * @param {Array[]} inputs - An array of values, falling back to the last value.
   * @param {Object} [context] - If defined and the current value is a function, the value
   * is called with `context` as first argument and the result becomes the new input.
   * @param {Number} [index] - If defined and the current value is an array, the value
   * at `index` become the new input.
   * @since 2.7.0
   */
  resolve: function (inputs, context, index) {
    var i, ilen, value;

    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];

      if (value === undefined) {
        continue;
      }

      if (context !== undefined && typeof value === 'function') {
        value = value(context);
      }

      if (index !== undefined && helpers.isArray(value)) {
        value = value[index];
      }

      if (value !== undefined) {
        return value;
      }
    }
  }
};

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */

/* global document: false */


var color = __webpack_require__(132);

var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

var scaleService = __webpack_require__(34);

module.exports = function () {
  // -- Basic js utility methods
  helpers.configMerge = function ()
  /* objects ... */
  {
    return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
      merger: function (key, target, source, options) {
        var tval = target[key] || {};
        var sval = source[key];

        if (key === 'scales') {
          // scale config merging is complex. Add our own function here for that
          target[key] = helpers.scaleMerge(tval, sval);
        } else if (key === 'scale') {
          // used in polar area & radar charts since there is only one scale
          target[key] = helpers.merge(tval, [scaleService.getScaleDefaults(sval.type), sval]);
        } else {
          helpers._merger(key, target, source, options);
        }
      }
    });
  };

  helpers.scaleMerge = function ()
  /* objects ... */
  {
    return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
      merger: function (key, target, source, options) {
        if (key === 'xAxes' || key === 'yAxes') {
          var slen = source[key].length;
          var i, type, scale;

          if (!target[key]) {
            target[key] = [];
          }

          for (i = 0; i < slen; ++i) {
            scale = source[key][i];
            type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

            if (i >= target[key].length) {
              target[key].push({});
            }

            if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
              // new/untyped scale or type changed: let's apply the new defaults
              // then merge source scale to correctly overwrite the defaults.
              helpers.merge(target[key][i], [scaleService.getScaleDefaults(type), scale]);
            } else {
              // scales type are the same
              helpers.merge(target[key][i], scale);
            }
          }
        } else {
          helpers._merger(key, target, source, options);
        }
      }
    });
  };

  helpers.where = function (collection, filterCallback) {
    if (helpers.isArray(collection) && Array.prototype.filter) {
      return collection.filter(filterCallback);
    }

    var filtered = [];
    helpers.each(collection, function (item) {
      if (filterCallback(item)) {
        filtered.push(item);
      }
    });
    return filtered;
  };

  helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
    return array.findIndex(callback, scope);
  } : function (array, callback, scope) {
    scope = scope === undefined ? array : scope;

    for (var i = 0, ilen = array.length; i < ilen; ++i) {
      if (callback.call(scope, array[i], i, array)) {
        return i;
      }
    }

    return -1;
  };

  helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
    // Default to start of the array
    if (helpers.isNullOrUndef(startIndex)) {
      startIndex = -1;
    }

    for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
      var currentItem = arrayToSearch[i];

      if (filterCallback(currentItem)) {
        return currentItem;
      }
    }
  };

  helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
    // Default to end of the array
    if (helpers.isNullOrUndef(startIndex)) {
      startIndex = arrayToSearch.length;
    }

    for (var i = startIndex - 1; i >= 0; i--) {
      var currentItem = arrayToSearch[i];

      if (filterCallback(currentItem)) {
        return currentItem;
      }
    }
  }; // -- Math methods


  helpers.isNumber = function (n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  helpers.almostEquals = function (x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  };

  helpers.almostWhole = function (x, epsilon) {
    var rounded = Math.round(x);
    return rounded - epsilon < x && rounded + epsilon > x;
  };

  helpers.max = function (array) {
    return array.reduce(function (max, value) {
      if (!isNaN(value)) {
        return Math.max(max, value);
      }

      return max;
    }, Number.NEGATIVE_INFINITY);
  };

  helpers.min = function (array) {
    return array.reduce(function (min, value) {
      if (!isNaN(value)) {
        return Math.min(min, value);
      }

      return min;
    }, Number.POSITIVE_INFINITY);
  };

  helpers.sign = Math.sign ? function (x) {
    return Math.sign(x);
  } : function (x) {
    x = +x; // convert to a number

    if (x === 0 || isNaN(x)) {
      return x;
    }

    return x > 0 ? 1 : -1;
  };
  helpers.log10 = Math.log10 ? function (x) {
    return Math.log10(x);
  } : function (x) {
    var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
    // Check for whole powers of 10,
    // which due to floating point rounding error should be corrected.

    var powerOf10 = Math.round(exponent);
    var isPowerOf10 = x === Math.pow(10, powerOf10);
    return isPowerOf10 ? powerOf10 : exponent;
  };

  helpers.toRadians = function (degrees) {
    return degrees * (Math.PI / 180);
  };

  helpers.toDegrees = function (radians) {
    return radians * (180 / Math.PI);
  }; // Gets the angle from vertical upright to the point about a centre.


  helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
    var distanceFromXCenter = anglePoint.x - centrePoint.x;
    var distanceFromYCenter = anglePoint.y - centrePoint.y;
    var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

    if (angle < -0.5 * Math.PI) {
      angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
    }

    return {
      angle: angle,
      distance: radialDistanceFromCenter
    };
  };

  helpers.distanceBetweenPoints = function (pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  };

  helpers.aliasPixel = function (pixelWidth) {
    return pixelWidth % 2 === 0 ? 0 : 0.5;
  };

  helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
    // Props to Rob Spencer at scaled innovation for his post on splining between points
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    // This function must also respect "skipped" points
    var previous = firstPoint.skip ? middlePoint : firstPoint;
    var current = middlePoint;
    var next = afterPoint.skip ? middlePoint : afterPoint;
    var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
    var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
    var s01 = d01 / (d01 + d12);
    var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    var fa = t * s01; // scaling factor for triangle Ta

    var fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  };

  helpers.EPSILON = Number.EPSILON || 1e-14;

  helpers.splineCurveMonotone = function (points) {
    // This function calculates Bézier control points in a similar way than |splineCurve|,
    // but preserves monotonicity of the provided data and ensures no local extremums are added
    // between the dataset discrete points due to the interpolation.
    // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
    var pointsWithTangents = (points || []).map(function (point) {
      return {
        model: point._model,
        deltaK: 0,
        mK: 0
      };
    }); // Calculate slopes (deltaK) and initialize tangents (mK)

    var pointsLen = pointsWithTangents.length;
    var i, pointBefore, pointCurrent, pointAfter;

    for (i = 0; i < pointsLen; ++i) {
      pointCurrent = pointsWithTangents[i];

      if (pointCurrent.model.skip) {
        continue;
      }

      pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
      pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

      if (pointAfter && !pointAfter.model.skip) {
        var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

        pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
      }

      if (!pointBefore || pointBefore.model.skip) {
        pointCurrent.mK = pointCurrent.deltaK;
      } else if (!pointAfter || pointAfter.model.skip) {
        pointCurrent.mK = pointBefore.deltaK;
      } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
        pointCurrent.mK = 0;
      } else {
        pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
      }
    } // Adjust tangents to ensure monotonic properties


    var alphaK, betaK, tauK, squaredMagnitude;

    for (i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointsWithTangents[i];
      pointAfter = pointsWithTangents[i + 1];

      if (pointCurrent.model.skip || pointAfter.model.skip) {
        continue;
      }

      if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
        pointCurrent.mK = pointAfter.mK = 0;
        continue;
      }

      alphaK = pointCurrent.mK / pointCurrent.deltaK;
      betaK = pointAfter.mK / pointCurrent.deltaK;
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

      if (squaredMagnitude <= 9) {
        continue;
      }

      tauK = 3 / Math.sqrt(squaredMagnitude);
      pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
      pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
    } // Compute control points


    var deltaX;

    for (i = 0; i < pointsLen; ++i) {
      pointCurrent = pointsWithTangents[i];

      if (pointCurrent.model.skip) {
        continue;
      }

      pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
      pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

      if (pointBefore && !pointBefore.model.skip) {
        deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
        pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
        pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
      }

      if (pointAfter && !pointAfter.model.skip) {
        deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
        pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
        pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
      }
    }
  };

  helpers.nextItem = function (collection, index, loop) {
    if (loop) {
      return index >= collection.length - 1 ? collection[0] : collection[index + 1];
    }

    return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
  };

  helpers.previousItem = function (collection, index, loop) {
    if (loop) {
      return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
    }

    return index <= 0 ? collection[0] : collection[index - 1];
  }; // Implementation of the nice number algorithm used in determining where axis labels will go


  helpers.niceNum = function (range, round) {
    var exponent = Math.floor(helpers.log10(range));
    var fraction = range / Math.pow(10, exponent);
    var niceFraction;

    if (round) {
      if (fraction < 1.5) {
        niceFraction = 1;
      } else if (fraction < 3) {
        niceFraction = 2;
      } else if (fraction < 7) {
        niceFraction = 5;
      } else {
        niceFraction = 10;
      }
    } else if (fraction <= 1.0) {
      niceFraction = 1;
    } else if (fraction <= 2) {
      niceFraction = 2;
    } else if (fraction <= 5) {
      niceFraction = 5;
    } else {
      niceFraction = 10;
    }

    return niceFraction * Math.pow(10, exponent);
  }; // Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


  helpers.requestAnimFrame = function () {
    if (typeof window === 'undefined') {
      return function (callback) {
        callback();
      };
    }

    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  }(); // -- DOM methods


  helpers.getRelativePosition = function (evt, chart) {
    var mouseX, mouseY;
    var e = evt.originalEvent || evt;
    var canvas = evt.target || evt.srcElement;
    var boundingRect = canvas.getBoundingClientRect();
    var touches = e.touches;

    if (touches && touches.length > 0) {
      mouseX = touches[0].clientX;
      mouseY = touches[0].clientY;
    } else {
      mouseX = e.clientX;
      mouseY = e.clientY;
    } // Scale mouse coordinates into canvas coordinates
    // by following the pattern laid out by 'jerryj' in the comments of
    // http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


    var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
    var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
    var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
    var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
    var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
    var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
    // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

    mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
    mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
    return {
      x: mouseX,
      y: mouseY
    };
  }; // Private helper function to convert max-width/max-height values that may be percentages into a number


  function parseMaxStyle(styleValue, node, parentProperty) {
    var valueInPixels;

    if (typeof styleValue === 'string') {
      valueInPixels = parseInt(styleValue, 10);

      if (styleValue.indexOf('%') !== -1) {
        // percentage * size in dimension
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }

    return valueInPixels;
  }
  /**
   * Returns if the given value contains an effective constraint.
   * @private
   */


  function isConstrainedValue(value) {
    return value !== undefined && value !== null && value !== 'none';
  } // Private helper to get a constraint dimension
  // @param domNode : the node to check the constraint on
  // @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
  // @param percentageProperty : property of parent to use when calculating width as a percentage
  // @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser


  function getConstraintDimension(domNode, maxStyle, percentageProperty) {
    var view = document.defaultView;

    var parentNode = helpers._getParentNode(domNode);

    var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
    var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
    var hasCNode = isConstrainedValue(constrainedNode);
    var hasCContainer = isConstrainedValue(constrainedContainer);
    var infinity = Number.POSITIVE_INFINITY;

    if (hasCNode || hasCContainer) {
      return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
    }

    return 'none';
  } // returns Number or undefined if no constraint


  helpers.getConstraintWidth = function (domNode) {
    return getConstraintDimension(domNode, 'max-width', 'clientWidth');
  }; // returns Number or undefined if no constraint


  helpers.getConstraintHeight = function (domNode) {
    return getConstraintDimension(domNode, 'max-height', 'clientHeight');
  };
  /**
   * @private
  	 */


  helpers._calculatePadding = function (container, padding, parentDimension) {
    padding = helpers.getStyle(container, padding);
    return padding.indexOf('%') > -1 ? parentDimension / parseInt(padding, 10) : parseInt(padding, 10);
  };
  /**
   * @private
   */


  helpers._getParentNode = function (domNode) {
    var parent = domNode.parentNode;

    if (parent && parent.host) {
      parent = parent.host;
    }

    return parent;
  };

  helpers.getMaximumWidth = function (domNode) {
    var container = helpers._getParentNode(domNode);

    if (!container) {
      return domNode.clientWidth;
    }

    var clientWidth = container.clientWidth;

    var paddingLeft = helpers._calculatePadding(container, 'padding-left', clientWidth);

    var paddingRight = helpers._calculatePadding(container, 'padding-right', clientWidth);

    var w = clientWidth - paddingLeft - paddingRight;
    var cw = helpers.getConstraintWidth(domNode);
    return isNaN(cw) ? w : Math.min(w, cw);
  };

  helpers.getMaximumHeight = function (domNode) {
    var container = helpers._getParentNode(domNode);

    if (!container) {
      return domNode.clientHeight;
    }

    var clientHeight = container.clientHeight;

    var paddingTop = helpers._calculatePadding(container, 'padding-top', clientHeight);

    var paddingBottom = helpers._calculatePadding(container, 'padding-bottom', clientHeight);

    var h = clientHeight - paddingTop - paddingBottom;
    var ch = helpers.getConstraintHeight(domNode);
    return isNaN(ch) ? h : Math.min(h, ch);
  };

  helpers.getStyle = function (el, property) {
    return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
  };

  helpers.retinaScale = function (chart, forceRatio) {
    var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

    if (pixelRatio === 1) {
      return;
    }

    var canvas = chart.canvas;
    var height = chart.height;
    var width = chart.width;
    canvas.height = height * pixelRatio;
    canvas.width = width * pixelRatio;
    chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
    // making the chart visually bigger, so let's enforce it to the "correct" values.
    // See https://github.com/chartjs/Chart.js/issues/3575

    if (!canvas.style.height && !canvas.style.width) {
      canvas.style.height = height + 'px';
      canvas.style.width = width + 'px';
    }
  }; // -- Canvas methods


  helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
  };

  helpers.longestText = function (ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    var data = cache.data = cache.data || {};
    var gc = cache.garbageCollect = cache.garbageCollect || [];

    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }

    ctx.font = font;
    var longest = 0;
    helpers.each(arrayOfThings, function (thing) {
      // Undefined strings and arrays should not be measured
      if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
        longest = helpers.measureText(ctx, data, gc, longest, thing);
      } else if (helpers.isArray(thing)) {
        // if it is an array lets measure each element
        // to do maybe simplify this function a bit so we can do this more recursively?
        helpers.each(thing, function (nestedThing) {
          // Undefined strings and arrays should not be measured
          if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
            longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
          }
        });
      }
    });
    var gcLen = gc.length / 2;

    if (gcLen > arrayOfThings.length) {
      for (var i = 0; i < gcLen; i++) {
        delete data[gc[i]];
      }

      gc.splice(0, gcLen);
    }

    return longest;
  };

  helpers.measureText = function (ctx, data, gc, longest, string) {
    var textWidth = data[string];

    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }

    if (textWidth > longest) {
      longest = textWidth;
    }

    return longest;
  };

  helpers.numberOfLabelLines = function (arrayOfThings) {
    var numberOfLines = 1;
    helpers.each(arrayOfThings, function (thing) {
      if (helpers.isArray(thing)) {
        if (thing.length > numberOfLines) {
          numberOfLines = thing.length;
        }
      }
    });
    return numberOfLines;
  };

  helpers.color = !color ? function (value) {
    console.error('Color.js not found!');
    return value;
  } : function (value) {
    /* global CanvasGradient */
    if (value instanceof CanvasGradient) {
      value = defaults.global.defaultColor;
    }

    return color(value);
  };

  helpers.getHoverColor = function (colorValue) {
    /* global CanvasPattern */
    return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
  };
};

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(462);

var convert = function () {
  return new Converter();
};

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] = function (func) {
    // accept array or plain args
    return function (arg) {
      if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    };
  }(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = function (func) {
    return function (arg) {
      if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined) return val; // keyword

      for (var i = 0; i < val.length; i++) val[i] = Math.round(val[i]);

      return val;
    };
  }(func);
}
/* Converter does lazy conversion and caching */


var Converter = function () {
  this.convs = {};
};
/* Either get the values for a space or
  set the values for a space, depending on args */


Converter.prototype.routeSpace = function (space, args) {
  var values = args[0];

  if (values === undefined) {
    // color.rgb()
    return this.getValues(space);
  } // color.rgb(10, 10, 10)


  if (typeof values == "number") {
    values = Array.prototype.slice.call(args);
  }

  return this.setValues(space, values);
};
/* Set the values for a space, invalidating cache */


Converter.prototype.setValues = function (space, values) {
  this.space = space;
  this.convs = {};
  this.convs[space] = values;
  return this;
};
/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */


Converter.prototype.getValues = function (space) {
  var vals = this.convs[space];

  if (!vals) {
    var fspace = this.space,
        from = this.convs[fspace];
    vals = convert[fspace][space](from);
    this.convs[space] = vals;
  }

  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
  Converter.prototype[space] = function (vals) {
    return this.routeSpace(space, arguments);
  };
});
module.exports = convert;

/***/ }),
/* 462 */
/***/ (function(module, exports) {

/* MIT license */
module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,
  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,
  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,
  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,
  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,
  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,
  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,
  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,
  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
};

function rgb2hsl(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h,
      s,
      l;
  if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;
  h = Math.min(h * 60, 360);
  if (h < 0) h += 360;
  l = (min + max) / 2;
  if (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);
  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h,
      s,
      v;
  if (max == 0) s = 0;else s = delta / max * 1000 / 10;
  if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;
  h = Math.min(h * 60, 360);
  if (h < 0) h += 360;
  v = max / 255 * 1000 / 10;
  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1 / 255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c,
      m,
      y,
      k;
  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255; // assume sRGB

  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
      x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l,
      a,
      b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1,
      t2,
      t3,
      rgb,
      val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;
  t1 = 2 * l - t2;
  rgb = [0, 0, 0];

  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;
    if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;
    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv,
      v;

  if (l === 0) {
    // no need to do calc on black
    // also avoids divide by 0 error
    return [0, 0, 0];
  }

  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  v = (l + s) / 2;
  sv = 2 * s / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}

function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;
  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - s * f),
      t = 255 * v * (1 - s * (1 - f)),
      v = 255 * v;

  switch (hi) {
    case 0:
      return [v, t, p];

    case 1:
      return [q, v, p];

    case 2:
      return [p, v, t];

    case 3:
      return [p, q, v];

    case 4:
      return [t, p, v];

    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl,
      l;
  l = (2 - s) * v;
  sl = s * v;
  sl /= l <= 1 ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args));
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
} // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i,
      v,
      f,
      n; // wh + bl cant be > 1

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;

  if ((i & 0x01) != 0) {
    f = 1 - f;
  }

  n = wh + f * (v - wh); // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;

    case 1:
      r = n;
      g = v;
      b = wh;
      break;

    case 2:
      r = wh;
      g = v;
      b = n;
      break;

    case 3:
      r = wh;
      g = n;
      b = v;
      break;

    case 4:
      r = n;
      g = wh;
      b = v;
      break;

    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r,
      g,
      b;
  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}

function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r,
      g,
      b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l,
      a,
      b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x,
      y,
      z,
      y2;

  if (l <= 8) {
    y = l * 100 / 903.3;
    y2 = 7.787 * (y / 100) + 16 / 116;
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1 / 3);
  }

  x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
  z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr,
      h,
      c;
  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;

  if (h < 0) {
    h += 360;
  }

  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a,
      b,
      hr;
  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var reverseKeywords = {};

for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var colorNames = __webpack_require__(464);

module.exports = {
  getRgba: getRgba,
  getHsla: getHsla,
  getRgb: getRgb,
  getHsl: getHsl,
  getHwb: getHwb,
  getAlpha: getAlpha,
  hexString: hexString,
  rgbString: rgbString,
  rgbaString: rgbaString,
  percentString: percentString,
  percentaString: percentaString,
  hslString: hslString,
  hslaString: hslaString,
  hwbString: hwbString,
  keyword: keyword
};

function getRgba(string) {
  if (!string) {
    return;
  }

  var abbr = /^#([a-fA-F0-9]{3})$/i,
      hex = /^#([a-fA-F0-9]{6})$/i,
      rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
      per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
      keyword = /(\w+)/;
  var rgb = [0, 0, 0],
      a = 1,
      match = string.match(abbr);

  if (match) {
    match = match[1];

    for (var i = 0; i < rgb.length; i++) {
      rgb[i] = parseInt(match[i] + match[i], 16);
    }
  } else if (match = string.match(hex)) {
    match = match[1];

    for (var i = 0; i < rgb.length; i++) {
      rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
    }
  } else if (match = string.match(rgba)) {
    for (var i = 0; i < rgb.length; i++) {
      rgb[i] = parseInt(match[i + 1]);
    }

    a = parseFloat(match[4]);
  } else if (match = string.match(per)) {
    for (var i = 0; i < rgb.length; i++) {
      rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
    }

    a = parseFloat(match[4]);
  } else if (match = string.match(keyword)) {
    if (match[1] == "transparent") {
      return [0, 0, 0, 0];
    }

    rgb = colorNames[match[1]];

    if (!rgb) {
      return;
    }
  }

  for (var i = 0; i < rgb.length; i++) {
    rgb[i] = scale(rgb[i], 0, 255);
  }

  if (!a && a != 0) {
    a = 1;
  } else {
    a = scale(a, 0, 1);
  }

  rgb[3] = a;
  return rgb;
}

function getHsla(string) {
  if (!string) {
    return;
  }

  var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
  var match = string.match(hsl);

  if (match) {
    var alpha = parseFloat(match[4]);
    var h = scale(parseInt(match[1]), 0, 360),
        s = scale(parseFloat(match[2]), 0, 100),
        l = scale(parseFloat(match[3]), 0, 100),
        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, s, l, a];
  }
}

function getHwb(string) {
  if (!string) {
    return;
  }

  var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
  var match = string.match(hwb);

  if (match) {
    var alpha = parseFloat(match[4]);
    var h = scale(parseInt(match[1]), 0, 360),
        w = scale(parseFloat(match[2]), 0, 100),
        b = scale(parseFloat(match[3]), 0, 100),
        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, w, b, a];
  }
}

function getRgb(string) {
  var rgba = getRgba(string);
  return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
  var vals = getRgba(string);

  if (vals) {
    return vals[3];
  } else if (vals = getHsla(string)) {
    return vals[3];
  } else if (vals = getHwb(string)) {
    return vals[3];
  }
} // generators


function hexString(rgb) {
  return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
  if (alpha < 1 || rgba[3] && rgba[3] < 1) {
    return rgbaString(rgba, alpha);
  }

  return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
  if (alpha === undefined) {
    alpha = rgba[3] !== undefined ? rgba[3] : 1;
  }

  return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
  if (alpha < 1 || rgba[3] && rgba[3] < 1) {
    return percentaString(rgba, alpha);
  }

  var r = Math.round(rgba[0] / 255 * 100),
      g = Math.round(rgba[1] / 255 * 100),
      b = Math.round(rgba[2] / 255 * 100);
  return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
  var r = Math.round(rgba[0] / 255 * 100),
      g = Math.round(rgba[1] / 255 * 100),
      b = Math.round(rgba[2] / 255 * 100);
  return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
  if (alpha < 1 || hsla[3] && hsla[3] < 1) {
    return hslaString(hsla, alpha);
  }

  return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
  if (alpha === undefined) {
    alpha = hsla[3] !== undefined ? hsla[3] : 1;
  }

  return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
} // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)


function hwbString(hwb, alpha) {
  if (alpha === undefined) {
    alpha = hwb[3] !== undefined ? hwb[3] : 1;
  }

  return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
} // helpers


function scale(num, min, max) {
  return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return str.length < 2 ? "0" + str : str;
} //create a list of reverse color names


var reverseNames = {};

for (var name in colorNames) {
  reverseNames[colorNames[name]] = name;
}

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

defaults._set('global', {
  elements: {
    arc: {
      backgroundColor: defaults.global.defaultColor,
      borderColor: '#fff',
      borderWidth: 2
    }
  }
});

module.exports = Element.extend({
  inLabelRange: function (mouseX) {
    var vm = this._view;

    if (vm) {
      return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
    }

    return false;
  },
  inRange: function (chartX, chartY) {
    var vm = this._view;

    if (vm) {
      var pointRelativePosition = helpers.getAngleFromPoint(vm, {
        x: chartX,
        y: chartY
      });
      var angle = pointRelativePosition.angle;
      var distance = pointRelativePosition.distance; // Sanitise angle range

      var startAngle = vm.startAngle;
      var endAngle = vm.endAngle;

      while (endAngle < startAngle) {
        endAngle += 2.0 * Math.PI;
      }

      while (angle > endAngle) {
        angle -= 2.0 * Math.PI;
      }

      while (angle < startAngle) {
        angle += 2.0 * Math.PI;
      } // Check if within the range of the open/close angle


      var betweenAngles = angle >= startAngle && angle <= endAngle;
      var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
      return betweenAngles && withinRadius;
    }

    return false;
  },
  getCenterPoint: function () {
    var vm = this._view;
    var halfAngle = (vm.startAngle + vm.endAngle) / 2;
    var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
    return {
      x: vm.x + Math.cos(halfAngle) * halfRadius,
      y: vm.y + Math.sin(halfAngle) * halfRadius
    };
  },
  getArea: function () {
    var vm = this._view;
    return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
  },
  tooltipPosition: function () {
    var vm = this._view;
    var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
    var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
    return {
      x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
      y: vm.y + Math.sin(centreAngle) * rangeFromCentre
    };
  },
  draw: function () {
    var ctx = this._chart.ctx;
    var vm = this._view;
    var sA = vm.startAngle;
    var eA = vm.endAngle;
    ctx.beginPath();
    ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
    ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
    ctx.closePath();
    ctx.strokeStyle = vm.borderColor;
    ctx.lineWidth = vm.borderWidth;
    ctx.fillStyle = vm.backgroundColor;
    ctx.fill();
    ctx.lineJoin = 'bevel';

    if (vm.borderWidth) {
      ctx.stroke();
    }
  }
});

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

var globalDefaults = defaults.global;

defaults._set('global', {
  elements: {
    line: {
      tension: 0.4,
      backgroundColor: globalDefaults.defaultColor,
      borderWidth: 3,
      borderColor: globalDefaults.defaultColor,
      borderCapStyle: 'butt',
      borderDash: [],
      borderDashOffset: 0.0,
      borderJoinStyle: 'miter',
      capBezierPoints: true,
      fill: true // do we fill in the area between the line and its base axis

    }
  }
});

module.exports = Element.extend({
  draw: function () {
    var me = this;
    var vm = me._view;
    var ctx = me._chart.ctx;
    var spanGaps = vm.spanGaps;

    var points = me._children.slice(); // clone array


    var globalOptionLineElements = globalDefaults.elements.line;
    var lastDrawnIndex = -1;
    var index, current, previous, currentVM; // If we are looping, adding the first point again

    if (me._loop && points.length) {
      points.push(points[0]);
    }

    ctx.save(); // Stroke Line Options

    ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

    if (ctx.setLineDash) {
      ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
    }

    ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
    ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
    ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
    ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

    ctx.beginPath();
    lastDrawnIndex = -1;

    for (index = 0; index < points.length; ++index) {
      current = points[index];
      previous = helpers.previousItem(points, index);
      currentVM = current._view; // First point moves to it's starting position no matter what

      if (index === 0) {
        if (!currentVM.skip) {
          ctx.moveTo(currentVM.x, currentVM.y);
          lastDrawnIndex = index;
        }
      } else {
        previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

        if (!currentVM.skip) {
          if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
            // There was a gap and this is the first point after the gap
            ctx.moveTo(currentVM.x, currentVM.y);
          } else {
            // Line to next point
            helpers.canvas.lineTo(ctx, previous._view, current._view);
          }

          lastDrawnIndex = index;
        }
      }
    }

    ctx.stroke();
    ctx.restore();
  }
});

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

var defaultColor = defaults.global.defaultColor;

defaults._set('global', {
  elements: {
    point: {
      radius: 3,
      pointStyle: 'circle',
      backgroundColor: defaultColor,
      borderColor: defaultColor,
      borderWidth: 1,
      // Hover
      hitRadius: 1,
      hoverRadius: 4,
      hoverBorderWidth: 1
    }
  }
});

function xRange(mouseX) {
  var vm = this._view;
  return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
}

function yRange(mouseY) {
  var vm = this._view;
  return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
}

module.exports = Element.extend({
  inRange: function (mouseX, mouseY) {
    var vm = this._view;
    return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
  },
  inLabelRange: xRange,
  inXRange: xRange,
  inYRange: yRange,
  getCenterPoint: function () {
    var vm = this._view;
    return {
      x: vm.x,
      y: vm.y
    };
  },
  getArea: function () {
    return Math.PI * Math.pow(this._view.radius, 2);
  },
  tooltipPosition: function () {
    var vm = this._view;
    return {
      x: vm.x,
      y: vm.y,
      padding: vm.radius + vm.borderWidth
    };
  },
  draw: function (chartArea) {
    var vm = this._view;
    var model = this._model;
    var ctx = this._chart.ctx;
    var pointStyle = vm.pointStyle;
    var rotation = vm.rotation;
    var radius = vm.radius;
    var x = vm.x;
    var y = vm.y;
    var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)

    if (vm.skip) {
      return;
    } // Clipping for Points.


    if (chartArea === undefined || model.x >= chartArea.left && chartArea.right * errMargin >= model.x && model.y >= chartArea.top && chartArea.bottom * errMargin >= model.y) {
      ctx.strokeStyle = vm.borderColor || defaultColor;
      ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
      ctx.fillStyle = vm.backgroundColor || defaultColor;
      helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
    }
  }
});

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

defaults._set('global', {
  elements: {
    rectangle: {
      backgroundColor: defaults.global.defaultColor,
      borderColor: defaults.global.defaultColor,
      borderSkipped: 'bottom',
      borderWidth: 0
    }
  }
});

function isVertical(bar) {
  return bar._view.width !== undefined;
}
/**
 * Helper function to get the bounds of the bar regardless of the orientation
 * @param bar {Chart.Element.Rectangle} the bar
 * @return {Bounds} bounds of the bar
 * @private
 */


function getBarBounds(bar) {
  var vm = bar._view;
  var x1, x2, y1, y2;

  if (isVertical(bar)) {
    // vertical
    var halfWidth = vm.width / 2;
    x1 = vm.x - halfWidth;
    x2 = vm.x + halfWidth;
    y1 = Math.min(vm.y, vm.base);
    y2 = Math.max(vm.y, vm.base);
  } else {
    // horizontal bar
    var halfHeight = vm.height / 2;
    x1 = Math.min(vm.x, vm.base);
    x2 = Math.max(vm.x, vm.base);
    y1 = vm.y - halfHeight;
    y2 = vm.y + halfHeight;
  }

  return {
    left: x1,
    top: y1,
    right: x2,
    bottom: y2
  };
}

module.exports = Element.extend({
  draw: function () {
    var ctx = this._chart.ctx;
    var vm = this._view;
    var left, right, top, bottom, signX, signY, borderSkipped;
    var borderWidth = vm.borderWidth;

    if (!vm.horizontal) {
      // bar
      left = vm.x - vm.width / 2;
      right = vm.x + vm.width / 2;
      top = vm.y;
      bottom = vm.base;
      signX = 1;
      signY = bottom > top ? 1 : -1;
      borderSkipped = vm.borderSkipped || 'bottom';
    } else {
      // horizontal bar
      left = vm.base;
      right = vm.x;
      top = vm.y - vm.height / 2;
      bottom = vm.y + vm.height / 2;
      signX = right > left ? 1 : -1;
      signY = 1;
      borderSkipped = vm.borderSkipped || 'left';
    } // Canvas doesn't allow us to stroke inside the width so we can
    // adjust the sizes to fit if we're setting a stroke on the line


    if (borderWidth) {
      // borderWidth shold be less than bar width and bar height.
      var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
      borderWidth = borderWidth > barSize ? barSize : borderWidth;
      var halfStroke = borderWidth / 2; // Adjust borderWidth when bar top position is near vm.base(zero).

      var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
      var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
      var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
      var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0); // not become a vertical line?

      if (borderLeft !== borderRight) {
        top = borderTop;
        bottom = borderBottom;
      } // not become a horizontal line?


      if (borderTop !== borderBottom) {
        left = borderLeft;
        right = borderRight;
      }
    }

    ctx.beginPath();
    ctx.fillStyle = vm.backgroundColor;
    ctx.strokeStyle = vm.borderColor;
    ctx.lineWidth = borderWidth; // Corner points, from bottom-left to bottom-right clockwise
    // | 1 2 |
    // | 0 3 |

    var corners = [[left, bottom], [left, top], [right, top], [right, bottom]]; // Find first (starting) corner with fallback to 'bottom'

    var borders = ['bottom', 'left', 'top', 'right'];
    var startCorner = borders.indexOf(borderSkipped, 0);

    if (startCorner === -1) {
      startCorner = 0;
    }

    function cornerAt(index) {
      return corners[(startCorner + index) % 4];
    } // Draw rectangle from 'startCorner'


    var corner = cornerAt(0);
    ctx.moveTo(corner[0], corner[1]);

    for (var i = 1; i < 4; i++) {
      corner = cornerAt(i);
      ctx.lineTo(corner[0], corner[1]);
    }

    ctx.fill();

    if (borderWidth) {
      ctx.stroke();
    }
  },
  height: function () {
    var vm = this._view;
    return vm.base - vm.y;
  },
  inRange: function (mouseX, mouseY) {
    var inRange = false;

    if (this._view) {
      var bounds = getBarBounds(this);
      inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
    }

    return inRange;
  },
  inLabelRange: function (mouseX, mouseY) {
    var me = this;

    if (!me._view) {
      return false;
    }

    var inRange = false;
    var bounds = getBarBounds(me);

    if (isVertical(me)) {
      inRange = mouseX >= bounds.left && mouseX <= bounds.right;
    } else {
      inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
    }

    return inRange;
  },
  inXRange: function (mouseX) {
    var bounds = getBarBounds(this);
    return mouseX >= bounds.left && mouseX <= bounds.right;
  },
  inYRange: function (mouseY) {
    var bounds = getBarBounds(this);
    return mouseY >= bounds.top && mouseY <= bounds.bottom;
  },
  getCenterPoint: function () {
    var vm = this._view;
    var x, y;

    if (isVertical(this)) {
      x = vm.x;
      y = (vm.y + vm.base) / 2;
    } else {
      x = (vm.x + vm.base) / 2;
      y = vm.y;
    }

    return {
      x: x,
      y: y
    };
  },
  getArea: function () {
    var vm = this._view;
    return vm.width * Math.abs(vm.y - vm.base);
  },
  tooltipPosition: function () {
    var vm = this._view;
    return {
      x: vm.x,
      y: vm.y
    };
  }
});

/***/ }),
/* 469 */
/***/ (function(module, exports) {

/**
 * Platform fallback implementation (minimal).
 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
 */
module.exports = {
  acquireContext: function (item) {
    if (item && item.canvas) {
      // Support for any object associated to a canvas (including a context2d)
      item = item.canvas;
    }

    return item && item.getContext('2d') || null;
  }
};

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Chart.Platform implementation for targeting a web browser
 */


var helpers = __webpack_require__(2);

var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
/**
 * DOM event types -> Chart.js event types.
 * Note: only events with different types are mapped.
 * @see https://developer.mozilla.org/en-US/docs/Web/Events
 */

var EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns {Number} Size in pixels or undefined if unknown.
 */

function readUsedSize(element, property) {
  var value = helpers.getStyle(element, property);
  var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? Number(matches[1]) : undefined;
}
/**
 * Initializes the canvas style and render size without modifying the canvas display size,
 * since responsiveness is handled by the controller.resize() method. The config is used
 * to determine the aspect ratio to apply in case no explicit height has been specified.
 */


function initCanvas(canvas, config) {
  var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
  // returns null or '' if no explicit value has been set to the canvas attribute.

  var renderHeight = canvas.getAttribute('height');
  var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  }; // Force canvas to display as block to avoid extra space caused by inline
  // elements, which would interfere with the responsive resize process.
  // https://github.com/chartjs/Chart.js/issues/2538

  style.display = style.display || 'block';

  if (renderWidth === null || renderWidth === '') {
    var displayWidth = readUsedSize(canvas, 'width');

    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }

  if (renderHeight === null || renderHeight === '') {
    if (canvas.style.height === '') {
      // If no explicit render height and style height, let's apply the aspect ratio,
      // which one can be specified by the user but also by charts as default option
      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
      canvas.height = canvas.width / (config.options.aspectRatio || 2);
    } else {
      var displayHeight = readUsedSize(canvas, 'height');

      if (displayWidth !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }

  return canvas;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */


var supportsEventListenerOptions = function () {
  var supports = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function () {
        supports = true;
      }
    });
    window.addEventListener('e', null, options);
  } catch (e) {// continue regardless of error
  }

  return supports;
}(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
// https://github.com/chartjs/Chart.js/issues/4287


var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;

function addEventListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}

function removeEventListener(node, type, listener) {
  node.removeEventListener(type, listener, eventListenerOptions);
}

function createEvent(type, chart, x, y, nativeEvent) {
  return {
    type: type,
    chart: chart,
    native: nativeEvent || null,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null
  };
}

function fromNativeEvent(event, chart) {
  var type = EVENT_TYPES[event.type] || event.type;
  var pos = helpers.getRelativePosition(event, chart);
  return createEvent(type, chart, pos.x, pos.y, event);
}

function throttled(fn, thisArg) {
  var ticking = false;
  var args = [];
  return function () {
    args = Array.prototype.slice.call(arguments);
    thisArg = thisArg || this;

    if (!ticking) {
      ticking = true;
      helpers.requestAnimFrame.call(window, function () {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
} // Implementation based on https://github.com/marcj/css-element-queries


function createResizer(handler) {
  var resizer = document.createElement('div');
  var cls = CSS_PREFIX + 'size-monitor';
  var maxSize = 1000000;
  var style = 'position:absolute;' + 'left:0;' + 'top:0;' + 'right:0;' + 'bottom:0;' + 'overflow:hidden;' + 'pointer-events:none;' + 'visibility:hidden;' + 'z-index:-1;';
  resizer.style.cssText = style;
  resizer.className = cls;
  resizer.innerHTML = '<div class="' + cls + '-expand" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:' + maxSize + 'px;' + 'height:' + maxSize + 'px;' + 'left:0;' + 'top:0">' + '</div>' + '</div>' + '<div class="' + cls + '-shrink" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:200%;' + 'height:200%;' + 'left:0; ' + 'top:0">' + '</div>' + '</div>';
  var expand = resizer.childNodes[0];
  var shrink = resizer.childNodes[1];

  resizer._reset = function () {
    expand.scrollLeft = maxSize;
    expand.scrollTop = maxSize;
    shrink.scrollLeft = maxSize;
    shrink.scrollTop = maxSize;
  };

  var onScroll = function () {
    resizer._reset();

    handler();
  };

  addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
  addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
  return resizer;
} // https://davidwalsh.name/detect-node-insertion


function watchForRender(node, handler) {
  var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

  var proxy = expando.renderProxy = function (e) {
    if (e.animationName === CSS_RENDER_ANIMATION) {
      handler();
    }
  };

  helpers.each(ANIMATION_START_EVENTS, function (type) {
    addEventListener(node, type, proxy);
  }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
  // is removed then added back immediately (same animation frame?). Accessing the
  // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
  // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
  // https://github.com/chartjs/Chart.js/issues/4737

  expando.reflow = !!node.offsetParent;
  node.classList.add(CSS_RENDER_MONITOR);
}

function unwatchForRender(node) {
  var expando = node[EXPANDO_KEY] || {};
  var proxy = expando.renderProxy;

  if (proxy) {
    helpers.each(ANIMATION_START_EVENTS, function (type) {
      removeEventListener(node, type, proxy);
    });
    delete expando.renderProxy;
  }

  node.classList.remove(CSS_RENDER_MONITOR);
}

function addResizeListener(node, listener, chart) {
  var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

  var resizer = expando.resizer = createResizer(throttled(function () {
    if (expando.resizer) {
      return listener(createEvent('resize', chart));
    }
  })); // The resizer needs to be attached to the node parent, so we first need to be
  // sure that `node` is attached to the DOM before injecting the resizer element.

  watchForRender(node, function () {
    if (expando.resizer) {
      var container = node.parentNode;

      if (container && container !== resizer.parentNode) {
        container.insertBefore(resizer, container.firstChild);
      } // The container size might have changed, let's reset the resizer state.


      resizer._reset();
    }
  });
}

function removeResizeListener(node) {
  var expando = node[EXPANDO_KEY] || {};
  var resizer = expando.resizer;
  delete expando.resizer;
  unwatchForRender(node);

  if (resizer && resizer.parentNode) {
    resizer.parentNode.removeChild(resizer);
  }
}

function injectCSS(platform, css) {
  // http://stackoverflow.com/q/3922139
  var style = platform._style || document.createElement('style');

  if (!platform._style) {
    platform._style = style;
    css = '/* Chart.js */\n' + css;
    style.setAttribute('type', 'text/css');
    document.getElementsByTagName('head')[0].appendChild(style);
  }

  style.appendChild(document.createTextNode(css));
}

module.exports = {
  /**
   * This property holds whether this platform is enabled for the current environment.
   * Currently used by platform.js to select the proper implementation.
   * @private
   */
  _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
  initialize: function () {
    var keyframes = 'from{opacity:0.99}to{opacity:1}';
    injectCSS(this, // DOM rendering detection
    // https://davidwalsh.name/detect-node-insertion
    '@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '.' + CSS_RENDER_MONITOR + '{' + '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + 'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + '}');
  },
  acquireContext: function (item, config) {
    if (typeof item === 'string') {
      item = document.getElementById(item);
    } else if (item.length) {
      // Support for array based queries (such as jQuery)
      item = item[0];
    }

    if (item && item.canvas) {
      // Support for any object associated to a canvas (including a context2d)
      item = item.canvas;
    } // To prevent canvas fingerprinting, some add-ons undefine the getContext
    // method, for example: https://github.com/kkapsner/CanvasBlocker
    // https://github.com/chartjs/Chart.js/issues/2807


    var context = item && item.getContext && item.getContext('2d'); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
    // inside an iframe or when running in a protected environment. We could guess the
    // types from their toString() value but let's keep things flexible and assume it's
    // a sufficient condition if the item has a context2D which has item as `canvas`.
    // https://github.com/chartjs/Chart.js/issues/3887
    // https://github.com/chartjs/Chart.js/issues/4102
    // https://github.com/chartjs/Chart.js/issues/4152

    if (context && context.canvas === item) {
      initCanvas(item, config);
      return context;
    }

    return null;
  },
  releaseContext: function (context) {
    var canvas = context.canvas;

    if (!canvas[EXPANDO_KEY]) {
      return;
    }

    var initial = canvas[EXPANDO_KEY].initial;
    ['height', 'width'].forEach(function (prop) {
      var value = initial[prop];

      if (helpers.isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    helpers.each(initial.style || {}, function (value, key) {
      canvas.style[key] = value;
    }); // The canvas render size might have been changed (and thus the state stack discarded),
    // we can't use save() and restore() to restore the initial state. So make sure that at
    // least the canvas context is reset to the default state by setting the canvas width.
    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html

    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
  },
  addEventListener: function (chart, type, listener) {
    var canvas = chart.canvas;

    if (type === 'resize') {
      // Note: the resize event is not supported on all browsers.
      addResizeListener(canvas, listener, chart);
      return;
    }

    var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
    var proxies = expando.proxies || (expando.proxies = {});

    var proxy = proxies[chart.id + '_' + type] = function (event) {
      listener(fromNativeEvent(event, chart));
    };

    addEventListener(canvas, type, proxy);
  },
  removeEventListener: function (chart, type, listener) {
    var canvas = chart.canvas;

    if (type === 'resize') {
      // Note: the resize event is not supported on all browsers.
      removeResizeListener(canvas, listener);
      return;
    }

    var expando = listener[EXPANDO_KEY] || {};
    var proxies = expando.proxies || {};
    var proxy = proxies[chart.id + '_' + type];

    if (!proxy) {
      return;
    }

    removeEventListener(canvas, type, proxy);
  }
}; // DEPRECATIONS

/**
 * Provided for backward compatibility, use EventTarget.addEventListener instead.
 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * @function Chart.helpers.addEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.addEvent = addEventListener;
/**
 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
 * @function Chart.helpers.removeEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */

helpers.removeEvent = removeEventListener;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Animation = __webpack_require__(133);

var animations = __webpack_require__(134);

var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

var Interaction = __webpack_require__(135);

var layouts = __webpack_require__(55);

var platform = __webpack_require__(136);

var plugins = __webpack_require__(137);

var scaleService = __webpack_require__(34);

var Tooltip = __webpack_require__(138);

module.exports = function (Chart) {
  // Create a dictionary of chart types, to allow for extension of existing types
  Chart.types = {}; // Store a reference to each instance - allowing us to globally resize chart instances on window resize.
  // Destroy method on the chart will remove the instance of the chart from this reference.

  Chart.instances = {}; // Controllers available for dataset visualization eg. bar, line, slice, etc.

  Chart.controllers = {};
  /**
   * Initializes the given config with global and chart default values.
   */

  function initConfig(config) {
    config = config || {}; // Do NOT use configMerge() for the data object because this method merges arrays
    // and so would change references to labels and datasets, preventing data updates.

    var data = config.data = config.data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    config.options = helpers.configMerge(defaults.global, defaults[config.type], config.options || {});
    return config;
  }
  /**
   * Updates the config of the chart
   * @param chart {Chart} chart to update the options for
   */


  function updateConfig(chart) {
    var newOptions = chart.options;
    helpers.each(chart.scales, function (scale) {
      layouts.removeBox(chart, scale);
    });
    newOptions = helpers.configMerge(Chart.defaults.global, Chart.defaults[chart.config.type], newOptions);
    chart.options = chart.config.options = newOptions;
    chart.ensureScalesHaveIDs();
    chart.buildOrUpdateScales(); // Tooltip

    chart.tooltip._options = newOptions.tooltips;
    chart.tooltip.initialize();
  }

  function positionIsHorizontal(position) {
    return position === 'top' || position === 'bottom';
  }

  helpers.extend(Chart.prototype,
  /** @lends Chart */
  {
    /**
     * @private
     */
    construct: function (item, config) {
      var me = this;
      config = initConfig(config);
      var context = platform.acquireContext(item, config);
      var canvas = context && context.canvas;
      var height = canvas && canvas.height;
      var width = canvas && canvas.width;
      me.id = helpers.uid();
      me.ctx = context;
      me.canvas = canvas;
      me.config = config;
      me.width = width;
      me.height = height;
      me.aspectRatio = height ? width / height : null;
      me.options = config.options;
      me._bufferedRender = false;
      /**
       * Provided for backward compatibility, Chart and Chart.Controller have been merged,
       * the "instance" still need to be defined since it might be called from plugins.
       * @prop Chart#chart
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */

      me.chart = me;
      me.controller = me; // chart.chart.controller #inception
      // Add the chart instance to the global namespace

      Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

      Object.defineProperty(me, 'data', {
        get: function () {
          return me.config.data;
        },
        set: function (value) {
          me.config.data = value;
        }
      });

      if (!context || !canvas) {
        // The given item is not a compatible context2d element, let's return before finalizing
        // the chart initialization but after setting basic chart / controller properties that
        // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
        // https://github.com/chartjs/Chart.js/issues/2807
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }

      me.initialize();
      me.update();
    },

    /**
     * @private
     */
    initialize: function () {
      var me = this; // Before init plugin notification

      plugins.notify(me, 'beforeInit');
      helpers.retinaScale(me, me.options.devicePixelRatio);
      me.bindEvents();

      if (me.options.responsive) {
        // Initial resize before chart draws (must be silent to preserve initial animations).
        me.resize(true);
      } // Make sure scales have IDs and are built before we build any controllers.


      me.ensureScalesHaveIDs();
      me.buildOrUpdateScales();
      me.initToolTip(); // After init plugin notification

      plugins.notify(me, 'afterInit');
      return me;
    },
    clear: function () {
      helpers.canvas.clear(this);
      return this;
    },
    stop: function () {
      // Stops any current animation loop occurring
      animations.cancelAnimation(this);
      return this;
    },
    resize: function (silent) {
      var me = this;
      var options = me.options;
      var canvas = me.canvas;
      var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
      // the canvas display style uses the same integer values to avoid blurring effect.
      // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

      var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
      var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

      if (me.width === newWidth && me.height === newHeight) {
        return;
      }

      canvas.width = me.width = newWidth;
      canvas.height = me.height = newHeight;
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';
      helpers.retinaScale(me, options.devicePixelRatio);

      if (!silent) {
        // Notify any plugins about the resize
        var newSize = {
          width: newWidth,
          height: newHeight
        };
        plugins.notify(me, 'resize', [newSize]); // Notify of resize

        if (me.options.onResize) {
          me.options.onResize(me, newSize);
        }

        me.stop();
        me.update({
          duration: me.options.responsiveAnimationDuration
        });
      }
    },
    ensureScalesHaveIDs: function () {
      var options = this.options;
      var scalesOptions = options.scales || {};
      var scaleOptions = options.scale;
      helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
        xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
      });
      helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
        yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
      });

      if (scaleOptions) {
        scaleOptions.id = scaleOptions.id || 'scale';
      }
    },

    /**
     * Builds a map of scale ID to scale object for future lookup.
     */
    buildOrUpdateScales: function () {
      var me = this;
      var options = me.options;
      var scales = me.scales || {};
      var items = [];
      var updated = Object.keys(scales).reduce(function (obj, id) {
        obj[id] = false;
        return obj;
      }, {});

      if (options.scales) {
        items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
          return {
            options: xAxisOptions,
            dtype: 'category',
            dposition: 'bottom'
          };
        }), (options.scales.yAxes || []).map(function (yAxisOptions) {
          return {
            options: yAxisOptions,
            dtype: 'linear',
            dposition: 'left'
          };
        }));
      }

      if (options.scale) {
        items.push({
          options: options.scale,
          dtype: 'radialLinear',
          isDefault: true,
          dposition: 'chartArea'
        });
      }

      helpers.each(items, function (item) {
        var scaleOptions = item.options;
        var id = scaleOptions.id;
        var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);

        if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }

        updated[id] = true;
        var scale = null;

        if (id in scales && scales[id].type === scaleType) {
          scale = scales[id];
          scale.options = scaleOptions;
          scale.ctx = me.ctx;
          scale.chart = me;
        } else {
          var scaleClass = scaleService.getScaleConstructor(scaleType);

          if (!scaleClass) {
            return;
          }

          scale = new scaleClass({
            id: id,
            type: scaleType,
            options: scaleOptions,
            ctx: me.ctx,
            chart: me
          });
          scales[scale.id] = scale;
        }

        scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
        // and consider it as a regular scale part of the "scales"" map only! This would
        // make the logic easier and remove some useless? custom code.

        if (item.isDefault) {
          me.scale = scale;
        }
      }); // clear up discarded scales

      helpers.each(updated, function (hasUpdated, id) {
        if (!hasUpdated) {
          delete scales[id];
        }
      });
      me.scales = scales;
      scaleService.addScalesToLayout(this);
    },
    buildOrUpdateControllers: function () {
      var me = this;
      var types = [];
      var newControllers = [];
      helpers.each(me.data.datasets, function (dataset, datasetIndex) {
        var meta = me.getDatasetMeta(datasetIndex);
        var type = dataset.type || me.config.type;

        if (meta.type && meta.type !== type) {
          me.destroyDatasetMeta(datasetIndex);
          meta = me.getDatasetMeta(datasetIndex);
        }

        meta.type = type;
        types.push(meta.type);

        if (meta.controller) {
          meta.controller.updateIndex(datasetIndex);
          meta.controller.linkScales();
        } else {
          var ControllerClass = Chart.controllers[meta.type];

          if (ControllerClass === undefined) {
            throw new Error('"' + meta.type + '" is not a chart type.');
          }

          meta.controller = new ControllerClass(me, datasetIndex);
          newControllers.push(meta.controller);
        }
      }, me);
      return newControllers;
    },

    /**
     * Reset the elements of all datasets
     * @private
     */
    resetElements: function () {
      var me = this;
      helpers.each(me.data.datasets, function (dataset, datasetIndex) {
        me.getDatasetMeta(datasetIndex).controller.reset();
      }, me);
    },

    /**
    * Resets the chart back to it's state before the initial animation
    */
    reset: function () {
      this.resetElements();
      this.tooltip.initialize();
    },
    update: function (config) {
      var me = this;

      if (!config || typeof config !== 'object') {
        // backwards compatibility
        config = {
          duration: config,
          lazy: arguments[1]
        };
      }

      updateConfig(me); // plugins options references might have change, let's invalidate the cache
      // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

      plugins._invalidate(me);

      if (plugins.notify(me, 'beforeUpdate') === false) {
        return;
      } // In case the entire data object changed


      me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

      var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

      helpers.each(me.data.datasets, function (dataset, datasetIndex) {
        me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
      }, me);
      me.updateLayout(); // Can only reset the new controllers after the scales have been updated

      if (me.options.animation && me.options.animation.duration) {
        helpers.each(newControllers, function (controller) {
          controller.reset();
        });
      }

      me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
      // after update.

      me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
      // When we reset the tooltip, we need to clear it

      me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

      plugins.notify(me, 'afterUpdate');

      if (me._bufferedRender) {
        me._bufferedRequest = {
          duration: config.duration,
          easing: config.easing,
          lazy: config.lazy
        };
      } else {
        me.render(config);
      }
    },

    /**
     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
     * hook, in which case, plugins will not be called on `afterLayout`.
     * @private
     */
    updateLayout: function () {
      var me = this;

      if (plugins.notify(me, 'beforeLayout') === false) {
        return;
      }

      layouts.update(this, this.width, this.height);
      /**
       * Provided for backward compatibility, use `afterLayout` instead.
       * @method IPlugin#afterScaleUpdate
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */

      plugins.notify(me, 'afterScaleUpdate');
      plugins.notify(me, 'afterLayout');
    },

    /**
     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
     * @private
     */
    updateDatasets: function () {
      var me = this;

      if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
        return;
      }

      for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
        me.updateDataset(i);
      }

      plugins.notify(me, 'afterDatasetsUpdate');
    },

    /**
     * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
     * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
     * @private
     */
    updateDataset: function (index) {
      var me = this;
      var meta = me.getDatasetMeta(index);
      var args = {
        meta: meta,
        index: index
      };

      if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
        return;
      }

      meta.controller.update();
      plugins.notify(me, 'afterDatasetUpdate', [args]);
    },
    render: function (config) {
      var me = this;

      if (!config || typeof config !== 'object') {
        // backwards compatibility
        config = {
          duration: config,
          lazy: arguments[1]
        };
      }

      var duration = config.duration;
      var lazy = config.lazy;

      if (plugins.notify(me, 'beforeRender') === false) {
        return;
      }

      var animationOptions = me.options.animation;

      var onComplete = function (animation) {
        plugins.notify(me, 'afterRender');
        helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
      };

      if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
        var animation = new Animation({
          numSteps: (duration || animationOptions.duration) / 16.66,
          // 60 fps
          easing: config.easing || animationOptions.easing,
          render: function (chart, animationObject) {
            var easingFunction = helpers.easing.effects[animationObject.easing];
            var currentStep = animationObject.currentStep;
            var stepDecimal = currentStep / animationObject.numSteps;
            chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
          },
          onAnimationProgress: animationOptions.onProgress,
          onAnimationComplete: onComplete
        });
        animations.addAnimation(me, animation, duration, lazy);
      } else {
        me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

        onComplete(new Animation({
          numSteps: 0,
          chart: me
        }));
      }

      return me;
    },
    draw: function (easingValue) {
      var me = this;
      me.clear();

      if (helpers.isNullOrUndef(easingValue)) {
        easingValue = 1;
      }

      me.transition(easingValue);

      if (me.width <= 0 || me.height <= 0) {
        return;
      }

      if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
        return;
      } // Draw all the scales


      helpers.each(me.boxes, function (box) {
        box.draw(me.chartArea);
      }, me);

      if (me.scale) {
        me.scale.draw();
      }

      me.drawDatasets(easingValue);

      me._drawTooltip(easingValue);

      plugins.notify(me, 'afterDraw', [easingValue]);
    },

    /**
     * @private
     */
    transition: function (easingValue) {
      var me = this;

      for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
        if (me.isDatasetVisible(i)) {
          me.getDatasetMeta(i).controller.transition(easingValue);
        }
      }

      me.tooltip.transition(easingValue);
    },

    /**
     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
     * @private
     */
    drawDatasets: function (easingValue) {
      var me = this;

      if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
        return;
      } // Draw datasets reversed to support proper line stacking


      for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
        if (me.isDatasetVisible(i)) {
          me.drawDataset(i, easingValue);
        }
      }

      plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
    },

    /**
     * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
     * hook, in which case, plugins will not be called on `afterDatasetDraw`.
     * @private
     */
    drawDataset: function (index, easingValue) {
      var me = this;
      var meta = me.getDatasetMeta(index);
      var args = {
        meta: meta,
        index: index,
        easingValue: easingValue
      };

      if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
        return;
      }

      meta.controller.draw(easingValue);
      plugins.notify(me, 'afterDatasetDraw', [args]);
    },

    /**
     * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
     * hook, in which case, plugins will not be called on `afterTooltipDraw`.
     * @private
     */
    _drawTooltip: function (easingValue) {
      var me = this;
      var tooltip = me.tooltip;
      var args = {
        tooltip: tooltip,
        easingValue: easingValue
      };

      if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
        return;
      }

      tooltip.draw();
      plugins.notify(me, 'afterTooltipDraw', [args]);
    },
    // Get the single element that was clicked on
    // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
    getElementAtEvent: function (e) {
      return Interaction.modes.single(this, e);
    },
    getElementsAtEvent: function (e) {
      return Interaction.modes.label(this, e, {
        intersect: true
      });
    },
    getElementsAtXAxis: function (e) {
      return Interaction.modes['x-axis'](this, e, {
        intersect: true
      });
    },
    getElementsAtEventForMode: function (e, mode, options) {
      var method = Interaction.modes[mode];

      if (typeof method === 'function') {
        return method(this, e, options);
      }

      return [];
    },
    getDatasetAtEvent: function (e) {
      return Interaction.modes.dataset(this, e, {
        intersect: true
      });
    },
    getDatasetMeta: function (datasetIndex) {
      var me = this;
      var dataset = me.data.datasets[datasetIndex];

      if (!dataset._meta) {
        dataset._meta = {};
      }

      var meta = dataset._meta[me.id];

      if (!meta) {
        meta = dataset._meta[me.id] = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          // See isDatasetVisible() comment
          xAxisID: null,
          yAxisID: null
        };
      }

      return meta;
    },
    getVisibleDatasetCount: function () {
      var count = 0;

      for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        if (this.isDatasetVisible(i)) {
          count++;
        }
      }

      return count;
    },
    isDatasetVisible: function (datasetIndex) {
      var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
      // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

      return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
    },
    generateLegend: function () {
      return this.options.legendCallback(this);
    },

    /**
     * @private
     */
    destroyDatasetMeta: function (datasetIndex) {
      var id = this.id;
      var dataset = this.data.datasets[datasetIndex];
      var meta = dataset._meta && dataset._meta[id];

      if (meta) {
        meta.controller.destroy();
        delete dataset._meta[id];
      }
    },
    destroy: function () {
      var me = this;
      var canvas = me.canvas;
      var i, ilen;
      me.stop(); // dataset controllers need to cleanup associated data

      for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
        me.destroyDatasetMeta(i);
      }

      if (canvas) {
        me.unbindEvents();
        helpers.canvas.clear(me);
        platform.releaseContext(me.ctx);
        me.canvas = null;
        me.ctx = null;
      }

      plugins.notify(me, 'destroy');
      delete Chart.instances[me.id];
    },
    toBase64Image: function () {
      return this.canvas.toDataURL.apply(this.canvas, arguments);
    },
    initToolTip: function () {
      var me = this;
      me.tooltip = new Tooltip({
        _chart: me,
        _chartInstance: me,
        // deprecated, backward compatibility
        _data: me.data,
        _options: me.options.tooltips
      }, me);
    },

    /**
     * @private
     */
    bindEvents: function () {
      var me = this;
      var listeners = me._listeners = {};

      var listener = function () {
        me.eventHandler.apply(me, arguments);
      };

      helpers.each(me.options.events, function (type) {
        platform.addEventListener(me, type, listener);
        listeners[type] = listener;
      }); // Elements used to detect size change should not be injected for non responsive charts.
      // See https://github.com/chartjs/Chart.js/issues/2210

      if (me.options.responsive) {
        listener = function () {
          me.resize();
        };

        platform.addEventListener(me, 'resize', listener);
        listeners.resize = listener;
      }
    },

    /**
     * @private
     */
    unbindEvents: function () {
      var me = this;
      var listeners = me._listeners;

      if (!listeners) {
        return;
      }

      delete me._listeners;
      helpers.each(listeners, function (listener, type) {
        platform.removeEventListener(me, type, listener);
      });
    },
    updateHoverStyle: function (elements, mode, enabled) {
      var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
      var element, i, ilen;

      for (i = 0, ilen = elements.length; i < ilen; ++i) {
        element = elements[i];

        if (element) {
          this.getDatasetMeta(element._datasetIndex).controller[method](element);
        }
      }
    },

    /**
     * @private
     */
    eventHandler: function (e) {
      var me = this;
      var tooltip = me.tooltip;

      if (plugins.notify(me, 'beforeEvent', [e]) === false) {
        return;
      } // Buffer any update calls so that renders do not occur


      me._bufferedRender = true;
      me._bufferedRequest = null;
      var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
      // the tooltip should be the source of change
      // Animation check workaround:
      // tooltip._start will be null when tooltip isn't animating

      if (tooltip) {
        changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
      }

      plugins.notify(me, 'afterEvent', [e]);
      var bufferedRequest = me._bufferedRequest;

      if (bufferedRequest) {
        // If we have an update that was triggered, we need to do a normal render
        me.render(bufferedRequest);
      } else if (changed && !me.animating) {
        // If entering, leaving, or changing elements, animate the change via pivot
        me.stop(); // We only need to render at this point. Updating will cause scales to be
        // recomputed generating flicker & using more memory than necessary.

        me.render({
          duration: me.options.hover.animationDuration,
          lazy: true
        });
      }

      me._bufferedRender = false;
      me._bufferedRequest = null;
      return me;
    },

    /**
     * Handle an event
     * @private
     * @param {IEvent} event the event to handle
     * @return {Boolean} true if the chart needs to re-render
     */
    handleEvent: function (e) {
      var me = this;
      var options = me.options || {};
      var hoverOptions = options.hover;
      var changed = false;
      me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

      if (e.type === 'mouseout') {
        me.active = [];
      } else {
        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
      } // Invoke onHover hook
      // Need to call with native event here to not break backwards compatibility


      helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

      if (e.type === 'mouseup' || e.type === 'click') {
        if (options.onClick) {
          // Use e.native here for backwards compatibility
          options.onClick.call(me, e.native, me.active);
        }
      } // Remove styling for last active (even if it may still be active)


      if (me.lastActive.length) {
        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
      } // Built in hover styling


      if (me.active.length && hoverOptions.mode) {
        me.updateHoverStyle(me.active, hoverOptions.mode, true);
      }

      changed = !helpers.arrayEquals(me.active, me.lastActive); // Remember Last Actives

      me.lastActive = me.active;
      return changed;
    }
  });
  /**
   * Provided for backward compatibility, use Chart instead.
   * @class Chart.Controller
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   * @private
   */

  Chart.Controller = Chart;
};

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);

module.exports = function (Chart) {
  var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
  /**
   * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
   * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
   * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
   */

  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);

      return;
    }

    Object.defineProperty(array, '_chartjs', {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach(function (key) {
      var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
      var base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value: function () {
          var args = Array.prototype.slice.call(arguments);
          var res = base.apply(this, args);
          helpers.each(array._chartjs.listeners, function (object) {
            if (typeof object[method] === 'function') {
              object[method].apply(object, args);
            }
          });
          return res;
        }
      });
    });
  }
  /**
   * Removes the given array event listener and cleanup extra attached properties (such as
   * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
   */


  function unlistenArrayEvents(array, listener) {
    var stub = array._chartjs;

    if (!stub) {
      return;
    }

    var listeners = stub.listeners;
    var index = listeners.indexOf(listener);

    if (index !== -1) {
      listeners.splice(index, 1);
    }

    if (listeners.length > 0) {
      return;
    }

    arrayEvents.forEach(function (key) {
      delete array[key];
    });
    delete array._chartjs;
  } // Base class for all dataset controllers (line, bar, etc)


  Chart.DatasetController = function (chart, datasetIndex) {
    this.initialize(chart, datasetIndex);
  };

  helpers.extend(Chart.DatasetController.prototype, {
    /**
     * Element type used to generate a meta dataset (e.g. Chart.element.Line).
     * @type {Chart.core.element}
     */
    datasetElementType: null,

    /**
     * Element type used to generate a meta data (e.g. Chart.element.Point).
     * @type {Chart.core.element}
     */
    dataElementType: null,
    initialize: function (chart, datasetIndex) {
      var me = this;
      me.chart = chart;
      me.index = datasetIndex;
      me.linkScales();
      me.addElements();
    },
    updateIndex: function (datasetIndex) {
      this.index = datasetIndex;
    },
    linkScales: function () {
      var me = this;
      var meta = me.getMeta();
      var dataset = me.getDataset();

      if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
        meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
      }

      if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
        meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
      }
    },
    getDataset: function () {
      return this.chart.data.datasets[this.index];
    },
    getMeta: function () {
      return this.chart.getDatasetMeta(this.index);
    },
    getScaleForId: function (scaleID) {
      return this.chart.scales[scaleID];
    },
    reset: function () {
      this.update(true);
    },

    /**
     * @private
     */
    destroy: function () {
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
    },
    createMetaDataset: function () {
      var me = this;
      var type = me.datasetElementType;
      return type && new type({
        _chart: me.chart,
        _datasetIndex: me.index
      });
    },
    createMetaData: function (index) {
      var me = this;
      var type = me.dataElementType;
      return type && new type({
        _chart: me.chart,
        _datasetIndex: me.index,
        _index: index
      });
    },
    addElements: function () {
      var me = this;
      var meta = me.getMeta();
      var data = me.getDataset().data || [];
      var metaData = meta.data;
      var i, ilen;

      for (i = 0, ilen = data.length; i < ilen; ++i) {
        metaData[i] = metaData[i] || me.createMetaData(i);
      }

      meta.dataset = meta.dataset || me.createMetaDataset();
    },
    addElementAndReset: function (index) {
      var element = this.createMetaData(index);
      this.getMeta().data.splice(index, 0, element);
      this.updateElement(element, index, true);
    },
    buildOrUpdateElements: function () {
      var me = this;
      var dataset = me.getDataset();
      var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
      // real-time charts), we need to monitor these data modifications and synchronize
      // the internal meta data accordingly.

      if (me._data !== data) {
        if (me._data) {
          // This case happens when the user replaced the data array instance.
          unlistenArrayEvents(me._data, me);
        }

        listenArrayEvents(data, me);
        me._data = data;
      } // Re-sync meta data in case the user replaced the data array or if we missed
      // any updates and so make sure that we handle number of datapoints changing.


      me.resyncElements();
    },
    update: helpers.noop,
    transition: function (easingValue) {
      var meta = this.getMeta();
      var elements = meta.data || [];
      var ilen = elements.length;
      var i = 0;

      for (; i < ilen; ++i) {
        elements[i].transition(easingValue);
      }

      if (meta.dataset) {
        meta.dataset.transition(easingValue);
      }
    },
    draw: function () {
      var meta = this.getMeta();
      var elements = meta.data || [];
      var ilen = elements.length;
      var i = 0;

      if (meta.dataset) {
        meta.dataset.draw();
      }

      for (; i < ilen; ++i) {
        elements[i].draw();
      }
    },
    removeHoverStyle: function (element) {
      helpers.merge(element._model, element.$previousStyle || {});
      delete element.$previousStyle;
    },
    setHoverStyle: function (element) {
      var dataset = this.chart.data.datasets[element._datasetIndex];
      var index = element._index;
      var custom = element.custom || {};
      var valueOrDefault = helpers.valueAtIndexOrDefault;
      var getHoverColor = helpers.getHoverColor;
      var model = element._model;
      element.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
      model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
      model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
    },

    /**
     * @private
     */
    resyncElements: function () {
      var me = this;
      var meta = me.getMeta();
      var data = me.getDataset().data;
      var numMeta = meta.data.length;
      var numData = data.length;

      if (numData < numMeta) {
        meta.data.splice(numData, numMeta - numData);
      } else if (numData > numMeta) {
        me.insertElements(numMeta, numData - numMeta);
      }
    },

    /**
     * @private
     */
    insertElements: function (start, count) {
      for (var i = 0; i < count; ++i) {
        this.addElementAndReset(start + i);
      }
    },

    /**
     * @private
     */
    onDataPush: function () {
      this.insertElements(this.getDataset().data.length - 1, arguments.length);
    },

    /**
     * @private
     */
    onDataPop: function () {
      this.getMeta().data.pop();
    },

    /**
     * @private
     */
    onDataShift: function () {
      this.getMeta().data.shift();
    },

    /**
     * @private
     */
    onDataSplice: function (start, count) {
      this.getMeta().data.splice(start, count);
      this.insertElements(start, arguments.length - 2);
    },

    /**
     * @private
     */
    onDataUnshift: function () {
      this.insertElements(0, arguments.length);
    }
  });
  Chart.DatasetController.extend = helpers.inherits;
};

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);

var Scale = __webpack_require__(56);
/**
 * Generate a set of linear ticks
 * @param generationOptions the options used to generate the ticks
 * @param dataRange the range of the data
 * @returns {Array<Number>} array of tick values
 */


function generateTicks(generationOptions, dataRange) {
  var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
  // "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
  // for details.

  var factor;
  var precision;
  var spacing;

  if (generationOptions.stepSize && generationOptions.stepSize > 0) {
    spacing = generationOptions.stepSize;
  } else {
    var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
    spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
    precision = generationOptions.precision;

    if (precision !== undefined) {
      // If the user specified a precision, round to that number of decimal places
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
  }

  var niceMin = Math.floor(dataRange.min / spacing) * spacing;
  var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

  if (!helpers.isNullOrUndef(generationOptions.min) && !helpers.isNullOrUndef(generationOptions.max) && generationOptions.stepSize) {
    // If very close to our whole number, use it.
    if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
      niceMin = generationOptions.min;
      niceMax = generationOptions.max;
    }
  }

  var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

  if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
    numSpaces = Math.round(numSpaces);
  } else {
    numSpaces = Math.ceil(numSpaces);
  }

  precision = 1;

  if (spacing < 1) {
    precision = Math.pow(10, 1 - Math.floor(helpers.log10(spacing)));
    niceMin = Math.round(niceMin * precision) / precision;
    niceMax = Math.round(niceMax * precision) / precision;
  }

  ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);

  for (var j = 1; j < numSpaces; ++j) {
    ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
  }

  ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
  return ticks;
}

module.exports = function (Chart) {
  var noop = helpers.noop;
  Chart.LinearScaleBase = Scale.extend({
    getRightValue: function (value) {
      if (typeof value === 'string') {
        return +value;
      }

      return Scale.prototype.getRightValue.call(this, value);
    },
    handleTickRangeOptions: function () {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
      // do nothing since that would make the chart weird. If the user really wants a weird chart
      // axis, they can manually override it

      if (tickOpts.beginAtZero) {
        var minSign = helpers.sign(me.min);
        var maxSign = helpers.sign(me.max);

        if (minSign < 0 && maxSign < 0) {
          // move the top up to 0
          me.max = 0;
        } else if (minSign > 0 && maxSign > 0) {
          // move the bottom down to 0
          me.min = 0;
        }
      }

      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

      if (tickOpts.min !== undefined) {
        me.min = tickOpts.min;
      } else if (tickOpts.suggestedMin !== undefined) {
        if (me.min === null) {
          me.min = tickOpts.suggestedMin;
        } else {
          me.min = Math.min(me.min, tickOpts.suggestedMin);
        }
      }

      if (tickOpts.max !== undefined) {
        me.max = tickOpts.max;
      } else if (tickOpts.suggestedMax !== undefined) {
        if (me.max === null) {
          me.max = tickOpts.suggestedMax;
        } else {
          me.max = Math.max(me.max, tickOpts.suggestedMax);
        }
      }

      if (setMin !== setMax) {
        // We set the min or the max but not both.
        // So ensure that our range is good
        // Inverted or 0 length range can happen when
        // ticks.min is set, and no datasets are visible
        if (me.min >= me.max) {
          if (setMin) {
            me.max = me.min + 1;
          } else {
            me.min = me.max - 1;
          }
        }
      }

      if (me.min === me.max) {
        me.max++;

        if (!tickOpts.beginAtZero) {
          me.min--;
        }
      }
    },
    getTickLimit: noop,
    handleDirectionalChanges: noop,
    buildTicks: function () {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
      // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
      // the graph. Make sure we always have at least 2 ticks

      var maxTicks = me.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      var numericGeneratorOptions = {
        maxTicks: maxTicks,
        min: tickOpts.min,
        max: tickOpts.max,
        precision: tickOpts.precision,
        stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
      };
      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
      // range of the scale

      me.max = helpers.max(ticks);
      me.min = helpers.min(ticks);

      if (tickOpts.reverse) {
        ticks.reverse();
        me.start = me.max;
        me.end = me.min;
      } else {
        me.start = me.min;
        me.end = me.max;
      }
    },
    convertTicksToLabels: function () {
      var me = this;
      me.ticksAsNumbers = me.ticks.slice();
      me.zeroLineIndex = me.ticks.indexOf(0);
      Scale.prototype.convertTicksToLabels.call(me);
    }
  });
};

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Scale = __webpack_require__(56);

var scaleService = __webpack_require__(34);

module.exports = function () {
  // Default config for a category scale
  var defaultConfig = {
    position: 'bottom'
  };
  var DatasetScale = Scale.extend({
    /**
    * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
    * else fall back to data.labels
    * @private
    */
    getLabels: function () {
      var data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
    },
    determineDataLimits: function () {
      var me = this;
      var labels = me.getLabels();
      me.minIndex = 0;
      me.maxIndex = labels.length - 1;
      var findIndex;

      if (me.options.ticks.min !== undefined) {
        // user specified min value
        findIndex = labels.indexOf(me.options.ticks.min);
        me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
      }

      if (me.options.ticks.max !== undefined) {
        // user specified max value
        findIndex = labels.indexOf(me.options.ticks.max);
        me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
      }

      me.min = labels[me.minIndex];
      me.max = labels[me.maxIndex];
    },
    buildTicks: function () {
      var me = this;
      var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

      me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
    },
    getLabelForIndex: function (index, datasetIndex) {
      var me = this;
      var data = me.chart.data;
      var isHorizontal = me.isHorizontal();

      if (data.yLabels && !isHorizontal) {
        return me.getRightValue(data.datasets[datasetIndex].data[index]);
      }

      return me.ticks[index - me.minIndex];
    },
    // Used to get data value locations.  Value can either be an index or a numerical value
    getPixelForValue: function (value, index) {
      var me = this;
      var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

      var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
      // not the index of the scale. We need to change that.

      var valueCategory;

      if (value !== undefined && value !== null) {
        valueCategory = me.isHorizontal() ? value.x : value.y;
      }

      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
        var labels = me.getLabels();
        value = valueCategory || value;
        var idx = labels.indexOf(value);
        index = idx !== -1 ? idx : index;
      }

      if (me.isHorizontal()) {
        var valueWidth = me.width / offsetAmt;
        var widthOffset = valueWidth * (index - me.minIndex);

        if (offset) {
          widthOffset += valueWidth / 2;
        }

        return me.left + Math.round(widthOffset);
      }

      var valueHeight = me.height / offsetAmt;
      var heightOffset = valueHeight * (index - me.minIndex);

      if (offset) {
        heightOffset += valueHeight / 2;
      }

      return me.top + Math.round(heightOffset);
    },
    getPixelForTick: function (index) {
      return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
    },
    getValueForPixel: function (pixel) {
      var me = this;
      var offset = me.options.offset;
      var value;
      var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
      var horz = me.isHorizontal();
      var valueDimension = (horz ? me.width : me.height) / offsetAmt;
      pixel -= horz ? me.left : me.top;

      if (offset) {
        pixel -= valueDimension / 2;
      }

      if (pixel <= 0) {
        value = 0;
      } else {
        value = Math.round(pixel / valueDimension);
      }

      return value + me.minIndex;
    },
    getBasePixel: function () {
      return this.bottom;
    }
  });
  scaleService.registerScaleType('category', DatasetScale, defaultConfig);
};

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

var scaleService = __webpack_require__(34);

var Ticks = __webpack_require__(57);

module.exports = function (Chart) {
  var defaultConfig = {
    position: 'left',
    ticks: {
      callback: Ticks.formatters.linear
    }
  };
  var LinearScale = Chart.LinearScaleBase.extend({
    determineDataLimits: function () {
      var me = this;
      var opts = me.options;
      var chart = me.chart;
      var data = chart.data;
      var datasets = data.datasets;
      var isHorizontal = me.isHorizontal();
      var DEFAULT_MIN = 0;
      var DEFAULT_MAX = 1;

      function IDMatches(meta) {
        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
      } // First Calculate the range


      me.min = null;
      me.max = null;
      var hasStacks = opts.stacked;

      if (hasStacks === undefined) {
        helpers.each(datasets, function (dataset, datasetIndex) {
          if (hasStacks) {
            return;
          }

          var meta = chart.getDatasetMeta(datasetIndex);

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
            hasStacks = true;
          }
        });
      }

      if (opts.stacked || hasStacks) {
        var valuesPerStack = {};
        helpers.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

          if (valuesPerStack[key] === undefined) {
            valuesPerStack[key] = {
              positiveValues: [],
              negativeValues: []
            };
          } // Store these per type


          var positiveValues = valuesPerStack[key].positiveValues;
          var negativeValues = valuesPerStack[key].negativeValues;

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            helpers.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              positiveValues[index] = positiveValues[index] || 0;
              negativeValues[index] = negativeValues[index] || 0;

              if (opts.relativePoints) {
                positiveValues[index] = 100;
              } else if (value < 0) {
                negativeValues[index] += value;
              } else {
                positiveValues[index] += value;
              }
            });
          }
        });
        helpers.each(valuesPerStack, function (valuesForType) {
          var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
          var minVal = helpers.min(values);
          var maxVal = helpers.max(values);
          me.min = me.min === null ? minVal : Math.min(me.min, minVal);
          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
        });
      } else {
        helpers.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            helpers.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              if (me.min === null) {
                me.min = value;
              } else if (value < me.min) {
                me.min = value;
              }

              if (me.max === null) {
                me.max = value;
              } else if (value > me.max) {
                me.max = value;
              }
            });
          }
        });
      }

      me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
      me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

      this.handleTickRangeOptions();
    },
    getTickLimit: function () {
      var maxTicks;
      var me = this;
      var tickOpts = me.options.ticks;

      if (me.isHorizontal()) {
        maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
      } else {
        // The factor of 2 used to scale the font size has been experimentally determined.
        var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
        maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
      }

      return maxTicks;
    },
    // Called after the ticks are built. We need
    handleDirectionalChanges: function () {
      if (!this.isHorizontal()) {
        // We are in a vertical orientation. The top value is the highest. So reverse the array
        this.ticks.reverse();
      }
    },
    getLabelForIndex: function (index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    // Utils
    getPixelForValue: function (value) {
      // This must be called after fit has been run so that
      // this.left, this.top, this.right, and this.bottom have been defined
      var me = this;
      var start = me.start;
      var rightValue = +me.getRightValue(value);
      var pixel;
      var range = me.end - start;

      if (me.isHorizontal()) {
        pixel = me.left + me.width / range * (rightValue - start);
      } else {
        pixel = me.bottom - me.height / range * (rightValue - start);
      }

      return pixel;
    },
    getValueForPixel: function (pixel) {
      var me = this;
      var isHorizontal = me.isHorizontal();
      var innerDimension = isHorizontal ? me.width : me.height;
      var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
      return me.start + (me.end - me.start) * offset;
    },
    getPixelForTick: function (index) {
      return this.getPixelForValue(this.ticksAsNumbers[index]);
    }
  });
  scaleService.registerScaleType('linear', LinearScale, defaultConfig);
};

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(2);

var Scale = __webpack_require__(56);

var scaleService = __webpack_require__(34);

var Ticks = __webpack_require__(57);
/**
 * Generate a set of logarithmic ticks
 * @param generationOptions the options used to generate the ticks
 * @param dataRange the range of the data
 * @returns {Array<Number>} array of tick values
 */


function generateTicks(generationOptions, dataRange) {
  var ticks = [];
  var valueOrDefault = helpers.valueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of
  // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
  // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
  // the graph

  var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
  var endExp = Math.floor(helpers.log10(dataRange.max));
  var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  var exp, significand;

  if (tickVal === 0) {
    exp = Math.floor(helpers.log10(dataRange.minNotZero));
    significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
    ticks.push(tickVal);
    tickVal = significand * Math.pow(10, exp);
  } else {
    exp = Math.floor(helpers.log10(tickVal));
    significand = Math.floor(tickVal / Math.pow(10, exp));
  }

  var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

  do {
    ticks.push(tickVal);
    ++significand;

    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }

    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);

  var lastTick = valueOrDefault(generationOptions.max, tickVal);
  ticks.push(lastTick);
  return ticks;
}

module.exports = function (Chart) {
  var defaultConfig = {
    position: 'left',
    // label settings
    ticks: {
      callback: Ticks.formatters.logarithmic
    }
  };
  var LogarithmicScale = Scale.extend({
    determineDataLimits: function () {
      var me = this;
      var opts = me.options;
      var chart = me.chart;
      var data = chart.data;
      var datasets = data.datasets;
      var isHorizontal = me.isHorizontal();

      function IDMatches(meta) {
        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
      } // Calculate Range


      me.min = null;
      me.max = null;
      me.minNotZero = null;
      var hasStacks = opts.stacked;

      if (hasStacks === undefined) {
        helpers.each(datasets, function (dataset, datasetIndex) {
          if (hasStacks) {
            return;
          }

          var meta = chart.getDatasetMeta(datasetIndex);

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
            hasStacks = true;
          }
        });
      }

      if (opts.stacked || hasStacks) {
        var valuesPerStack = {};
        helpers.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = [];
            }

            helpers.each(dataset.data, function (rawValue, index) {
              var values = valuesPerStack[key];
              var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

              if (isNaN(value) || meta.data[index].hidden || value < 0) {
                return;
              }

              values[index] = values[index] || 0;
              values[index] += value;
            });
          }
        });
        helpers.each(valuesPerStack, function (valuesForType) {
          if (valuesForType.length > 0) {
            var minVal = helpers.min(valuesForType);
            var maxVal = helpers.max(valuesForType);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          }
        });
      } else {
        helpers.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            helpers.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

              if (isNaN(value) || meta.data[index].hidden || value < 0) {
                return;
              }

              if (me.min === null) {
                me.min = value;
              } else if (value < me.min) {
                me.min = value;
              }

              if (me.max === null) {
                me.max = value;
              } else if (value > me.max) {
                me.max = value;
              }

              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                me.minNotZero = value;
              }
            });
          }
        });
      } // Common base implementation to handle ticks.min, ticks.max


      this.handleTickRangeOptions();
    },
    handleTickRangeOptions: function () {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks;
      var valueOrDefault = helpers.valueOrDefault;
      var DEFAULT_MIN = 1;
      var DEFAULT_MAX = 10;
      me.min = valueOrDefault(tickOpts.min, me.min);
      me.max = valueOrDefault(tickOpts.max, me.max);

      if (me.min === me.max) {
        if (me.min !== 0 && me.min !== null) {
          me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
          me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
        } else {
          me.min = DEFAULT_MIN;
          me.max = DEFAULT_MAX;
        }
      }

      if (me.min === null) {
        me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
      }

      if (me.max === null) {
        me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1) : DEFAULT_MAX;
      }

      if (me.minNotZero === null) {
        if (me.min > 0) {
          me.minNotZero = me.min;
        } else if (me.max < 1) {
          me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
        } else {
          me.minNotZero = DEFAULT_MIN;
        }
      }
    },
    buildTicks: function () {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks;
      var reverse = !me.isHorizontal();
      var generationOptions = {
        min: tickOpts.min,
        max: tickOpts.max
      };
      var ticks = me.ticks = generateTicks(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
      // range of the scale

      me.max = helpers.max(ticks);
      me.min = helpers.min(ticks);

      if (tickOpts.reverse) {
        reverse = !reverse;
        me.start = me.max;
        me.end = me.min;
      } else {
        me.start = me.min;
        me.end = me.max;
      }

      if (reverse) {
        ticks.reverse();
      }
    },
    convertTicksToLabels: function () {
      this.tickValues = this.ticks.slice();
      Scale.prototype.convertTicksToLabels.call(this);
    },
    // Get the correct tooltip label
    getLabelForIndex: function (index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    getPixelForTick: function (index) {
      return this.getPixelForValue(this.tickValues[index]);
    },

    /**
     * Returns the value of the first tick.
     * @param {Number} value - The minimum not zero value.
     * @return {Number} The first tick value.
     * @private
     */
    _getFirstTickValue: function (value) {
      var exp = Math.floor(helpers.log10(value));
      var significand = Math.floor(value / Math.pow(10, exp));
      return significand * Math.pow(10, exp);
    },
    getPixelForValue: function (value) {
      var me = this;
      var reverse = me.options.ticks.reverse;
      var log10 = helpers.log10;

      var firstTickValue = me._getFirstTickValue(me.minNotZero);

      var offset = 0;
      var innerDimension, pixel, start, end, sign;
      value = +me.getRightValue(value);

      if (reverse) {
        start = me.end;
        end = me.start;
        sign = -1;
      } else {
        start = me.start;
        end = me.end;
        sign = 1;
      }

      if (me.isHorizontal()) {
        innerDimension = me.width;
        pixel = reverse ? me.right : me.left;
      } else {
        innerDimension = me.height;
        sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

        pixel = reverse ? me.top : me.bottom;
      }

      if (value !== start) {
        if (start === 0) {
          // include zero tick
          offset = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
          innerDimension -= offset;
          start = firstTickValue;
        }

        if (value !== 0) {
          offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
        }

        pixel += sign * offset;
      }

      return pixel;
    },
    getValueForPixel: function (pixel) {
      var me = this;
      var reverse = me.options.ticks.reverse;
      var log10 = helpers.log10;

      var firstTickValue = me._getFirstTickValue(me.minNotZero);

      var innerDimension, start, end, value;

      if (reverse) {
        start = me.end;
        end = me.start;
      } else {
        start = me.start;
        end = me.end;
      }

      if (me.isHorizontal()) {
        innerDimension = me.width;
        value = reverse ? me.right - pixel : pixel - me.left;
      } else {
        innerDimension = me.height;
        value = reverse ? pixel - me.top : me.bottom - pixel;
      }

      if (value !== start) {
        if (start === 0) {
          // include zero tick
          var offset = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
          value -= offset;
          innerDimension -= offset;
          start = firstTickValue;
        }

        value *= log10(end) - log10(start);
        value /= innerDimension;
        value = Math.pow(10, log10(start) + value);
      }

      return value;
    }
  });
  scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
};

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

var scaleService = __webpack_require__(34);

var Ticks = __webpack_require__(57);

module.exports = function (Chart) {
  var globalDefaults = defaults.global;
  var defaultConfig = {
    display: true,
    // Boolean - Whether to animate scaling the chart from the centre
    animate: true,
    position: 'chartArea',
    angleLines: {
      display: true,
      color: 'rgba(0, 0, 0, 0.1)',
      lineWidth: 1
    },
    gridLines: {
      circular: false
    },
    // label settings
    ticks: {
      // Boolean - Show a backdrop to the scale label
      showLabelBackdrop: true,
      // String - The colour of the label backdrop
      backdropColor: 'rgba(255,255,255,0.75)',
      // Number - The backdrop padding above & below the label in pixels
      backdropPaddingY: 2,
      // Number - The backdrop padding to the side of the label in pixels
      backdropPaddingX: 2,
      callback: Ticks.formatters.linear
    },
    pointLabels: {
      // Boolean - if true, show point labels
      display: true,
      // Number - Point label font size in pixels
      fontSize: 10,
      // Function - Used to convert point labels
      callback: function (label) {
        return label;
      }
    }
  };

  function getValueCount(scale) {
    var opts = scale.options;
    return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
  }

  function getPointLabelFontOptions(scale) {
    var pointLabelOptions = scale.options.pointLabels;
    var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
    var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
    var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
    var font = helpers.fontString(fontSize, fontStyle, fontFamily);
    return {
      size: fontSize,
      style: fontStyle,
      family: fontFamily,
      font: font
    };
  }

  function measureLabelSize(ctx, fontSize, label) {
    if (helpers.isArray(label)) {
      return {
        w: helpers.longestText(ctx, ctx.font, label),
        h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
      };
    }

    return {
      w: ctx.measureText(label).width,
      h: fontSize
    };
  }

  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size - 5,
        end: pos
      };
    }

    return {
      start: pos,
      end: pos + size + 5
    };
  }
  /**
   * Helper function to fit a radial linear scale with point labels
   */


  function fitWithPointLabels(scale) {
    /*
     * Right, this is really confusing and there is a lot of maths going on here
     * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
     *
     * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
     *
     * Solution:
     *
     * We assume the radius of the polygon is half the size of the canvas at first
     * at each index we check if the text overlaps.
     *
     * Where it does, we store that angle and that index.
     *
     * After finding the largest index and angle we calculate how much we need to remove
     * from the shape radius to move the point inwards by that x.
     *
     * We average the left and right distances to get the maximum shape radius that can fit in the box
     * along with labels.
     *
     * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
     * on each side, removing that from the size, halving it and adding the left x protrusion width.
     *
     * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
     * and position it in the most space efficient manner
     *
     * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
     */
    var plFont = getPointLabelFontOptions(scale); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points

    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
    var furthestLimits = {
      r: scale.width,
      l: 0,
      t: scale.height,
      b: 0
    };
    var furthestAngles = {};
    var i, textSize, pointPosition;
    scale.ctx.font = plFont.font;
    scale._pointLabelSizes = [];
    var valueCount = getValueCount(scale);

    for (i = 0; i < valueCount; i++) {
      pointPosition = scale.getPointPosition(i, largestPossibleRadius);
      textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
      scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

      var angleRadians = scale.getIndexAngle(i);
      var angle = helpers.toDegrees(angleRadians) % 360;
      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

      if (hLimits.start < furthestLimits.l) {
        furthestLimits.l = hLimits.start;
        furthestAngles.l = angleRadians;
      }

      if (hLimits.end > furthestLimits.r) {
        furthestLimits.r = hLimits.end;
        furthestAngles.r = angleRadians;
      }

      if (vLimits.start < furthestLimits.t) {
        furthestLimits.t = vLimits.start;
        furthestAngles.t = angleRadians;
      }

      if (vLimits.end > furthestLimits.b) {
        furthestLimits.b = vLimits.end;
        furthestAngles.b = angleRadians;
      }
    }

    scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
  }
  /**
   * Helper function to fit a radial linear scale with no point labels
   */


  function fit(scale) {
    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
    scale.drawingArea = Math.round(largestPossibleRadius);
    scale.setCenterPoint(0, 0, 0, 0);
  }

  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return 'center';
    } else if (angle < 180) {
      return 'left';
    }

    return 'right';
  }

  function fillText(ctx, text, position, fontSize) {
    if (helpers.isArray(text)) {
      var y = position.y;
      var spacing = 1.5 * fontSize;

      for (var i = 0; i < text.length; ++i) {
        ctx.fillText(text[i], position.x, y);
        y += spacing;
      }
    } else {
      ctx.fillText(text, position.x, position.y);
    }
  }

  function adjustPointPositionForLabelHeight(angle, textSize, position) {
    if (angle === 90 || angle === 270) {
      position.y -= textSize.h / 2;
    } else if (angle > 270 || angle < 90) {
      position.y -= textSize.h;
    }
  }

  function drawPointLabels(scale) {
    var ctx = scale.ctx;
    var opts = scale.options;
    var angleLineOpts = opts.angleLines;
    var pointLabelOpts = opts.pointLabels;
    ctx.lineWidth = angleLineOpts.lineWidth;
    ctx.strokeStyle = angleLineOpts.color;
    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

    var plFont = getPointLabelFontOptions(scale);
    ctx.textBaseline = 'top';

    for (var i = getValueCount(scale) - 1; i >= 0; i--) {
      if (angleLineOpts.display) {
        var outerPosition = scale.getPointPosition(i, outerDistance);
        ctx.beginPath();
        ctx.moveTo(scale.xCenter, scale.yCenter);
        ctx.lineTo(outerPosition.x, outerPosition.y);
        ctx.stroke();
        ctx.closePath();
      }

      if (pointLabelOpts.display) {
        // Extra 3px out for some label spacing
        var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5); // Keep this in loop since we may support array properties here

        var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
        ctx.font = plFont.font;
        ctx.fillStyle = pointLabelFontColor;
        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers.toDegrees(angleRadians);
        ctx.textAlign = getTextAlignForAngle(angle);
        adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
        fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
      }
    }
  }

  function drawRadiusLine(scale, gridLineOpts, radius, index) {
    var ctx = scale.ctx;
    ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
    ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

    if (scale.options.gridLines.circular) {
      // Draw circular arcs between the points
      ctx.beginPath();
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      ctx.closePath();
      ctx.stroke();
    } else {
      // Draw straight lines connecting each index
      var valueCount = getValueCount(scale);

      if (valueCount === 0) {
        return;
      }

      ctx.beginPath();
      var pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);

      for (var i = 1; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }

      ctx.closePath();
      ctx.stroke();
    }
  }

  function numberOrZero(param) {
    return helpers.isNumber(param) ? param : 0;
  }

  var LinearRadialScale = Chart.LinearScaleBase.extend({
    setDimensions: function () {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks; // Set the unconstrained dimension before label rotation

      me.width = me.maxWidth;
      me.height = me.maxHeight;
      me.xCenter = Math.round(me.width / 2);
      me.yCenter = Math.round(me.height / 2);
      var minSize = helpers.min([me.height, me.width]);
      var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
      me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
    },
    determineDataLimits: function () {
      var me = this;
      var chart = me.chart;
      var min = Number.POSITIVE_INFINITY;
      var max = Number.NEGATIVE_INFINITY;
      helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          helpers.each(dataset.data, function (rawValue, index) {
            var value = +me.getRightValue(rawValue);

            if (isNaN(value) || meta.data[index].hidden) {
              return;
            }

            min = Math.min(value, min);
            max = Math.max(value, max);
          });
        }
      });
      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

      me.handleTickRangeOptions();
    },
    getTickLimit: function () {
      var tickOpts = this.options.ticks;
      var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
      return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
    },
    convertTicksToLabels: function () {
      var me = this;
      Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me); // Point labels

      me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
    },
    getLabelForIndex: function (index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    fit: function () {
      if (this.options.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        fit(this);
      }
    },

    /**
     * Set radius reductions and determine new radius and center point
     * @private
     */
    setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
      var me = this;
      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
      var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
      radiusReductionLeft = numberOrZero(radiusReductionLeft);
      radiusReductionRight = numberOrZero(radiusReductionRight);
      radiusReductionTop = numberOrZero(radiusReductionTop);
      radiusReductionBottom = numberOrZero(radiusReductionBottom);
      me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
    },
    setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
      var me = this;
      var maxRight = me.width - rightMovement - me.drawingArea;
      var maxLeft = leftMovement + me.drawingArea;
      var maxTop = topMovement + me.drawingArea;
      var maxBottom = me.height - bottomMovement - me.drawingArea;
      me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
      me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
    },
    getIndexAngle: function (index) {
      var angleMultiplier = Math.PI * 2 / getValueCount(this);
      var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
      var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

      return index * angleMultiplier + startAngleRadians;
    },
    getDistanceFromCenterForValue: function (value) {
      var me = this;

      if (value === null) {
        return 0; // null always in center
      } // Take into account half font size + the yPadding of the top value


      var scalingFactor = me.drawingArea / (me.max - me.min);

      if (me.options.ticks.reverse) {
        return (me.max - value) * scalingFactor;
      }

      return (value - me.min) * scalingFactor;
    },
    getPointPosition: function (index, distanceFromCenter) {
      var me = this;
      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
      return {
        x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
        y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
      };
    },
    getPointPositionForValue: function (index, value) {
      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    },
    getBasePosition: function () {
      var me = this;
      var min = me.min;
      var max = me.max;
      return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
    },
    draw: function () {
      var me = this;
      var opts = me.options;
      var gridLineOpts = opts.gridLines;
      var tickOpts = opts.ticks;
      var valueOrDefault = helpers.valueOrDefault;

      if (opts.display) {
        var ctx = me.ctx;
        var startAngle = this.getIndexAngle(0); // Tick Font

        var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
        var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
        var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
        var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
        helpers.each(me.ticks, function (label, index) {
          // Don't draw a centre value (if it is minimum)
          if (index > 0 || tickOpts.reverse) {
            var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

            if (gridLineOpts.display && index !== 0) {
              drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
            }

            if (tickOpts.display) {
              var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
              ctx.font = tickLabelFont;
              ctx.save();
              ctx.translate(me.xCenter, me.yCenter);
              ctx.rotate(startAngle);

              if (tickOpts.showLabelBackdrop) {
                var labelWidth = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);
              }

              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -yCenterOffset);
              ctx.restore();
            }
          }
        });

        if (opts.angleLines.display || opts.pointLabels.display) {
          drawPointLabels(me);
        }
      }
    }
  });
  scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
};

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */


var moment = __webpack_require__(0);

moment = typeof moment === 'function' ? moment : window.moment;

var defaults = __webpack_require__(7);

var helpers = __webpack_require__(2);

var Scale = __webpack_require__(56);

var scaleService = __webpack_require__(34); // Integer constants are from the ES6 spec.


var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
  },
  second: {
    common: true,
    size: 1000,
    steps: [1, 2, 5, 10, 15, 30]
  },
  minute: {
    common: true,
    size: 60000,
    steps: [1, 2, 5, 10, 15, 30]
  },
  hour: {
    common: true,
    size: 3600000,
    steps: [1, 2, 3, 6, 12]
  },
  day: {
    common: true,
    size: 86400000,
    steps: [1, 2, 5]
  },
  week: {
    common: false,
    size: 604800000,
    steps: [1, 2, 3, 4]
  },
  month: {
    common: true,
    size: 2.628e9,
    steps: [1, 2, 3]
  },
  quarter: {
    common: false,
    size: 7.884e9,
    steps: [1, 2, 3, 4]
  },
  year: {
    common: true,
    size: 3.154e10
  }
};
var UNITS = Object.keys(INTERVALS);

function sorter(a, b) {
  return a - b;
}

function arrayUnique(items) {
  var hash = {};
  var out = [];
  var i, ilen, item;

  for (i = 0, ilen = items.length; i < ilen; ++i) {
    item = items[i];

    if (!hash[item]) {
      hash[item] = true;
      out.push(item);
    }
  }

  return out;
}
/**
 * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
 * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
 * extremity (left + width or top + height). Note that it would be more optimized to directly
 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
 *
 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
 * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
 * If 'series', timestamps will be positioned at the same distance from each other. In this
 * case, only timestamps that break the time linearity are registered, meaning that in the
 * best case, all timestamps are linear, the table contains only min and max.
 */


function buildLookupTable(timestamps, min, max, distribution) {
  if (distribution === 'linear' || !timestamps.length) {
    return [{
      time: min,
      pos: 0
    }, {
      time: max,
      pos: 1
    }];
  }

  var table = [];
  var items = [min];
  var i, ilen, prev, curr, next;

  for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
    curr = timestamps[i];

    if (curr > min && curr < max) {
      items.push(curr);
    }
  }

  items.push(max);

  for (i = 0, ilen = items.length; i < ilen; ++i) {
    next = items[i + 1];
    prev = items[i - 1];
    curr = items[i]; // only add points that breaks the scale linearity

    if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
      table.push({
        time: curr,
        pos: i / (ilen - 1)
      });
    }
  }

  return table;
} // @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


function lookup(table, key, value) {
  var lo = 0;
  var hi = table.length - 1;
  var mid, i0, i1;

  while (lo >= 0 && lo <= hi) {
    mid = lo + hi >> 1;
    i0 = table[mid - 1] || null;
    i1 = table[mid];

    if (!i0) {
      // given value is outside table (before first item)
      return {
        lo: null,
        hi: i1
      };
    } else if (i1[key] < value) {
      lo = mid + 1;
    } else if (i0[key] > value) {
      hi = mid - 1;
    } else {
      return {
        lo: i0,
        hi: i1
      };
    }
  } // given value is outside table (after last item)


  return {
    lo: i1,
    hi: null
  };
}
/**
 * Linearly interpolates the given source `value` using the table items `skey` values and
 * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
 * index [0, 1] or [n - 1, n] are used for the interpolation.
 */


function interpolate(table, skey, sval, tkey) {
  var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

  var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
  var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
  var span = next[skey] - prev[skey];
  var ratio = span ? (sval - prev[skey]) / span : 0;
  var offset = (next[tkey] - prev[tkey]) * ratio;
  return prev[tkey] + offset;
}
/**
 * Convert the given value to a moment object using the given time options.
 * @see http://momentjs.com/docs/#/parsing/
 */


function momentify(value, options) {
  var parser = options.parser;
  var format = options.parser || options.format;

  if (typeof parser === 'function') {
    return parser(value);
  }

  if (typeof value === 'string' && typeof format === 'string') {
    return moment(value, format);
  }

  if (!(value instanceof moment)) {
    value = moment(value);
  }

  if (value.isValid()) {
    return value;
  } // Labels are in an incompatible moment format and no `parser` has been provided.
  // The user might still use the deprecated `format` option to convert his inputs.


  if (typeof format === 'function') {
    return format(value);
  }

  return value;
}

function parse(input, scale) {
  if (helpers.isNullOrUndef(input)) {
    return null;
  }

  var options = scale.options.time;
  var value = momentify(scale.getRightValue(input), options);

  if (!value.isValid()) {
    return null;
  }

  if (options.round) {
    value.startOf(options.round);
  }

  return value.valueOf();
}
/**
 * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
 * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
 */


function determineStepSize(min, max, unit, capacity) {
  var range = max - min;
  var interval = INTERVALS[unit];
  var milliseconds = interval.size;
  var steps = interval.steps;
  var i, ilen, factor;

  if (!steps) {
    return Math.ceil(range / (capacity * milliseconds));
  }

  for (i = 0, ilen = steps.length; i < ilen; ++i) {
    factor = steps[i];

    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
      break;
    }
  }

  return factor;
}
/**
 * Figures out what unit results in an appropriate number of auto-generated ticks
 */


function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  var ilen = UNITS.length;
  var i, interval, factor;

  for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    interval = INTERVALS[UNITS[i]];
    factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }

  return UNITS[ilen - 1];
}
/**
 * Figures out what unit to format a set of ticks with
 */


function determineUnitForFormatting(ticks, minUnit, min, max) {
  var duration = moment.duration(moment(max).diff(moment(min)));
  var ilen = UNITS.length;
  var i, unit;

  for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
    unit = UNITS[i];

    if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
      return unit;
    }
  }

  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}

function determineMajorUnit(unit) {
  for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
/**
 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
 * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
 * Important: this method can return ticks outside the min and max range, it's the
 * responsibility of the calling code to clamp values if needed.
 */


function generate(min, max, capacity, options) {
  var timeOpts = options.time;
  var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
  var major = determineMajorUnit(minor);
  var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
  var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
  var majorTicksEnabled = options.ticks.major.enabled;
  var interval = INTERVALS[minor];
  var first = moment(min);
  var last = moment(max);
  var ticks = [];
  var time;

  if (!stepSize) {
    stepSize = determineStepSize(min, max, minor, capacity);
  } // For 'week' unit, handle the first day of week option


  if (weekday) {
    first = first.isoWeekday(weekday);
    last = last.isoWeekday(weekday);
  } // Align first/last ticks on unit


  first = first.startOf(weekday ? 'day' : minor);
  last = last.startOf(weekday ? 'day' : minor); // Make sure that the last tick include max

  if (last < max) {
    last.add(1, minor);
  }

  time = moment(first);

  if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
    // Align the first tick on the previous `minor` unit aligned on the `major` unit:
    // we first aligned time on the previous `major` unit then add the number of full
    // stepSize there is between first and the previous major time.
    time.startOf(major);
    time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
  }

  for (; time < last; time.add(stepSize, minor)) {
    ticks.push(+time);
  }

  ticks.push(+time);
  return ticks;
}
/**
 * Returns the right and left offsets from edges in the form of {left, right}.
 * Offsets are added when the `offset` option is true.
 */


function computeOffsets(table, ticks, min, max, options) {
  var left = 0;
  var right = 0;
  var upper, lower;

  if (options.offset && ticks.length) {
    if (!options.time.min) {
      upper = ticks.length > 1 ? ticks[1] : max;
      lower = ticks[0];
      left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
    }

    if (!options.time.max) {
      upper = ticks[ticks.length - 1];
      lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
      right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
    }
  }

  return {
    left: left,
    right: right
  };
}

function ticksFromTimestamps(values, majorUnit) {
  var ticks = [];
  var i, ilen, value, major;

  for (i = 0, ilen = values.length; i < ilen; ++i) {
    value = values[i];
    major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;
    ticks.push({
      value: value,
      major: major
    });
  }

  return ticks;
}

function determineLabelFormat(data, timeOpts) {
  var i, momentDate, hasTime;
  var ilen = data.length; // find the label with the most parts (milliseconds, minutes, etc.)
  // format all labels with the same level of detail as the most specific label

  for (i = 0; i < ilen; i++) {
    momentDate = momentify(data[i], timeOpts);

    if (momentDate.millisecond() !== 0) {
      return 'MMM D, YYYY h:mm:ss.SSS a';
    }

    if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
      hasTime = true;
    }
  }

  if (hasTime) {
    return 'MMM D, YYYY h:mm:ss a';
  }

  return 'MMM D, YYYY';
}

module.exports = function () {
  var defaultConfig = {
    position: 'bottom',

    /**
     * Data distribution along the scale:
     * - 'linear': data are spread according to their time (distances can vary),
     * - 'series': data are spread at the same distance from each other.
     * @see https://github.com/chartjs/Chart.js/pull/4507
     * @since 2.7.0
     */
    distribution: 'linear',

    /**
     * Scale boundary strategy (bypassed by min/max time options)
     * - `data`: make sure data are fully visible, ticks outside are removed
     * - `ticks`: make sure ticks are fully visible, data outside are truncated
     * @see https://github.com/chartjs/Chart.js/pull/4556
     * @since 2.7.0
     */
    bounds: 'data',
    time: {
      parser: false,
      // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
      format: false,
      // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
      unit: false,
      // false == automatic or override with week, month, year, etc.
      round: false,
      // none, or override with week, month, year, etc.
      displayFormat: false,
      // DEPRECATED
      isoWeekday: false,
      // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
      minUnit: 'millisecond',
      // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
      displayFormats: {
        millisecond: 'h:mm:ss.SSS a',
        // 11:20:01.123 AM,
        second: 'h:mm:ss a',
        // 11:20:01 AM
        minute: 'h:mm a',
        // 11:20 AM
        hour: 'hA',
        // 5PM
        day: 'MMM D',
        // Sep 4
        week: 'll',
        // Week 46, or maybe "[W]WW - YYYY" ?
        month: 'MMM YYYY',
        // Sept 2015
        quarter: '[Q]Q - YYYY',
        // Q3
        year: 'YYYY' // 2015

      }
    },
    ticks: {
      autoSkip: false,

      /**
       * Ticks generation input values:
       * - 'auto': generates "optimal" ticks based on scale size and time options.
       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
       * - 'labels': generates ticks from user given `data.labels` values ONLY.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      source: 'auto',
      major: {
        enabled: false
      }
    }
  };
  var TimeScale = Scale.extend({
    initialize: function () {
      if (!moment) {
        throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
      }

      this.mergeTicksOptions();
      Scale.prototype.initialize.call(this);
    },
    update: function () {
      var me = this;
      var options = me.options; // DEPRECATIONS: output a message only one time per update

      if (options.time && options.time.format) {
        console.warn('options.time.format is deprecated and replaced by options.time.parser.');
      }

      return Scale.prototype.update.apply(me, arguments);
    },

    /**
     * Allows data to be referenced via 't' attribute
     */
    getRightValue: function (rawValue) {
      if (rawValue && rawValue.t !== undefined) {
        rawValue = rawValue.t;
      }

      return Scale.prototype.getRightValue.call(this, rawValue);
    },
    determineDataLimits: function () {
      var me = this;
      var chart = me.chart;
      var timeOpts = me.options.time;
      var unit = timeOpts.unit || 'day';
      var min = MAX_INTEGER;
      var max = MIN_INTEGER;
      var timestamps = [];
      var datasets = [];
      var labels = [];
      var i, j, ilen, jlen, data, timestamp; // Convert labels to timestamps

      for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
        labels.push(parse(chart.data.labels[i], me));
      } // Convert data to timestamps


      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

          if (helpers.isObject(data[0])) {
            datasets[i] = [];

            for (j = 0, jlen = data.length; j < jlen; ++j) {
              timestamp = parse(data[j], me);
              timestamps.push(timestamp);
              datasets[i][j] = timestamp;
            }
          } else {
            timestamps.push.apply(timestamps, labels);
            datasets[i] = labels.slice(0);
          }
        } else {
          datasets[i] = [];
        }
      }

      if (labels.length) {
        // Sort labels **after** data have been converted
        labels = arrayUnique(labels).sort(sorter);
        min = Math.min(min, labels[0]);
        max = Math.max(max, labels[labels.length - 1]);
      }

      if (timestamps.length) {
        timestamps = arrayUnique(timestamps).sort(sorter);
        min = Math.min(min, timestamps[0]);
        max = Math.max(max, timestamps[timestamps.length - 1]);
      }

      min = parse(timeOpts.min, me) || min;
      max = parse(timeOpts.max, me) || max; // In case there is no valid min/max, set limits based on unit time option

      min = min === MAX_INTEGER ? +moment().startOf(unit) : min;
      max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

      me.min = Math.min(min, max);
      me.max = Math.max(min + 1, max); // PRIVATE

      me._horizontal = me.isHorizontal();
      me._table = [];
      me._timestamps = {
        data: timestamps,
        datasets: datasets,
        labels: labels
      };
    },
    buildTicks: function () {
      var me = this;
      var min = me.min;
      var max = me.max;
      var options = me.options;
      var timeOpts = options.time;
      var timestamps = [];
      var ticks = [];
      var i, ilen, timestamp;

      switch (options.ticks.source) {
        case 'data':
          timestamps = me._timestamps.data;
          break;

        case 'labels':
          timestamps = me._timestamps.labels;
          break;

        case 'auto':
        default:
          timestamps = generate(min, max, me.getLabelCapacity(min), options);
      }

      if (options.bounds === 'ticks' && timestamps.length) {
        min = timestamps[0];
        max = timestamps[timestamps.length - 1];
      } // Enforce limits with user min/max options


      min = parse(timeOpts.min, me) || min;
      max = parse(timeOpts.max, me) || max; // Remove ticks outside the min/max range

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        timestamp = timestamps[i];

        if (timestamp >= min && timestamp <= max) {
          ticks.push(timestamp);
        }
      }

      me.min = min;
      me.max = max; // PRIVATE

      me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
      me._majorUnit = determineMajorUnit(me._unit);
      me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
      me._offsets = computeOffsets(me._table, ticks, min, max, options);
      me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);
      return ticksFromTimestamps(ticks, me._majorUnit);
    },
    getLabelForIndex: function (index, datasetIndex) {
      var me = this;
      var data = me.chart.data;
      var timeOpts = me.options.time;
      var label = data.labels && index < data.labels.length ? data.labels[index] : '';
      var value = data.datasets[datasetIndex].data[index];

      if (helpers.isObject(value)) {
        label = me.getRightValue(value);
      }

      if (timeOpts.tooltipFormat) {
        return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
      }

      if (typeof label === 'string') {
        return label;
      }

      return momentify(label, timeOpts).format(me._labelFormat);
    },

    /**
     * Function to format an individual tick mark
     * @private
     */
    tickFormatFunction: function (tick, index, ticks, formatOverride) {
      var me = this;
      var options = me.options;
      var time = tick.valueOf();
      var formats = options.time.displayFormats;
      var minorFormat = formats[me._unit];
      var majorUnit = me._majorUnit;
      var majorFormat = formats[majorUnit];
      var majorTime = tick.clone().startOf(majorUnit).valueOf();
      var majorTickOpts = options.ticks.major;
      var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
      var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
      var tickOpts = major ? majorTickOpts : options.ticks.minor;
      var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);
      return formatter ? formatter(label, index, ticks) : label;
    },
    convertTicksToLabels: function (ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
      }

      return labels;
    },

    /**
     * @private
     */
    getPixelForOffset: function (time) {
      var me = this;
      var size = me._horizontal ? me.width : me.height;
      var start = me._horizontal ? me.left : me.top;
      var pos = interpolate(me._table, 'time', time, 'pos');
      return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
    },
    getPixelForValue: function (value, index, datasetIndex) {
      var me = this;
      var time = null;

      if (index !== undefined && datasetIndex !== undefined) {
        time = me._timestamps.datasets[datasetIndex][index];
      }

      if (time === null) {
        time = parse(value, me);
      }

      if (time !== null) {
        return me.getPixelForOffset(time);
      }
    },
    getPixelForTick: function (index) {
      var ticks = this.getTicks();
      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
    },
    getValueForPixel: function (pixel) {
      var me = this;
      var size = me._horizontal ? me.width : me.height;
      var start = me._horizontal ? me.left : me.top;
      var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
      var time = interpolate(me._table, 'pos', pos, 'time');
      return moment(time);
    },

    /**
     * Crude approximation of what the label width might be
     * @private
     */
    getLabelWidth: function (label) {
      var me = this;
      var ticksOpts = me.options.ticks;
      var tickLabelWidth = me.ctx.measureText(label).width;
      var angle = helpers.toRadians(ticksOpts.maxRotation);
      var cosRotation = Math.cos(angle);
      var sinRotation = Math.sin(angle);
      var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);
      return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
    },

    /**
     * @private
     */
    getLabelCapacity: function (exampleTime) {
      var me = this;
      var formatOverride = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation

      var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
      var tickLabelWidth = me.getLabelWidth(exampleLabel);
      var innerWidth = me.isHorizontal() ? me.width : me.height;
      var capacity = Math.floor(innerWidth / tickLabelWidth);
      return capacity > 0 ? capacity : 1;
    }
  });
  scaleService.registerScaleType('time', TimeScale, defaultConfig);
};

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 139,
	"./af.js": 139,
	"./ar": 140,
	"./ar-dz": 141,
	"./ar-dz.js": 141,
	"./ar-kw": 142,
	"./ar-kw.js": 142,
	"./ar-ly": 143,
	"./ar-ly.js": 143,
	"./ar-ma": 144,
	"./ar-ma.js": 144,
	"./ar-sa": 145,
	"./ar-sa.js": 145,
	"./ar-tn": 146,
	"./ar-tn.js": 146,
	"./ar.js": 140,
	"./az": 147,
	"./az.js": 147,
	"./be": 148,
	"./be.js": 148,
	"./bg": 149,
	"./bg.js": 149,
	"./bm": 150,
	"./bm.js": 150,
	"./bn": 151,
	"./bn.js": 151,
	"./bo": 152,
	"./bo.js": 152,
	"./br": 153,
	"./br.js": 153,
	"./bs": 154,
	"./bs.js": 154,
	"./ca": 155,
	"./ca.js": 155,
	"./cs": 156,
	"./cs.js": 156,
	"./cv": 157,
	"./cv.js": 157,
	"./cy": 158,
	"./cy.js": 158,
	"./da": 159,
	"./da.js": 159,
	"./de": 160,
	"./de-at": 161,
	"./de-at.js": 161,
	"./de-ch": 162,
	"./de-ch.js": 162,
	"./de.js": 160,
	"./dv": 163,
	"./dv.js": 163,
	"./el": 164,
	"./el.js": 164,
	"./en-au": 165,
	"./en-au.js": 165,
	"./en-ca": 166,
	"./en-ca.js": 166,
	"./en-gb": 167,
	"./en-gb.js": 167,
	"./en-ie": 168,
	"./en-ie.js": 168,
	"./en-il": 169,
	"./en-il.js": 169,
	"./en-nz": 170,
	"./en-nz.js": 170,
	"./eo": 171,
	"./eo.js": 171,
	"./es": 172,
	"./es-do": 173,
	"./es-do.js": 173,
	"./es-us": 174,
	"./es-us.js": 174,
	"./es.js": 172,
	"./et": 175,
	"./et.js": 175,
	"./eu": 176,
	"./eu.js": 176,
	"./fa": 177,
	"./fa.js": 177,
	"./fi": 178,
	"./fi.js": 178,
	"./fo": 179,
	"./fo.js": 179,
	"./fr": 180,
	"./fr-ca": 181,
	"./fr-ca.js": 181,
	"./fr-ch": 182,
	"./fr-ch.js": 182,
	"./fr.js": 180,
	"./fy": 183,
	"./fy.js": 183,
	"./gd": 184,
	"./gd.js": 184,
	"./gl": 185,
	"./gl.js": 185,
	"./gom-latn": 186,
	"./gom-latn.js": 186,
	"./gu": 187,
	"./gu.js": 187,
	"./he": 188,
	"./he.js": 188,
	"./hi": 189,
	"./hi.js": 189,
	"./hr": 190,
	"./hr.js": 190,
	"./hu": 191,
	"./hu.js": 191,
	"./hy-am": 192,
	"./hy-am.js": 192,
	"./id": 193,
	"./id.js": 193,
	"./is": 194,
	"./is.js": 194,
	"./it": 195,
	"./it.js": 195,
	"./ja": 196,
	"./ja.js": 196,
	"./jv": 197,
	"./jv.js": 197,
	"./ka": 198,
	"./ka.js": 198,
	"./kk": 199,
	"./kk.js": 199,
	"./km": 200,
	"./km.js": 200,
	"./kn": 201,
	"./kn.js": 201,
	"./ko": 202,
	"./ko.js": 202,
	"./ku": 203,
	"./ku.js": 203,
	"./ky": 204,
	"./ky.js": 204,
	"./lb": 205,
	"./lb.js": 205,
	"./lo": 206,
	"./lo.js": 206,
	"./lt": 207,
	"./lt.js": 207,
	"./lv": 208,
	"./lv.js": 208,
	"./me": 209,
	"./me.js": 209,
	"./mi": 210,
	"./mi.js": 210,
	"./mk": 211,
	"./mk.js": 211,
	"./ml": 212,
	"./ml.js": 212,
	"./mn": 213,
	"./mn.js": 213,
	"./mr": 214,
	"./mr.js": 214,
	"./ms": 215,
	"./ms-my": 216,
	"./ms-my.js": 216,
	"./ms.js": 215,
	"./mt": 217,
	"./mt.js": 217,
	"./my": 218,
	"./my.js": 218,
	"./nb": 219,
	"./nb.js": 219,
	"./ne": 220,
	"./ne.js": 220,
	"./nl": 221,
	"./nl-be": 222,
	"./nl-be.js": 222,
	"./nl.js": 221,
	"./nn": 223,
	"./nn.js": 223,
	"./pa-in": 224,
	"./pa-in.js": 224,
	"./pl": 225,
	"./pl.js": 225,
	"./pt": 226,
	"./pt-br": 227,
	"./pt-br.js": 227,
	"./pt.js": 226,
	"./ro": 228,
	"./ro.js": 228,
	"./ru": 229,
	"./ru.js": 229,
	"./sd": 230,
	"./sd.js": 230,
	"./se": 231,
	"./se.js": 231,
	"./si": 232,
	"./si.js": 232,
	"./sk": 233,
	"./sk.js": 233,
	"./sl": 234,
	"./sl.js": 234,
	"./sq": 235,
	"./sq.js": 235,
	"./sr": 236,
	"./sr-cyrl": 237,
	"./sr-cyrl.js": 237,
	"./sr.js": 236,
	"./ss": 238,
	"./ss.js": 238,
	"./sv": 239,
	"./sv.js": 239,
	"./sw": 240,
	"./sw.js": 240,
	"./ta": 241,
	"./ta.js": 241,
	"./te": 242,
	"./te.js": 242,
	"./tet": 243,
	"./tet.js": 243,
	"./tg": 244,
	"./tg.js": 244,
	"./th": 245,
	"./th.js": 245,
	"./tl-ph": 246,
	"./tl-ph.js": 246,
	"./tlh": 247,
	"./tlh.js": 247,
	"./tr": 248,
	"./tr.js": 248,
	"./tzl": 249,
	"./tzl.js": 249,
	"./tzm": 250,
	"./tzm-latn": 251,
	"./tzm-latn.js": 251,
	"./tzm.js": 250,
	"./ug-cn": 252,
	"./ug-cn.js": 252,
	"./uk": 253,
	"./uk.js": 253,
	"./ur": 254,
	"./ur.js": 254,
	"./uz": 255,
	"./uz-latn": 256,
	"./uz-latn.js": 256,
	"./uz.js": 255,
	"./vi": 257,
	"./vi.js": 257,
	"./x-pseudo": 258,
	"./x-pseudo.js": 258,
	"./yo": 259,
	"./yo.js": 259,
	"./zh-cn": 260,
	"./zh-cn.js": 260,
	"./zh-hk": 261,
	"./zh-hk.js": 261,
	"./zh-tw": 262,
	"./zh-tw.js": 262
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 479;

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('bar', {
  hover: {
    mode: 'label'
  },
  scales: {
    xAxes: [{
      type: 'category',
      // Specific to Bar Controller
      categoryPercentage: 0.8,
      barPercentage: 0.9,
      // offset settings
      offset: true,
      // grid line settings
      gridLines: {
        offsetGridLines: true
      }
    }],
    yAxes: [{
      type: 'linear'
    }]
  }
});

defaults._set('horizontalBar', {
  hover: {
    mode: 'index',
    axis: 'y'
  },
  scales: {
    xAxes: [{
      type: 'linear',
      position: 'bottom'
    }],
    yAxes: [{
      position: 'left',
      type: 'category',
      // Specific to Horizontal Bar Controller
      categoryPercentage: 0.8,
      barPercentage: 0.9,
      // offset settings
      offset: true,
      // grid line settings
      gridLines: {
        offsetGridLines: true
      }
    }]
  },
  elements: {
    rectangle: {
      borderSkipped: 'left'
    }
  },
  tooltips: {
    callbacks: {
      title: function (item, data) {
        // Pick first xLabel for now
        var title = '';

        if (item.length > 0) {
          if (item[0].yLabel) {
            title = item[0].yLabel;
          } else if (data.labels.length > 0 && item[0].index < data.labels.length) {
            title = data.labels[item[0].index];
          }
        }

        return title;
      },
      label: function (item, data) {
        var datasetLabel = data.datasets[item.datasetIndex].label || '';
        return datasetLabel + ': ' + item.xLabel;
      }
    },
    mode: 'index',
    axis: 'y'
  }
});
/**
 * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
 * @private
 */


function computeMinSampleSize(scale, pixels) {
  var min = scale.isHorizontal() ? scale.width : scale.height;
  var ticks = scale.getTicks();
  var prev, curr, i, ilen;

  for (i = 1, ilen = pixels.length; i < ilen; ++i) {
    min = Math.min(min, pixels[i] - pixels[i - 1]);
  }

  for (i = 0, ilen = ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    min = i > 0 ? Math.min(min, curr - prev) : min;
    prev = curr;
  }

  return min;
}
/**
 * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
 * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
 * mode currently always generates bars equally sized (until we introduce scriptable options?).
 * @private
 */


function computeFitCategoryTraits(index, ruler, options) {
  var thickness = options.barThickness;
  var count = ruler.stackCount;
  var curr = ruler.pixels[index];
  var size, ratio;

  if (helpers.isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    // When bar thickness is enforced, category and bar percentages are ignored.
    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
    // and deprecate barPercentage since this value is ignored when thickness is absolute.
    size = thickness * count;
    ratio = 1;
  }

  return {
    chunk: size / count,
    ratio: ratio,
    start: curr - size / 2
  };
}
/**
 * Computes an "optimal" category that globally arranges bars side by side (no gap when
 * percentage options are 1), based on the previous and following categories. This mode
 * generates bars with different widths when data are not evenly spaced.
 * @private
 */


function computeFlexCategoryTraits(index, ruler, options) {
  var pixels = ruler.pixels;
  var curr = pixels[index];
  var prev = index > 0 ? pixels[index - 1] : null;
  var next = index < pixels.length - 1 ? pixels[index + 1] : null;
  var percent = options.categoryPercentage;
  var start, size;

  if (prev === null) {
    // first data: its size is double based on the next point or,
    // if it's also the last data, we use the scale end extremity.
    prev = curr - (next === null ? ruler.end - curr : next - curr);
  }

  if (next === null) {
    // last data: its size is also double based on the previous point.
    next = curr + curr - prev;
  }

  start = curr - (curr - prev) / 2 * percent;
  size = (next - prev) / 2 * percent;
  return {
    chunk: size / ruler.stackCount,
    ratio: options.barPercentage,
    start: start
  };
}

module.exports = function (Chart) {
  Chart.controllers.bar = Chart.DatasetController.extend({
    dataElementType: elements.Rectangle,
    initialize: function () {
      var me = this;
      var meta;
      Chart.DatasetController.prototype.initialize.apply(me, arguments);
      meta = me.getMeta();
      meta.stack = me.getDataset().stack;
      meta.bar = true;
    },
    update: function (reset) {
      var me = this;
      var rects = me.getMeta().data;
      var i, ilen;
      me._ruler = me.getRuler();

      for (i = 0, ilen = rects.length; i < ilen; ++i) {
        me.updateElement(rects[i], i, reset);
      }
    },
    updateElement: function (rectangle, index, reset) {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var dataset = me.getDataset();
      var custom = rectangle.custom || {};
      var rectangleOptions = chart.options.elements.rectangle;
      rectangle._xScale = me.getScaleForId(meta.xAxisID);
      rectangle._yScale = me.getScaleForId(meta.yAxisID);
      rectangle._datasetIndex = me.index;
      rectangle._index = index;
      rectangle._model = {
        datasetLabel: dataset.label,
        label: chart.data.labels[index],
        borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
        borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
      };
      me.updateElementGeometry(rectangle, index, reset);
      rectangle.pivot();
    },

    /**
     * @private
     */
    updateElementGeometry: function (rectangle, index, reset) {
      var me = this;
      var model = rectangle._model;
      var vscale = me.getValueScale();
      var base = vscale.getBasePixel();
      var horizontal = vscale.isHorizontal();
      var ruler = me._ruler || me.getRuler();
      var vpixels = me.calculateBarValuePixels(me.index, index);
      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
      model.horizontal = horizontal;
      model.base = reset ? base : vpixels.base;
      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
      model.height = horizontal ? ipixels.size : undefined;
      model.width = horizontal ? undefined : ipixels.size;
    },

    /**
     * @private
     */
    getValueScaleId: function () {
      return this.getMeta().yAxisID;
    },

    /**
     * @private
     */
    getIndexScaleId: function () {
      return this.getMeta().xAxisID;
    },

    /**
     * @private
     */
    getValueScale: function () {
      return this.getScaleForId(this.getValueScaleId());
    },

    /**
     * @private
     */
    getIndexScale: function () {
      return this.getScaleForId(this.getIndexScaleId());
    },

    /**
     * Returns the stacks based on groups and bar visibility.
     * @param {Number} [last] - The dataset index
     * @returns {Array} The stack list
     * @private
     */
    _getStacks: function (last) {
      var me = this;
      var chart = me.chart;
      var scale = me.getIndexScale();
      var stacked = scale.options.stacked;
      var ilen = last === undefined ? chart.data.datasets.length : last + 1;
      var stacks = [];
      var i, meta;

      for (i = 0; i < ilen; ++i) {
        meta = chart.getDatasetMeta(i);

        if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
          stacks.push(meta.stack);
        }
      }

      return stacks;
    },

    /**
     * Returns the effective number of stacks based on groups and bar visibility.
     * @private
     */
    getStackCount: function () {
      return this._getStacks().length;
    },

    /**
     * Returns the stack index for the given dataset based on groups and bar visibility.
     * @param {Number} [datasetIndex] - The dataset index
     * @param {String} [name] - The stack name to find
     * @returns {Number} The stack index
     * @private
     */
    getStackIndex: function (datasetIndex, name) {
      var stacks = this._getStacks(datasetIndex);

      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

      return index === -1 ? stacks.length - 1 : index;
    },

    /**
     * @private
     */
    getRuler: function () {
      var me = this;
      var scale = me.getIndexScale();
      var stackCount = me.getStackCount();
      var datasetIndex = me.index;
      var isHorizontal = scale.isHorizontal();
      var start = isHorizontal ? scale.left : scale.top;
      var end = start + (isHorizontal ? scale.width : scale.height);
      var pixels = [];
      var i, ilen, min;

      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
        pixels.push(scale.getPixelForValue(null, i, datasetIndex));
      }

      min = helpers.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
      return {
        min: min,
        pixels: pixels,
        start: start,
        end: end,
        stackCount: stackCount,
        scale: scale
      };
    },

    /**
     * Note: pixel values are not clamped to the scale area.
     * @private
     */
    calculateBarValuePixels: function (datasetIndex, index) {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var scale = me.getValueScale();
      var datasets = chart.data.datasets;
      var value = scale.getRightValue(datasets[datasetIndex].data[index]);
      var stacked = scale.options.stacked;
      var stack = meta.stack;
      var start = 0;
      var i, imeta, ivalue, base, head, size;

      if (stacked || stacked === undefined && stack !== undefined) {
        for (i = 0; i < datasetIndex; ++i) {
          imeta = chart.getDatasetMeta(i);

          if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
            ivalue = scale.getRightValue(datasets[i].data[index]);

            if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
              start += ivalue;
            }
          }
        }
      }

      base = scale.getPixelForValue(start);
      head = scale.getPixelForValue(start + value);
      size = (head - base) / 2;
      return {
        size: size,
        base: base,
        head: head,
        center: head + size / 2
      };
    },

    /**
     * @private
     */
    calculateBarIndexPixels: function (datasetIndex, index, ruler) {
      var me = this;
      var options = ruler.scale.options;
      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
      var center = range.start + range.chunk * stackIndex + range.chunk / 2;
      var size = Math.min(helpers.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
      return {
        base: center - size / 2,
        head: center + size / 2,
        center: center,
        size: size
      };
    },
    draw: function () {
      var me = this;
      var chart = me.chart;
      var scale = me.getValueScale();
      var rects = me.getMeta().data;
      var dataset = me.getDataset();
      var ilen = rects.length;
      var i = 0;
      helpers.canvas.clipArea(chart.ctx, chart.chartArea);

      for (; i < ilen; ++i) {
        if (!isNaN(scale.getRightValue(dataset.data[i]))) {
          rects[i].draw();
        }
      }

      helpers.canvas.unclipArea(chart.ctx);
    }
  });
  Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
    /**
     * @private
     */
    getValueScaleId: function () {
      return this.getMeta().xAxisID;
    },

    /**
     * @private
     */
    getIndexScaleId: function () {
      return this.getMeta().yAxisID;
    }
  });
};

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('bubble', {
  hover: {
    mode: 'single'
  },
  scales: {
    xAxes: [{
      type: 'linear',
      // bubble should probably use a linear scale by default
      position: 'bottom',
      id: 'x-axis-0' // need an ID so datasets can reference the scale

    }],
    yAxes: [{
      type: 'linear',
      position: 'left',
      id: 'y-axis-0'
    }]
  },
  tooltips: {
    callbacks: {
      title: function () {
        // Title doesn't make sense for scatter since we format the data as a point
        return '';
      },
      label: function (item, data) {
        var datasetLabel = data.datasets[item.datasetIndex].label || '';
        var dataPoint = data.datasets[item.datasetIndex].data[item.index];
        return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
      }
    }
  }
});

module.exports = function (Chart) {
  Chart.controllers.bubble = Chart.DatasetController.extend({
    /**
     * @protected
     */
    dataElementType: elements.Point,

    /**
     * @protected
     */
    update: function (reset) {
      var me = this;
      var meta = me.getMeta();
      var points = meta.data; // Update Points

      helpers.each(points, function (point, index) {
        me.updateElement(point, index, reset);
      });
    },

    /**
     * @protected
     */
    updateElement: function (point, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var custom = point.custom || {};
      var xScale = me.getScaleForId(meta.xAxisID);
      var yScale = me.getScaleForId(meta.yAxisID);

      var options = me._resolveElementOptions(point, index);

      var data = me.getDataset().data[index];
      var dsIndex = me.index;
      var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
      var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
      point._xScale = xScale;
      point._yScale = yScale;
      point._options = options;
      point._datasetIndex = dsIndex;
      point._index = index;
      point._model = {
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        hitRadius: options.hitRadius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        radius: reset ? 0 : options.radius,
        skip: custom.skip || isNaN(x) || isNaN(y),
        x: x,
        y: y
      };
      point.pivot();
    },

    /**
     * @protected
     */
    setHoverStyle: function (point) {
      var model = point._model;
      var options = point._options;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
      model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
      model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      model.radius = options.radius + options.hoverRadius;
    },

    /**
     * @private
     */
    _resolveElementOptions: function (point, index) {
      var me = this;
      var chart = me.chart;
      var datasets = chart.data.datasets;
      var dataset = datasets[me.index];
      var custom = point.custom || {};
      var options = chart.options.elements.point;
      var resolve = helpers.options.resolve;
      var data = dataset.data[index];
      var values = {};
      var i, ilen, key; // Scriptable options

      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve([custom[key], dataset[key], options[key]], context, index);
      } // Custom radius resolution


      values.radius = resolve([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
      return values;
    }
  });
};

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('doughnut', {
  animation: {
    // Boolean - Whether we animate the rotation of the Doughnut
    animateRotate: true,
    // Boolean - Whether we animate scaling the Doughnut from the centre
    animateScale: false
  },
  hover: {
    mode: 'single'
  },
  legendCallback: function (chart) {
    var text = [];
    text.push('<ul class="' + chart.id + '-legend">');
    var data = chart.data;
    var datasets = data.datasets;
    var labels = data.labels;

    if (datasets.length) {
      for (var i = 0; i < datasets[0].data.length; ++i) {
        text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

        if (labels[i]) {
          text.push(labels[i]);
        }

        text.push('</li>');
      }
    }

    text.push('</ul>');
    return text.join('');
  },
  legend: {
    labels: {
      generateLabels: function (chart) {
        var data = chart.data;

        if (data.labels.length && data.datasets.length) {
          return data.labels.map(function (label, i) {
            var meta = chart.getDatasetMeta(0);
            var ds = data.datasets[0];
            var arc = meta.data[i];
            var custom = arc && arc.custom || {};
            var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
            var arcOpts = chart.options.elements.arc;
            var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
            var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
            var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
            return {
              text: label,
              fillStyle: fill,
              strokeStyle: stroke,
              lineWidth: bw,
              hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
              // Extra data used for toggling the correct item
              index: i
            };
          });
        }

        return [];
      }
    },
    onClick: function (e, legendItem) {
      var index = legendItem.index;
      var chart = this.chart;
      var i, ilen, meta;

      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
        meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

        if (meta.data[index]) {
          meta.data[index].hidden = !meta.data[index].hidden;
        }
      }

      chart.update();
    }
  },
  // The percentage of the chart that we cut out of the middle.
  cutoutPercentage: 50,
  // The rotation of the chart, where the first data arc begins.
  rotation: Math.PI * -0.5,
  // The total circumference of the chart.
  circumference: Math.PI * 2.0,
  // Need to override these to give a nice default
  tooltips: {
    callbacks: {
      title: function () {
        return '';
      },
      label: function (tooltipItem, data) {
        var dataLabel = data.labels[tooltipItem.index];
        var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

        if (helpers.isArray(dataLabel)) {
          // show value on first line of multiline label
          // need to clone because we are changing the value
          dataLabel = dataLabel.slice();
          dataLabel[0] += value;
        } else {
          dataLabel += value;
        }

        return dataLabel;
      }
    }
  }
});

defaults._set('pie', helpers.clone(defaults.doughnut));

defaults._set('pie', {
  cutoutPercentage: 0
});

module.exports = function (Chart) {
  Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
    dataElementType: elements.Arc,
    linkScales: helpers.noop,
    // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
    getRingIndex: function (datasetIndex) {
      var ringIndex = 0;

      for (var j = 0; j < datasetIndex; ++j) {
        if (this.chart.isDatasetVisible(j)) {
          ++ringIndex;
        }
      }

      return ringIndex;
    },
    update: function (reset) {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var arcOpts = opts.elements.arc;
      var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
      var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
      var minSize = Math.min(availableWidth, availableHeight);
      var offset = {
        x: 0,
        y: 0
      };
      var meta = me.getMeta();
      var cutoutPercentage = opts.cutoutPercentage;
      var circumference = opts.circumference; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

      if (circumference < Math.PI * 2.0) {
        var startAngle = opts.rotation % (Math.PI * 2.0);
        startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
        var endAngle = startAngle + circumference;
        var start = {
          x: Math.cos(startAngle),
          y: Math.sin(startAngle)
        };
        var end = {
          x: Math.cos(endAngle),
          y: Math.sin(endAngle)
        };
        var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
        var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
        var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
        var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
        var cutout = cutoutPercentage / 100.0;
        var min = {
          x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
          y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
        };
        var max = {
          x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
          y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
        };
        var size = {
          width: (max.x - min.x) * 0.5,
          height: (max.y - min.y) * 0.5
        };
        minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
        offset = {
          x: (max.x + min.x) * -0.5,
          y: (max.y + min.y) * -0.5
        };
      }

      chart.borderWidth = me.getMaxBorderWidth(meta.data);
      chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
      chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
      chart.offsetX = offset.x * chart.outerRadius;
      chart.offsetY = offset.y * chart.outerRadius;
      meta.total = me.calculateTotal();
      me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
      me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
      helpers.each(meta.data, function (arc, index) {
        me.updateElement(arc, index, reset);
      });
    },
    updateElement: function (arc, index, reset) {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var animationOpts = opts.animation;
      var centerX = (chartArea.left + chartArea.right) / 2;
      var centerY = (chartArea.top + chartArea.bottom) / 2;
      var startAngle = opts.rotation; // non reset case handled later

      var endAngle = opts.rotation; // non reset case handled later

      var dataset = me.getDataset();
      var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
      var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
      var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
      var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
      helpers.extend(arc, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        // Desired view properties
        _model: {
          x: centerX + chart.offsetX,
          y: centerY + chart.offsetY,
          startAngle: startAngle,
          endAngle: endAngle,
          circumference: circumference,
          outerRadius: outerRadius,
          innerRadius: innerRadius,
          label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
        }
      });
      var model = arc._model; // Resets the visual styles

      var custom = arc.custom || {};
      var valueOrDefault = helpers.valueAtIndexOrDefault;
      var elementOpts = this.chart.options.elements.arc;
      model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
      model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
      model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth); // Set correct angles if not resetting

      if (!reset || !animationOpts.animateRotate) {
        if (index === 0) {
          model.startAngle = opts.rotation;
        } else {
          model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
        }

        model.endAngle = model.startAngle + model.circumference;
      }

      arc.pivot();
    },
    calculateTotal: function () {
      var dataset = this.getDataset();
      var meta = this.getMeta();
      var total = 0;
      var value;
      helpers.each(meta.data, function (element, index) {
        value = dataset.data[index];

        if (!isNaN(value) && !element.hidden) {
          total += Math.abs(value);
        }
      });
      /* if (total === 0) {
      	total = NaN;
      }*/

      return total;
    },
    calculateCircumference: function (value) {
      var total = this.getMeta().total;

      if (total > 0 && !isNaN(value)) {
        return Math.PI * 2.0 * (Math.abs(value) / total);
      }

      return 0;
    },
    // gets the max border or hover width to properly scale pie charts
    getMaxBorderWidth: function (arcs) {
      var max = 0;
      var index = this.index;
      var length = arcs.length;
      var borderWidth;
      var hoverWidth;

      for (var i = 0; i < length; i++) {
        borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
        hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
        max = borderWidth > max ? borderWidth : max;
        max = hoverWidth > max ? hoverWidth : max;
      }

      return max;
    }
  });
};

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('line', {
  showLines: true,
  spanGaps: false,
  hover: {
    mode: 'label'
  },
  scales: {
    xAxes: [{
      type: 'category',
      id: 'x-axis-0'
    }],
    yAxes: [{
      type: 'linear',
      id: 'y-axis-0'
    }]
  }
});

module.exports = function (Chart) {
  function lineEnabled(dataset, options) {
    return helpers.valueOrDefault(dataset.showLine, options.showLines);
  }

  Chart.controllers.line = Chart.DatasetController.extend({
    datasetElementType: elements.Line,
    dataElementType: elements.Point,
    update: function (reset) {
      var me = this;
      var meta = me.getMeta();
      var line = meta.dataset;
      var points = meta.data || [];
      var options = me.chart.options;
      var lineElementOptions = options.elements.line;
      var scale = me.getScaleForId(meta.yAxisID);
      var i, ilen, custom;
      var dataset = me.getDataset();
      var showLine = lineEnabled(dataset, options); // Update Line

      if (showLine) {
        custom = line.custom || {}; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points; // Model

        line._model = {
          // Appearance
          // The default behavior of lines is to break at null values, according
          // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
          // This option gives lines the ability to span gaps
          spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
          tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
          backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
          borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
          borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
          borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
          borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
          borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
          borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
          fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
          steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
          cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
        };
        line.pivot();
      } // Update Points


      for (i = 0, ilen = points.length; i < ilen; ++i) {
        me.updateElement(points[i], i, reset);
      }

      if (showLine && line._model.tension !== 0) {
        me.updateBezierControlPoints();
      } // Now pivot the point for animation


      for (i = 0, ilen = points.length; i < ilen; ++i) {
        points[i].pivot();
      }
    },
    getPointBackgroundColor: function (point, index) {
      var backgroundColor = this.chart.options.elements.point.backgroundColor;
      var dataset = this.getDataset();
      var custom = point.custom || {};

      if (custom.backgroundColor) {
        backgroundColor = custom.backgroundColor;
      } else if (dataset.pointBackgroundColor) {
        backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
      } else if (dataset.backgroundColor) {
        backgroundColor = dataset.backgroundColor;
      }

      return backgroundColor;
    },
    getPointBorderColor: function (point, index) {
      var borderColor = this.chart.options.elements.point.borderColor;
      var dataset = this.getDataset();
      var custom = point.custom || {};

      if (custom.borderColor) {
        borderColor = custom.borderColor;
      } else if (dataset.pointBorderColor) {
        borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
      } else if (dataset.borderColor) {
        borderColor = dataset.borderColor;
      }

      return borderColor;
    },
    getPointBorderWidth: function (point, index) {
      var borderWidth = this.chart.options.elements.point.borderWidth;
      var dataset = this.getDataset();
      var custom = point.custom || {};

      if (!isNaN(custom.borderWidth)) {
        borderWidth = custom.borderWidth;
      } else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
        borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
      } else if (!isNaN(dataset.borderWidth)) {
        borderWidth = dataset.borderWidth;
      }

      return borderWidth;
    },
    getPointRotation: function (point, index) {
      var pointRotation = this.chart.options.elements.point.rotation;
      var dataset = this.getDataset();
      var custom = point.custom || {};

      if (!isNaN(custom.rotation)) {
        pointRotation = custom.rotation;
      } else if (!isNaN(dataset.pointRotation) || helpers.isArray(dataset.pointRotation)) {
        pointRotation = helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointRotation);
      }

      return pointRotation;
    },
    updateElement: function (point, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var custom = point.custom || {};
      var dataset = me.getDataset();
      var datasetIndex = me.index;
      var value = dataset.data[index];
      var yScale = me.getScaleForId(meta.yAxisID);
      var xScale = me.getScaleForId(meta.xAxisID);
      var pointOptions = me.chart.options.elements.point;
      var x, y; // Compatibility: If the properties are defined with only the old name, use those values

      if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
        dataset.pointRadius = dataset.radius;
      }

      if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
        dataset.pointHitRadius = dataset.hitRadius;
      }

      x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
      y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

      point._xScale = xScale;
      point._yScale = yScale;
      point._datasetIndex = datasetIndex;
      point._index = index; // Desired view properties

      point._model = {
        x: x,
        y: y,
        skip: custom.skip || isNaN(x) || isNaN(y),
        // Appearance
        radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
        pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
        rotation: me.getPointRotation(point, index),
        backgroundColor: me.getPointBackgroundColor(point, index),
        borderColor: me.getPointBorderColor(point, index),
        borderWidth: me.getPointBorderWidth(point, index),
        tension: meta.dataset._model ? meta.dataset._model.tension : 0,
        steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
        // Tooltip
        hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
      };
    },
    calculatePointY: function (value, index, datasetIndex) {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var yScale = me.getScaleForId(meta.yAxisID);
      var sumPos = 0;
      var sumNeg = 0;
      var i, ds, dsMeta;

      if (yScale.options.stacked) {
        for (i = 0; i < datasetIndex; i++) {
          ds = chart.data.datasets[i];
          dsMeta = chart.getDatasetMeta(i);

          if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
            var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

            if (stackedRightValue < 0) {
              sumNeg += stackedRightValue || 0;
            } else {
              sumPos += stackedRightValue || 0;
            }
          }
        }

        var rightValue = Number(yScale.getRightValue(value));

        if (rightValue < 0) {
          return yScale.getPixelForValue(sumNeg + rightValue);
        }

        return yScale.getPixelForValue(sumPos + rightValue);
      }

      return yScale.getPixelForValue(value);
    },
    updateBezierControlPoints: function () {
      var me = this;
      var meta = me.getMeta();
      var area = me.chart.chartArea;
      var points = meta.data || [];
      var i, ilen, point, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

      if (meta.dataset._model.spanGaps) {
        points = points.filter(function (pt) {
          return !pt._model.skip;
        });
      }

      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }

      if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
        helpers.splineCurveMonotone(points);
      } else {
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          point = points[i];
          model = point._model;
          controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
          model.controlPointPreviousX = controlPoints.previous.x;
          model.controlPointPreviousY = controlPoints.previous.y;
          model.controlPointNextX = controlPoints.next.x;
          model.controlPointNextY = controlPoints.next.y;
        }
      }

      if (me.chart.options.elements.line.capBezierPoints) {
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
          model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
        }
      }
    },
    draw: function () {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var points = meta.data || [];
      var area = chart.chartArea;
      var ilen = points.length;
      var halfBorderWidth;
      var i = 0;

      if (lineEnabled(me.getDataset(), chart.options)) {
        halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
        helpers.canvas.clipArea(chart.ctx, {
          left: area.left,
          right: area.right,
          top: area.top - halfBorderWidth,
          bottom: area.bottom + halfBorderWidth
        });
        meta.dataset.draw();
        helpers.canvas.unclipArea(chart.ctx);
      } // Draw the points


      for (; i < ilen; ++i) {
        points[i].draw(area);
      }
    },
    setHoverStyle: function (element) {
      // Point
      var dataset = this.chart.data.datasets[element._datasetIndex];
      var index = element._index;
      var custom = element.custom || {};
      var model = element._model;
      element.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
      model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
      model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
      model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
    }
  });
};

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('polarArea', {
  scale: {
    type: 'radialLinear',
    angleLines: {
      display: false
    },
    gridLines: {
      circular: true
    },
    pointLabels: {
      display: false
    },
    ticks: {
      beginAtZero: true
    }
  },
  // Boolean - Whether to animate the rotation of the chart
  animation: {
    animateRotate: true,
    animateScale: true
  },
  startAngle: -0.5 * Math.PI,
  legendCallback: function (chart) {
    var text = [];
    text.push('<ul class="' + chart.id + '-legend">');
    var data = chart.data;
    var datasets = data.datasets;
    var labels = data.labels;

    if (datasets.length) {
      for (var i = 0; i < datasets[0].data.length; ++i) {
        text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

        if (labels[i]) {
          text.push(labels[i]);
        }

        text.push('</li>');
      }
    }

    text.push('</ul>');
    return text.join('');
  },
  legend: {
    labels: {
      generateLabels: function (chart) {
        var data = chart.data;

        if (data.labels.length && data.datasets.length) {
          return data.labels.map(function (label, i) {
            var meta = chart.getDatasetMeta(0);
            var ds = data.datasets[0];
            var arc = meta.data[i];
            var custom = arc.custom || {};
            var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
            var arcOpts = chart.options.elements.arc;
            var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
            var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
            var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
            return {
              text: label,
              fillStyle: fill,
              strokeStyle: stroke,
              lineWidth: bw,
              hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
              // Extra data used for toggling the correct item
              index: i
            };
          });
        }

        return [];
      }
    },
    onClick: function (e, legendItem) {
      var index = legendItem.index;
      var chart = this.chart;
      var i, ilen, meta;

      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
        meta = chart.getDatasetMeta(i);
        meta.data[index].hidden = !meta.data[index].hidden;
      }

      chart.update();
    }
  },
  // Need to override these to give a nice default
  tooltips: {
    callbacks: {
      title: function () {
        return '';
      },
      label: function (item, data) {
        return data.labels[item.index] + ': ' + item.yLabel;
      }
    }
  }
});

module.exports = function (Chart) {
  Chart.controllers.polarArea = Chart.DatasetController.extend({
    dataElementType: elements.Arc,
    linkScales: helpers.noop,
    update: function (reset) {
      var me = this;
      var dataset = me.getDataset();
      var meta = me.getMeta();
      var start = me.chart.options.startAngle || 0;
      var starts = me._starts = [];
      var angles = me._angles = [];
      var i, ilen, angle;

      me._updateRadius();

      meta.count = me.countVisibleElements();

      for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
        starts[i] = start;
        angle = me._computeAngle(i);
        angles[i] = angle;
        start += angle;
      }

      helpers.each(meta.data, function (arc, index) {
        me.updateElement(arc, index, reset);
      });
    },

    /**
     * @private
     */
    _updateRadius: function () {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var arcOpts = opts.elements.arc;
      var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
      chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
      me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
      me.innerRadius = me.outerRadius - chart.radiusLength;
    },
    updateElement: function (arc, index, reset) {
      var me = this;
      var chart = me.chart;
      var dataset = me.getDataset();
      var opts = chart.options;
      var animationOpts = opts.animation;
      var scale = chart.scale;
      var labels = chart.data.labels;
      var centerX = scale.xCenter;
      var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

      var datasetStartAngle = opts.startAngle;
      var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
      var startAngle = me._starts[index];
      var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
      var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
      helpers.extend(arc, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        _scale: scale,
        // Desired view properties
        _model: {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius: reset ? resetRadius : distance,
          startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
          endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
          label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
        }
      }); // Apply border and fill style

      var elementOpts = this.chart.options.elements.arc;
      var custom = arc.custom || {};
      var valueOrDefault = helpers.valueAtIndexOrDefault;
      var model = arc._model;
      model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
      model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
      model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
      arc.pivot();
    },
    countVisibleElements: function () {
      var dataset = this.getDataset();
      var meta = this.getMeta();
      var count = 0;
      helpers.each(meta.data, function (element, index) {
        if (!isNaN(dataset.data[index]) && !element.hidden) {
          count++;
        }
      });
      return count;
    },

    /**
     * @private
     */
    _computeAngle: function (index) {
      var me = this;
      var count = this.getMeta().count;
      var dataset = me.getDataset();
      var meta = me.getMeta();

      if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
        return 0;
      } // Scriptable options


      var context = {
        chart: me.chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      return helpers.options.resolve([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
    }
  });
};

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('radar', {
  scale: {
    type: 'radialLinear'
  },
  elements: {
    line: {
      tension: 0 // no bezier in radar

    }
  }
});

module.exports = function (Chart) {
  Chart.controllers.radar = Chart.DatasetController.extend({
    datasetElementType: elements.Line,
    dataElementType: elements.Point,
    linkScales: helpers.noop,
    update: function (reset) {
      var me = this;
      var meta = me.getMeta();
      var line = meta.dataset;
      var points = meta.data;
      var custom = line.custom || {};
      var dataset = me.getDataset();
      var lineElementOptions = me.chart.options.elements.line;
      var scale = me.chart.scale; // Compatibility: If the properties are defined with only the old name, use those values

      if (dataset.tension !== undefined && dataset.lineTension === undefined) {
        dataset.lineTension = dataset.tension;
      }

      helpers.extend(meta.dataset, {
        // Utility
        _datasetIndex: me.index,
        _scale: scale,
        // Data
        _children: points,
        _loop: true,
        // Model
        _model: {
          // Appearance
          tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
          backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
          borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
          borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
          fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
          borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
          borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
          borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
          borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
        }
      });
      meta.dataset.pivot(); // Update Points

      helpers.each(points, function (point, index) {
        me.updateElement(point, index, reset);
      }, me); // Update bezier control points

      me.updateBezierControlPoints();
    },
    updateElement: function (point, index, reset) {
      var me = this;
      var custom = point.custom || {};
      var dataset = me.getDataset();
      var scale = me.chart.scale;
      var pointElementOptions = me.chart.options.elements.point;
      var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]); // Compatibility: If the properties are defined with only the old name, use those values

      if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
        dataset.pointRadius = dataset.radius;
      }

      if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
        dataset.pointHitRadius = dataset.hitRadius;
      }

      helpers.extend(point, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        _scale: scale,
        // Desired view properties
        _model: {
          x: reset ? scale.xCenter : pointPosition.x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: reset ? scale.yCenter : pointPosition.y,
          // Appearance
          tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
          radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
          backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
          borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
          borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
          pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
          rotation: custom.rotation ? custom.rotation : helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointElementOptions.rotation),
          // Tooltip
          hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
        }
      });
      point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
    },
    updateBezierControlPoints: function () {
      var chartArea = this.chart.chartArea;
      var meta = this.getMeta();
      helpers.each(meta.data, function (point, index) {
        var model = point._model;
        var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

        model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
        model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
        model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
        model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top); // Now pivot the point for animation

        point.pivot();
      });
    },
    setHoverStyle: function (point) {
      // Point
      var dataset = this.chart.data.datasets[point._datasetIndex];
      var custom = point.custom || {};
      var index = point._index;
      var model = point._model;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
      model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
      model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
      model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
    }
  });
};

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

defaults._set('scatter', {
  hover: {
    mode: 'single'
  },
  scales: {
    xAxes: [{
      id: 'x-axis-1',
      // need an ID so datasets can reference the scale
      type: 'linear',
      // scatter should not use a category axis
      position: 'bottom'
    }],
    yAxes: [{
      id: 'y-axis-1',
      type: 'linear',
      position: 'left'
    }]
  },
  showLines: false,
  tooltips: {
    callbacks: {
      title: function () {
        return ''; // doesn't make sense for scatter since data are formatted as a point
      },
      label: function (item) {
        return '(' + item.xLabel + ', ' + item.yLabel + ')';
      }
    }
  }
});

module.exports = function (Chart) {
  // Scatter charts use line controllers
  Chart.controllers.scatter = Chart.controllers.line;
};

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.Bar = function (context, config) {
    config.type = 'bar';
    return new Chart(context, config);
  };
};

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.Bubble = function (context, config) {
    config.type = 'bubble';
    return new Chart(context, config);
  };
};

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.Doughnut = function (context, config) {
    config.type = 'doughnut';
    return new Chart(context, config);
  };
};

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.Line = function (context, config) {
    config.type = 'line';
    return new Chart(context, config);
  };
};

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.PolarArea = function (context, config) {
    config.type = 'polarArea';
    return new Chart(context, config);
  };
};

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.Radar = function (context, config) {
    config.type = 'radar';
    return new Chart(context, config);
  };
};

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
  Chart.Scatter = function (context, config) {
    config.type = 'scatter';
    return new Chart(context, config);
  };
};

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};
module.exports.filler = __webpack_require__(495);
module.exports.legend = __webpack_require__(496);
module.exports.title = __webpack_require__(497);

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Plugin based on discussion from the following Chart.js issues:
 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
 */


var defaults = __webpack_require__(7);

var elements = __webpack_require__(35);

var helpers = __webpack_require__(2);

defaults._set('global', {
  plugins: {
    filler: {
      propagate: true
    }
  }
});

var mappers = {
  dataset: function (source) {
    var index = source.fill;
    var chart = source.chart;
    var meta = chart.getDatasetMeta(index);
    var visible = meta && chart.isDatasetVisible(index);
    var points = visible && meta.dataset._children || [];
    var length = points.length || 0;
    return !length ? null : function (point, i) {
      return i < length && points[i]._view || null;
    };
  },
  boundary: function (source) {
    var boundary = source.boundary;
    var x = boundary ? boundary.x : null;
    var y = boundary ? boundary.y : null;
    return function (point) {
      return {
        x: x === null ? point.x : x,
        y: y === null ? point.y : y
      };
    };
  }
}; // @todo if (fill[0] === '#')

function decodeFill(el, index, count) {
  var model = el._model || {};
  var fill = model.fill;
  var target;

  if (fill === undefined) {
    fill = !!model.backgroundColor;
  }

  if (fill === false || fill === null) {
    return false;
  }

  if (fill === true) {
    return 'origin';
  }

  target = parseFloat(fill, 10);

  if (isFinite(target) && Math.floor(target) === target) {
    if (fill[0] === '-' || fill[0] === '+') {
      target = index + target;
    }

    if (target === index || target < 0 || target >= count) {
      return false;
    }

    return target;
  }

  switch (fill) {
    // compatibility
    case 'bottom':
      return 'start';

    case 'top':
      return 'end';

    case 'zero':
      return 'origin';
    // supported boundaries

    case 'origin':
    case 'start':
    case 'end':
      return fill;
    // invalid fill values

    default:
      return false;
  }
}

function computeBoundary(source) {
  var model = source.el._model || {};
  var scale = source.el._scale || {};
  var fill = source.fill;
  var target = null;
  var horizontal;

  if (isFinite(fill)) {
    return null;
  } // Backward compatibility: until v3, we still need to support boundary values set on
  // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
  // controllers might still use it (e.g. the Smith chart).


  if (fill === 'start') {
    target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
  } else if (fill === 'end') {
    target = model.scaleTop === undefined ? scale.top : model.scaleTop;
  } else if (model.scaleZero !== undefined) {
    target = model.scaleZero;
  } else if (scale.getBasePosition) {
    target = scale.getBasePosition();
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }

  if (target !== undefined && target !== null) {
    if (target.x !== undefined && target.y !== undefined) {
      return target;
    }

    if (typeof target === 'number' && isFinite(target)) {
      horizontal = scale.isHorizontal();
      return {
        x: horizontal ? target : null,
        y: horizontal ? null : target
      };
    }
  }

  return null;
}

function resolveTarget(sources, index, propagate) {
  var source = sources[index];
  var fill = source.fill;
  var visited = [index];
  var target;

  if (!propagate) {
    return fill;
  }

  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isFinite(fill)) {
      return fill;
    }

    target = sources[fill];

    if (!target) {
      return false;
    }

    if (target.visible) {
      return fill;
    }

    visited.push(fill);
    fill = target.fill;
  }

  return false;
}

function createMapper(source) {
  var fill = source.fill;
  var type = 'dataset';

  if (fill === false) {
    return null;
  }

  if (!isFinite(fill)) {
    type = 'boundary';
  }

  return mappers[type](source);
}

function isDrawable(point) {
  return point && !point.skip;
}

function drawArea(ctx, curve0, curve1, len0, len1) {
  var i;

  if (!len0 || !len1) {
    return;
  } // building first area curve (normal)


  ctx.moveTo(curve0[0].x, curve0[0].y);

  for (i = 1; i < len0; ++i) {
    helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
  } // joining the two area curves


  ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

  for (i = len1 - 1; i > 0; --i) {
    helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
  }
}

function doFill(ctx, points, mapper, view, color, loop) {
  var count = points.length;
  var span = view.spanGaps;
  var curve0 = [];
  var curve1 = [];
  var len0 = 0;
  var len1 = 0;
  var i, ilen, index, p0, p1, d0, d1;
  ctx.beginPath();

  for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
    index = i % count;
    p0 = points[index]._view;
    p1 = mapper(p0, index, view);
    d0 = isDrawable(p0);
    d1 = isDrawable(p1);

    if (d0 && d1) {
      len0 = curve0.push(p0);
      len1 = curve1.push(p1);
    } else if (len0 && len1) {
      if (!span) {
        drawArea(ctx, curve0, curve1, len0, len1);
        len0 = len1 = 0;
        curve0 = [];
        curve1 = [];
      } else {
        if (d0) {
          curve0.push(p0);
        }

        if (d1) {
          curve1.push(p1);
        }
      }
    }
  }

  drawArea(ctx, curve0, curve1, len0, len1);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
}

module.exports = {
  id: 'filler',
  afterDatasetsUpdate: function (chart, options) {
    var count = (chart.data.datasets || []).length;
    var propagate = options.propagate;
    var sources = [];
    var meta, i, el, source;

    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      el = meta.dataset;
      source = null;

      if (el && el._model && el instanceof elements.Line) {
        source = {
          visible: chart.isDatasetVisible(i),
          fill: decodeFill(el, i, count),
          chart: chart,
          el: el
        };
      }

      meta.$filler = source;
      sources.push(source);
    }

    for (i = 0; i < count; ++i) {
      source = sources[i];

      if (!source) {
        continue;
      }

      source.fill = resolveTarget(sources, i, propagate);
      source.boundary = computeBoundary(source);
      source.mapper = createMapper(source);
    }
  },
  beforeDatasetDraw: function (chart, args) {
    var meta = args.meta.$filler;

    if (!meta) {
      return;
    }

    var ctx = chart.ctx;
    var el = meta.el;
    var view = el._view;
    var points = el._children || [];
    var mapper = meta.mapper;
    var color = view.backgroundColor || defaults.global.defaultColor;

    if (mapper && color && points.length) {
      helpers.canvas.clipArea(ctx, chart.chartArea);
      doFill(ctx, points, mapper, view, color, el._loop);
      helpers.canvas.unclipArea(ctx);
    }
  }
};

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

var layouts = __webpack_require__(55);

var noop = helpers.noop;

defaults._set('global', {
  legend: {
    display: true,
    position: 'top',
    fullWidth: true,
    reverse: false,
    weight: 1000,
    // a callback that will handle
    onClick: function (e, legendItem) {
      var index = legendItem.datasetIndex;
      var ci = this.chart;
      var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

      meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

      ci.update();
    },
    onHover: null,
    labels: {
      boxWidth: 40,
      padding: 10,
      // Generates labels shown in the legend
      // Valid properties to return:
      // text : text to display
      // fillStyle : fill of coloured box
      // strokeStyle: stroke of coloured box
      // hidden : if this legend item refers to a hidden item
      // lineCap : cap style for line
      // lineDash
      // lineDashOffset :
      // lineJoin :
      // lineWidth :
      generateLabels: function (chart) {
        var data = chart.data;
        return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
          return {
            text: dataset.label,
            fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
            hidden: !chart.isDatasetVisible(i),
            lineCap: dataset.borderCapStyle,
            lineDash: dataset.borderDash,
            lineDashOffset: dataset.borderDashOffset,
            lineJoin: dataset.borderJoinStyle,
            lineWidth: dataset.borderWidth,
            strokeStyle: dataset.borderColor,
            pointStyle: dataset.pointStyle,
            // Below is extra data used for toggling the datasets
            datasetIndex: i
          };
        }, this) : [];
      }
    }
  },
  legendCallback: function (chart) {
    var text = [];
    text.push('<ul class="' + chart.id + '-legend">');

    for (var i = 0; i < chart.data.datasets.length; i++) {
      text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

      if (chart.data.datasets[i].label) {
        text.push(chart.data.datasets[i].label);
      }

      text.push('</li>');
    }

    text.push('</ul>');
    return text.join('');
  }
});
/**
 * Helper function to get the box width based on the usePointStyle option
 * @param labelopts {Object} the label options on the legend
 * @param fontSize {Number} the label font size
 * @return {Number} width of the color box area
 */


function getBoxWidth(labelOpts, fontSize) {
  return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
}
/**
 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
 */


var Legend = Element.extend({
  initialize: function (config) {
    helpers.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

    this.legendHitBoxes = []; // Are we in doughnut mode which has a different data type

    this.doughnutMode = false;
  },
  // These methods are ordered by lifecycle. Utilities then follow.
  // Any function defined here is inherited by all legend types.
  // Any function can be extended by the legend type
  beforeUpdate: noop,
  update: function (maxWidth, maxHeight, margins) {
    var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

    me.beforeUpdate(); // Absorb the master measurements

    me.maxWidth = maxWidth;
    me.maxHeight = maxHeight;
    me.margins = margins; // Dimensions

    me.beforeSetDimensions();
    me.setDimensions();
    me.afterSetDimensions(); // Labels

    me.beforeBuildLabels();
    me.buildLabels();
    me.afterBuildLabels(); // Fit

    me.beforeFit();
    me.fit();
    me.afterFit(); //

    me.afterUpdate();
    return me.minSize;
  },
  afterUpdate: noop,
  //
  beforeSetDimensions: noop,
  setDimensions: function () {
    var me = this; // Set the unconstrained dimension before label rotation

    if (me.isHorizontal()) {
      // Reset position before calculating rotation
      me.width = me.maxWidth;
      me.left = 0;
      me.right = me.width;
    } else {
      me.height = me.maxHeight; // Reset position before calculating rotation

      me.top = 0;
      me.bottom = me.height;
    } // Reset padding


    me.paddingLeft = 0;
    me.paddingTop = 0;
    me.paddingRight = 0;
    me.paddingBottom = 0; // Reset minSize

    me.minSize = {
      width: 0,
      height: 0
    };
  },
  afterSetDimensions: noop,
  //
  beforeBuildLabels: noop,
  buildLabels: function () {
    var me = this;
    var labelOpts = me.options.labels || {};
    var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

    if (labelOpts.filter) {
      legendItems = legendItems.filter(function (item) {
        return labelOpts.filter(item, me.chart.data);
      });
    }

    if (me.options.reverse) {
      legendItems.reverse();
    }

    me.legendItems = legendItems;
  },
  afterBuildLabels: noop,
  //
  beforeFit: noop,
  fit: function () {
    var me = this;
    var opts = me.options;
    var labelOpts = opts.labels;
    var display = opts.display;
    var ctx = me.ctx;
    var globalDefault = defaults.global;
    var valueOrDefault = helpers.valueOrDefault;
    var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
    var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
    var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
    var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Reset hit boxes

    var hitboxes = me.legendHitBoxes = [];
    var minSize = me.minSize;
    var isHorizontal = me.isHorizontal();

    if (isHorizontal) {
      minSize.width = me.maxWidth; // fill all the width

      minSize.height = display ? 10 : 0;
    } else {
      minSize.width = display ? 10 : 0;
      minSize.height = me.maxHeight; // fill all the height
    } // Increase sizes here


    if (display) {
      ctx.font = labelFont;

      if (isHorizontal) {
        // Labels
        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
        var lineWidths = me.lineWidths = [0];
        var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        helpers.each(me.legendItems, function (legendItem, i) {
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

          if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
            totalHeight += fontSize + labelOpts.padding;
            lineWidths[lineWidths.length] = me.left;
          } // Store the hitbox width and height here. Final position will be updated in `draw`


          hitboxes[i] = {
            left: 0,
            top: 0,
            width: width,
            height: fontSize
          };
          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
        });
        minSize.height += totalHeight;
      } else {
        var vPadding = labelOpts.padding;
        var columnWidths = me.columnWidths = [];
        var totalWidth = labelOpts.padding;
        var currentColWidth = 0;
        var currentColHeight = 0;
        var itemHeight = fontSize + vPadding;
        helpers.each(me.legendItems, function (legendItem, i) {
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

          if (currentColHeight + itemHeight > minSize.height) {
            totalWidth += currentColWidth + labelOpts.padding;
            columnWidths.push(currentColWidth); // previous column width

            currentColWidth = 0;
            currentColHeight = 0;
          } // Get max width


          currentColWidth = Math.max(currentColWidth, itemWidth);
          currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

          hitboxes[i] = {
            left: 0,
            top: 0,
            width: itemWidth,
            height: fontSize
          };
        });
        totalWidth += currentColWidth;
        columnWidths.push(currentColWidth);
        minSize.width += totalWidth;
      }
    }

    me.width = minSize.width;
    me.height = minSize.height;
  },
  afterFit: noop,
  // Shared Methods
  isHorizontal: function () {
    return this.options.position === 'top' || this.options.position === 'bottom';
  },
  // Actually draw the legend on the canvas
  draw: function () {
    var me = this;
    var opts = me.options;
    var labelOpts = opts.labels;
    var globalDefault = defaults.global;
    var lineDefault = globalDefault.elements.line;
    var legendWidth = me.width;
    var lineWidths = me.lineWidths;

    if (opts.display) {
      var ctx = me.ctx;
      var valueOrDefault = helpers.valueOrDefault;
      var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
      var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
      var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
      var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
      var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
      var cursor; // Canvas setup

      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = fontColor; // for strikethrough effect

      ctx.fillStyle = fontColor; // render in correct colour

      ctx.font = labelFont;
      var boxWidth = getBoxWidth(labelOpts, fontSize);
      var hitboxes = me.legendHitBoxes; // current position

      var drawLegendBox = function (x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0) {
          return;
        } // Set the ctx for the box


        ctx.save();
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
        ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
        var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;

        if (ctx.setLineDash) {
          // IE 9 and 10 do not support line dash
          ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
        }

        if (opts.labels && opts.labels.usePointStyle) {
          // Recalculate x and y for drawPoint() because its expecting
          // x and y to be center of figure (instead of top left)
          var radius = fontSize * Math.SQRT2 / 2;
          var offSet = radius / Math.SQRT2;
          var centerX = x + offSet;
          var centerY = y + offSet; // Draw pointStyle as legend symbol

          helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
        } else {
          // Draw box as legend symbol
          if (!isLineWidthZero) {
            ctx.strokeRect(x, y, boxWidth, fontSize);
          }

          ctx.fillRect(x, y, boxWidth, fontSize);
        }

        ctx.restore();
      };

      var fillText = function (x, y, legendItem, textWidth) {
        var halfFontSize = fontSize / 2;
        var xLeft = boxWidth + halfFontSize + x;
        var yMiddle = y + halfFontSize;
        ctx.fillText(legendItem.text, xLeft, yMiddle);

        if (legendItem.hidden) {
          // Strikethrough the text if hidden
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.moveTo(xLeft, yMiddle);
          ctx.lineTo(xLeft + textWidth, yMiddle);
          ctx.stroke();
        }
      }; // Horizontal


      var isHorizontal = me.isHorizontal();

      if (isHorizontal) {
        cursor = {
          x: me.left + (legendWidth - lineWidths[0]) / 2,
          y: me.top + labelOpts.padding,
          line: 0
        };
      } else {
        cursor = {
          x: me.left + labelOpts.padding,
          y: me.top + labelOpts.padding,
          line: 0
        };
      }

      var itemHeight = fontSize + labelOpts.padding;
      helpers.each(me.legendItems, function (legendItem, i) {
        var textWidth = ctx.measureText(legendItem.text).width;
        var width = boxWidth + fontSize / 2 + textWidth;
        var x = cursor.x;
        var y = cursor.y;

        if (isHorizontal) {
          if (x + width >= legendWidth) {
            y = cursor.y += itemHeight;
            cursor.line++;
            x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
          }
        } else if (y + itemHeight > me.bottom) {
          x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
          y = cursor.y = me.top + labelOpts.padding;
          cursor.line++;
        }

        drawLegendBox(x, y, legendItem);
        hitboxes[i].left = x;
        hitboxes[i].top = y; // Fill the actual label

        fillText(x, y, legendItem, textWidth);

        if (isHorizontal) {
          cursor.x += width + labelOpts.padding;
        } else {
          cursor.y += itemHeight;
        }
      });
    }
  },

  /**
   * Handle an event
   * @private
   * @param {IEvent} event - The event to handle
   * @return {Boolean} true if a change occured
   */
  handleEvent: function (e) {
    var me = this;
    var opts = me.options;
    var type = e.type === 'mouseup' ? 'click' : e.type;
    var changed = false;

    if (type === 'mousemove') {
      if (!opts.onHover) {
        return;
      }
    } else if (type === 'click') {
      if (!opts.onClick) {
        return;
      }
    } else {
      return;
    } // Chart event already has relative position in it


    var x = e.x;
    var y = e.y;

    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
      // See if we are touching one of the dataset boxes
      var lh = me.legendHitBoxes;

      for (var i = 0; i < lh.length; ++i) {
        var hitBox = lh[i];

        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
          // Touching an element
          if (type === 'click') {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, me.legendItems[i]);
            changed = true;
            break;
          } else if (type === 'mousemove') {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, me.legendItems[i]);
            changed = true;
            break;
          }
        }
      }
    }

    return changed;
  }
});

function createNewLegendAndAttach(chart, legendOpts) {
  var legend = new Legend({
    ctx: chart.ctx,
    options: legendOpts,
    chart: chart
  });
  layouts.configure(chart, legend, legendOpts);
  layouts.addBox(chart, legend);
  chart.legend = legend;
}

module.exports = {
  id: 'legend',

  /**
   * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
   * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
   * the plugin, which one will be re-exposed in the chart.js file.
   * https://github.com/chartjs/Chart.js/pull/2640
   * @private
   */
  _element: Legend,
  beforeInit: function (chart) {
    var legendOpts = chart.options.legend;

    if (legendOpts) {
      createNewLegendAndAttach(chart, legendOpts);
    }
  },
  beforeUpdate: function (chart) {
    var legendOpts = chart.options.legend;
    var legend = chart.legend;

    if (legendOpts) {
      helpers.mergeIf(legendOpts, defaults.global.legend);

      if (legend) {
        layouts.configure(chart, legend, legendOpts);
        legend.options = legendOpts;
      } else {
        createNewLegendAndAttach(chart, legendOpts);
      }
    } else if (legend) {
      layouts.removeBox(chart, legend);
      delete chart.legend;
    }
  },
  afterEvent: function (chart, e) {
    var legend = chart.legend;

    if (legend) {
      legend.handleEvent(e);
    }
  }
};

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(7);

var Element = __webpack_require__(25);

var helpers = __webpack_require__(2);

var layouts = __webpack_require__(55);

var noop = helpers.noop;

defaults._set('global', {
  title: {
    display: false,
    fontStyle: 'bold',
    fullWidth: true,
    lineHeight: 1.2,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000 // by default greater than legend (1000) to be above

  }
});
/**
 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
 */


var Title = Element.extend({
  initialize: function (config) {
    var me = this;
    helpers.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

    me.legendHitBoxes = [];
  },
  // These methods are ordered by lifecycle. Utilities then follow.
  beforeUpdate: noop,
  update: function (maxWidth, maxHeight, margins) {
    var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

    me.beforeUpdate(); // Absorb the master measurements

    me.maxWidth = maxWidth;
    me.maxHeight = maxHeight;
    me.margins = margins; // Dimensions

    me.beforeSetDimensions();
    me.setDimensions();
    me.afterSetDimensions(); // Labels

    me.beforeBuildLabels();
    me.buildLabels();
    me.afterBuildLabels(); // Fit

    me.beforeFit();
    me.fit();
    me.afterFit(); //

    me.afterUpdate();
    return me.minSize;
  },
  afterUpdate: noop,
  //
  beforeSetDimensions: noop,
  setDimensions: function () {
    var me = this; // Set the unconstrained dimension before label rotation

    if (me.isHorizontal()) {
      // Reset position before calculating rotation
      me.width = me.maxWidth;
      me.left = 0;
      me.right = me.width;
    } else {
      me.height = me.maxHeight; // Reset position before calculating rotation

      me.top = 0;
      me.bottom = me.height;
    } // Reset padding


    me.paddingLeft = 0;
    me.paddingTop = 0;
    me.paddingRight = 0;
    me.paddingBottom = 0; // Reset minSize

    me.minSize = {
      width: 0,
      height: 0
    };
  },
  afterSetDimensions: noop,
  //
  beforeBuildLabels: noop,
  buildLabels: noop,
  afterBuildLabels: noop,
  //
  beforeFit: noop,
  fit: function () {
    var me = this;
    var valueOrDefault = helpers.valueOrDefault;
    var opts = me.options;
    var display = opts.display;
    var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
    var minSize = me.minSize;
    var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
    var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
    var textSize = display ? lineCount * lineHeight + opts.padding * 2 : 0;

    if (me.isHorizontal()) {
      minSize.width = me.maxWidth; // fill all the width

      minSize.height = textSize;
    } else {
      minSize.width = textSize;
      minSize.height = me.maxHeight; // fill all the height
    }

    me.width = minSize.width;
    me.height = minSize.height;
  },
  afterFit: noop,
  // Shared Methods
  isHorizontal: function () {
    var pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  },
  // Actually draw the title block on the canvas
  draw: function () {
    var me = this;
    var ctx = me.ctx;
    var valueOrDefault = helpers.valueOrDefault;
    var opts = me.options;
    var globalDefaults = defaults.global;

    if (opts.display) {
      var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
      var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
      var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
      var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
      var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
      var offset = lineHeight / 2 + opts.padding;
      var rotation = 0;
      var top = me.top;
      var left = me.left;
      var bottom = me.bottom;
      var right = me.right;
      var maxWidth, titleX, titleY;
      ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour

      ctx.font = titleFont; // Horizontal

      if (me.isHorizontal()) {
        titleX = left + (right - left) / 2; // midpoint of the width

        titleY = top + offset;
        maxWidth = right - left;
      } else {
        titleX = opts.position === 'left' ? left + offset : right - offset;
        titleY = top + (bottom - top) / 2;
        maxWidth = bottom - top;
        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
      }

      ctx.save();
      ctx.translate(titleX, titleY);
      ctx.rotate(rotation);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      var text = opts.text;

      if (helpers.isArray(text)) {
        var y = 0;

        for (var i = 0; i < text.length; ++i) {
          ctx.fillText(text[i], 0, y, maxWidth);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, 0, 0, maxWidth);
      }

      ctx.restore();
    }
  }
});

function createNewTitleBlockAndAttach(chart, titleOpts) {
  var title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart: chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}

module.exports = {
  id: 'title',

  /**
   * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
   * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
   * the plugin, which one will be re-exposed in the chart.js file.
   * https://github.com/chartjs/Chart.js/pull/2640
   * @private
   */
  _element: Title,
  beforeInit: function (chart) {
    var titleOpts = chart.options.title;

    if (titleOpts) {
      createNewTitleBlockAndAttach(chart, titleOpts);
    }
  },
  beforeUpdate: function (chart) {
    var titleOpts = chart.options.title;
    var titleBlock = chart.titleBlock;

    if (titleOpts) {
      helpers.mergeIf(titleOpts, defaults.global.title);

      if (titleBlock) {
        layouts.configure(chart, titleBlock, titleOpts);
        titleBlock.options = titleOpts;
      } else {
        createNewTitleBlockAndAttach(chart, titleOpts);
      }
    } else if (titleBlock) {
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    }
  }
};

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (global) {
  /**
   * Polyfill URLSearchParams
   *
   * Inspired from : https://github.com/WebReflection/url-search-params/blob/master/src/url-search-params.js
   */
  var checkIfIteratorIsSupported = function () {
    try {
      return !!Symbol.iterator;
    } catch (error) {
      return false;
    }
  };

  var iteratorSupported = checkIfIteratorIsSupported();

  var createIterator = function (items) {
    var iterator = {
      next: function () {
        var value = items.shift();
        return {
          done: value === void 0,
          value: value
        };
      }
    };

    if (iteratorSupported) {
      iterator[Symbol.iterator] = function () {
        return iterator;
      };
    }

    return iterator;
  };
  /**
   * Search param name and values should be encoded according to https://url.spec.whatwg.org/#urlencoded-serializing
   * encodeURIComponent() produces the same result except encoding spaces as `%20` instead of `+`.
   */


  var serializeParam = function (value) {
    return encodeURIComponent(value).replace(/%20/g, '+');
  };

  var deserializeParam = function (value) {
    return decodeURIComponent(value).replace(/\+/g, ' ');
  };

  var polyfillURLSearchParams = function () {
    var URLSearchParams = function (searchString) {
      Object.defineProperty(this, '_entries', {
        writable: true,
        value: {}
      });
      var typeofSearchString = typeof searchString;

      if (typeofSearchString === 'undefined') {// do nothing
      } else if (typeofSearchString === 'string') {
        if (searchString !== '') {
          this._fromString(searchString);
        }
      } else if (searchString instanceof URLSearchParams) {
        var _this = this;

        searchString.forEach(function (value, name) {
          _this.append(name, value);
        });
      } else if (searchString !== null && typeofSearchString === 'object') {
        if (Object.prototype.toString.call(searchString) === '[object Array]') {
          for (var i = 0; i < searchString.length; i++) {
            var entry = searchString[i];

            if (Object.prototype.toString.call(entry) === '[object Array]' || entry.length !== 2) {
              this.append(entry[0], entry[1]);
            } else {
              throw new TypeError('Expected [string, any] as entry at index ' + i + ' of URLSearchParams\'s input');
            }
          }
        } else {
          for (var key in searchString) {
            if (searchString.hasOwnProperty(key)) {
              this.append(key, searchString[key]);
            }
          }
        }
      } else {
        throw new TypeError('Unsupported input\'s type for URLSearchParams');
      }
    };

    var proto = URLSearchParams.prototype;

    proto.append = function (name, value) {
      if (name in this._entries) {
        this._entries[name].push(String(value));
      } else {
        this._entries[name] = [String(value)];
      }
    };

    proto.delete = function (name) {
      delete this._entries[name];
    };

    proto.get = function (name) {
      return name in this._entries ? this._entries[name][0] : null;
    };

    proto.getAll = function (name) {
      return name in this._entries ? this._entries[name].slice(0) : [];
    };

    proto.has = function (name) {
      return name in this._entries;
    };

    proto.set = function (name, value) {
      this._entries[name] = [String(value)];
    };

    proto.forEach = function (callback, thisArg) {
      var entries;

      for (var name in this._entries) {
        if (this._entries.hasOwnProperty(name)) {
          entries = this._entries[name];

          for (var i = 0; i < entries.length; i++) {
            callback.call(thisArg, entries[i], name, this);
          }
        }
      }
    };

    proto.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return createIterator(items);
    };

    proto.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return createIterator(items);
    };

    proto.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return createIterator(items);
    };

    if (iteratorSupported) {
      proto[Symbol.iterator] = proto.entries;
    }

    proto.toString = function () {
      var searchArray = [];
      this.forEach(function (value, name) {
        searchArray.push(serializeParam(name) + '=' + serializeParam(value));
      });
      return searchArray.join('&');
    };

    global.URLSearchParams = URLSearchParams;
  };

  if (!('URLSearchParams' in global) || new URLSearchParams('?a=1').toString() !== 'a=1') {
    polyfillURLSearchParams();
  }

  var proto = URLSearchParams.prototype;

  if (typeof proto.sort !== 'function') {
    proto.sort = function () {
      var _this = this;

      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);

        if (!_this._entries) {
          _this.delete(name);
        }
      });
      items.sort(function (a, b) {
        if (a[0] < b[0]) {
          return -1;
        } else if (a[0] > b[0]) {
          return +1;
        } else {
          return 0;
        }
      });

      if (_this._entries) {
        // force reset because IE keeps keys index
        _this._entries = {};
      }

      for (var i = 0; i < items.length; i++) {
        this.append(items[i][0], items[i][1]);
      }
    };
  }

  if (typeof proto._fromString !== 'function') {
    Object.defineProperty(proto, '_fromString', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: function (searchString) {
        if (this._entries) {
          this._entries = {};
        } else {
          var keys = [];
          this.forEach(function (value, name) {
            keys.push(name);
          });

          for (var i = 0; i < keys.length; i++) {
            this.delete(keys[i]);
          }
        }

        searchString = searchString.replace(/^\?/, '');
        var attributes = searchString.split('&');
        var attribute;

        for (var i = 0; i < attributes.length; i++) {
          attribute = attributes[i].split('=');
          this.append(deserializeParam(attribute[0]), attribute.length > 1 ? deserializeParam(attribute[1]) : '');
        }
      }
    });
  } // HTMLAnchorElement

})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : this);

(function (global) {
  /**
   * Polyfill URL
   *
   * Inspired from : https://github.com/arv/DOM-URL-Polyfill/blob/master/src/url.js
   */
  var checkIfURLIsSupported = function () {
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      return u.href === 'http://a/c%20d' && u.searchParams;
    } catch (e) {
      return false;
    }
  };

  var polyfillURL = function () {
    var _URL = global.URL;

    var URL = function (url, base) {
      if (typeof url !== 'string') url = String(url); // Only create another document if the base is different from current location.

      var doc = document,
          baseElement;

      if (base && (global.location === void 0 || base !== global.location.href)) {
        doc = document.implementation.createHTMLDocument('');
        baseElement = doc.createElement('base');
        baseElement.href = base;
        doc.head.appendChild(baseElement);

        try {
          if (baseElement.href.indexOf(base) !== 0) throw new Error(baseElement.href);
        } catch (err) {
          throw new Error('URL unable to set base ' + base + ' due to ' + err);
        }
      }

      var anchorElement = doc.createElement('a');
      anchorElement.href = url;

      if (baseElement) {
        doc.body.appendChild(anchorElement);
        anchorElement.href = anchorElement.href; // force href to refresh
      }

      if (anchorElement.protocol === ':' || !/:/.test(anchorElement.href)) {
        throw new TypeError('Invalid URL');
      }

      Object.defineProperty(this, '_anchorElement', {
        value: anchorElement
      }); // create a linked searchParams which reflect its changes on URL

      var searchParams = new URLSearchParams(this.search);
      var enableSearchUpdate = true;
      var enableSearchParamsUpdate = true;

      var _this = this;

      ['append', 'delete', 'set'].forEach(function (methodName) {
        var method = searchParams[methodName];

        searchParams[methodName] = function () {
          method.apply(searchParams, arguments);

          if (enableSearchUpdate) {
            enableSearchParamsUpdate = false;
            _this.search = searchParams.toString();
            enableSearchParamsUpdate = true;
          }
        };
      });
      Object.defineProperty(this, 'searchParams', {
        value: searchParams,
        enumerable: true
      });
      var search = void 0;
      Object.defineProperty(this, '_updateSearchParams', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function () {
          if (this.search !== search) {
            search = this.search;

            if (enableSearchParamsUpdate) {
              enableSearchUpdate = false;

              this.searchParams._fromString(this.search);

              enableSearchUpdate = true;
            }
          }
        }
      });
    };

    var proto = URL.prototype;

    var linkURLWithAnchorAttribute = function (attributeName) {
      Object.defineProperty(proto, attributeName, {
        get: function () {
          return this._anchorElement[attributeName];
        },
        set: function (value) {
          this._anchorElement[attributeName] = value;
        },
        enumerable: true
      });
    };

    ['hash', 'host', 'hostname', 'port', 'protocol'].forEach(function (attributeName) {
      linkURLWithAnchorAttribute(attributeName);
    });
    Object.defineProperty(proto, 'search', {
      get: function () {
        return this._anchorElement['search'];
      },
      set: function (value) {
        this._anchorElement['search'] = value;

        this._updateSearchParams();
      },
      enumerable: true
    });
    Object.defineProperties(proto, {
      'toString': {
        get: function () {
          var _this = this;

          return function () {
            return _this.href;
          };
        }
      },
      'href': {
        get: function () {
          return this._anchorElement.href.replace(/\?$/, '');
        },
        set: function (value) {
          this._anchorElement.href = value;

          this._updateSearchParams();
        },
        enumerable: true
      },
      'pathname': {
        get: function () {
          return this._anchorElement.pathname.replace(/(^\/?)/, '/');
        },
        set: function (value) {
          this._anchorElement.pathname = value;
        },
        enumerable: true
      },
      'origin': {
        get: function () {
          // get expected port from protocol
          var expectedPort = {
            'http:': 80,
            'https:': 443,
            'ftp:': 21
          }[this._anchorElement.protocol]; // add port to origin if, expected port is different than actual port
          // and it is not empty f.e http://foo:8080
          // 8080 != 80 && 8080 != ''

          var addPortToOrigin = this._anchorElement.port != expectedPort && this._anchorElement.port !== '';
          return this._anchorElement.protocol + '//' + this._anchorElement.hostname + (addPortToOrigin ? ':' + this._anchorElement.port : '');
        },
        enumerable: true
      },
      'password': {
        // TODO
        get: function () {
          return '';
        },
        set: function (value) {},
        enumerable: true
      },
      'username': {
        // TODO
        get: function () {
          return '';
        },
        set: function (value) {},
        enumerable: true
      }
    });

    URL.createObjectURL = function (blob) {
      return _URL.createObjectURL.apply(_URL, arguments);
    };

    URL.revokeObjectURL = function (url) {
      return _URL.revokeObjectURL.apply(_URL, arguments);
    };

    global.URL = URL;
  };

  if (!checkIfURLIsSupported()) {
    polyfillURL();
  }

  if (global.location !== void 0 && !('origin' in global.location)) {
    var getOrigin = function () {
      return global.location.protocol + '//' + global.location.hostname + (global.location.port ? ':' + global.location.port : '');
    };

    try {
      Object.defineProperty(global.location, 'origin', {
        get: getOrigin,
        enumerable: true
      });
    } catch (e) {
      setInterval(function () {
        global.location.origin = getOrigin();
      }, 100);
    }
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(70)))

/***/ }),
/* 499 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabsCordion; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__slideToggler__ = __webpack_require__(99);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var TabsCordion =
/*#__PURE__*/
function () {
  function TabsCordion() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.tabs';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'tabs';

    _classCallCheck(this, TabsCordion);

    this.selector = selector;
    this.prefix = prefix;
    this.options = {
      class: {
        trigger: "".concat(this.prefix, "__trigger"),
        // Clicked title in accordion or in tabs
        panel: "".concat(this.prefix, "__panel"),
        list: "".concat(this.prefix, "__list"),
        // List of tab state title
        listItem: "".concat(this.prefix, "__list-item"),
        // Title item for tabs
        typeAccordion: '-type-accordion',
        typeTab: '-type-tabs',
        stateActive: '-current',
        // stateDisabled: '-disabled', todo
        stateHidden: 'ghost'
      },
      onlyState: null,
      titleSelector: 'h2',
      initIndex: 0,
      eq: 0,
      // which tab open on init
      breakpoint: 768,
      // px
      slideDuration: 300,
      // ms
      beforeInit: function beforeInit() {},
      afterInit: function afterInit() {},
      preCreateTrigger: function preCreateTrigger(text) {
        var checkText = text.children;
        var trigger = null; // If already has a button

        if (checkText.length && checkText[0] instanceof HTMLElement && checkText[0].nodeName === 'BUTTON') {
          trigger = checkText[0]; // text.innerText = checkText[0].innerText;
        } else {
          trigger = document.createElement('button');
          trigger.innerHTML = text.innerHTML;
        }

        return trigger;
      }
    };

    if (options instanceof Object) {
      this.options = __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](this.options, options);
    }

    this.checkBeforeInit();
  }

  _createClass(TabsCordion, [{
    key: "checkBeforeInit",
    value: function checkBeforeInit() {
      if (typeof this.selector === 'string') {
        var els = document.querySelectorAll(this.selector);

        for (var i = 0; i < els.length; i++) {
          var el = new TabsCordion(els[i], this.options);
        }
      } else {
        this.options.beforeInit(this.selector);
        this.init();
        this.options.afterInit(this.selector);
      }
    }
  }, {
    key: "init",
    value: function init() {
      this.create(this.isTabs()); // setTimeout(this.destroy.bind(this), 1000);

      this.initEvents();
    }
  }, {
    key: "getState",
    value: function getState() {
      if (!this.options.onlyState) {
        return window.innerWidth < this.options.breakpoint ? 'accordion' : 'tabs';
      }

      return this.options.onlyState;
    }
  }, {
    key: "isTabs",
    value: function isTabs() {
      return this.getState() === 'tabs';
    }
  }, {
    key: "create",
    value: function create(isTabs) {
      var _this = this;

      var eqs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.eq;
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](this.selector, this.options.class[isTabs ? 'typeTab' : 'typeAccordion']);
      var tabsList;
      var titles = Array.prototype.slice.call(this.selector.querySelectorAll(this.options.titleSelector));

      if (isTabs) {
        tabsList = "<ul class=\"".concat(this.options.class.list, "\" role=\"tablist\">");
      } else {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](this.selector, {
          role: 'tablist'
        });
      }

      titles.forEach(function (title, i) {
        var panel = title.parentNode;
        var id = panel.dataset.id || __WEBPACK_IMPORTED_MODULE_0__helpers__["l" /* getUniqId */]();
        var isActive = id === eqs || i === parseInt(eqs, 10);

        var trigger = _this.createTrigger(id, title, isTabs); // Visually hide the Title


        __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](title, _this.options.class.stateHidden);
        __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](panel, {
          'data-id': id,
          // do not remove this attr
          'id': "control-".concat(id),
          'aria-labelledby': "labled-".concat(id),
          'role': 'tabpanel',
          'aria-hidden': true // will change on switch tabs

        }); // Init toggler before call activatePanel method

        if (!isTabs && !panel.slideToggler) {
          panel.slideToggler = new __WEBPACK_IMPORTED_MODULE_1__slideToggler__["a" /* default */](panel);
        }

        if (isActive) {
          _this.activateTrigger(trigger, isTabs);

          _this.activatePanel(panel, isTabs);

          __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](_this.selector, {
            'data-current': id
          });
        }

        if (isTabs) {
          tabsList += "<li class=\"".concat(_this.options.class.listItem, "\" role=\"presentation\">").concat(trigger.outerHTML, "</li>");
        } else {
          panel.parentNode.insertBefore(trigger, panel);
        }
      });

      if (isTabs) {
        tabsList += '</ul>'; // Prepend tabs list before the tab panels

        this.selector.innerHTML = tabsList + this.selector.innerHTML;
      }
    }
  }, {
    key: "createTrigger",
    value: function createTrigger(id, text, isTabs) {
      var trigger = this.options.preCreateTrigger(text); // Add attributes for the Trigger

      __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](trigger, {
        'id': "labled-".concat(id),
        'aria-controls': "control-".concat(id),
        'type': 'button',
        'role': 'tab',
        'aria-selected': false // will change on switch tabs
        // 'class': this.options.class.trigger,

      });
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](trigger, this.options.class.trigger);

      if (!isTabs) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](trigger, {
          'aria-expanded': false // only for accordion

        });
      }

      return trigger;
    }
  }, {
    key: "activatePanel",
    value: function activatePanel(panel, isTabs) {
      if (!isTabs && panel.slideToggler) {
        panel.slideToggler.open();
      }

      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](panel, this.options.class.stateActive);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["v" /* removeAttributes */](panel, ['aria-hidden']);
    }
  }, {
    key: "deactivatePanel",
    value: function deactivatePanel(panel, isTabs) {
      if (!isTabs && panel.slideToggler) {
        panel.slideToggler.close();
      }

      __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](panel, this.options.class.stateActive);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](panel, {
        'aria-hidden': true // will change on switch tabs

      });
    }
  }, {
    key: "activateTrigger",
    value: function activateTrigger(trigger, isTabs) {
      trigger.focus();
      __WEBPACK_IMPORTED_MODULE_0__helpers__["a" /* addClass */](trigger, this.options.class.stateActive);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](trigger, {
        'aria-selected': true // will change on switch tabs

      });

      if (!isTabs) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](trigger, {
          'aria-expanded': true // only for accordion

        });
      }
    }
  }, {
    key: "deactivateTrigger",
    value: function deactivateTrigger(trigger, isTabs) {
      __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](trigger, this.options.class.stateActive);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](trigger, {
        'aria-selected': false // will change on switch tabs

      });

      if (!isTabs) {
        __WEBPACK_IMPORTED_MODULE_0__helpers__["y" /* setAttributes */](trigger, {
          'aria-expanded': false // only for accordion

        });
      }
    }
  }, {
    key: "switchTab",
    value: function switchTab(trigger) {
      var isTabs = this.isTabs();
      var currentId = this.selector.dataset.current; // Update current id

      this.selector.dataset.current = trigger.id.replace('labled-', ''); // Deactivate current trigger and panel

      this.deactivateTrigger(document.getElementById("labled-".concat(currentId)), isTabs);
      this.deactivatePanel(document.getElementById("control-".concat(currentId)), isTabs); // activate new ones

      this.activateTrigger(trigger, isTabs);
      this.activatePanel(document.getElementById(trigger.getAttribute('aria-controls')), isTabs);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      // Remove role attribute from main container if exists
      __WEBPACK_IMPORTED_MODULE_0__helpers__["v" /* removeAttributes */](this.selector, ['role']);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](this.selector, this.options.class.typeAccordion);
      __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](this.selector, this.options.class.typeTab); // Remove tabs list if it exists

      var list = this.selector.querySelector(".".concat(this.options.class.list));

      if (list) {
        this.selector.removeChild(list); // remove tabs list
      }

      var children = Array.prototype.slice.call(this.selector.childNodes); // Get all children of main container

      children = children.filter(function (child) {
        return child.nodeName !== '#text';
      }); // filter text nodes from children set

      children.forEach(function (child) {
        if (child.nodeName === 'BUTTON') {
          child.removeEventListener('click', TabsCordion.onTogglerClick.bind(_this2));
          child.parentNode.removeChild(child); // remove this child if it's a button
        } else {
          __WEBPACK_IMPORTED_MODULE_0__helpers__["v" /* removeAttributes */](child, ['id', 'aria-labelledby', 'role', 'aria-hidden', 'style']); // remove all generated attributes from content item

          __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](child, _this2.options.class.stateActive);
          var title = child.querySelector(_this2.options.titleSelector);

          if (title) {
            __WEBPACK_IMPORTED_MODULE_0__helpers__["w" /* removeClass */](title, _this2.options.class.stateHidden);
          }
        }
      });
    }
  }, {
    key: "initEvents",
    value: function initEvents() {
      var _this3 = this;

      this.initEventsTriggers(); // let panels = Array.prototype.slice.call(this.selector.querySelectorAll(`.${this.options.class.panel}`)); // Get all panels of main container
      // panels = panels.filter(panel => panel.slideToggler);

      window.addEventListener('responsive', function () {
        var isTabs = _this3.isTabs();

        var currentStateTabs = __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](_this3.selector, _this3.options.class.typeTab);

        if (isTabs !== currentStateTabs) {
          // console.log( `change state from ${currentStateTabs ? 'tabs' : 'accordion'} to ${isTabs ? 'tabs' : 'accordion'}` );
          _this3.destroy();

          _this3.create(isTabs, _this3.selector.dataset.current);

          _this3.initEventsTriggers();
        } // Causes a bug. Recalculates panels height after resize
        // if (!isTabs) {
        //     panels.forEach((panel) => {
        //         if(panel.slideToggler){
        //             panel.slideToggler.updateValues();
        //             //panel.slideToggler.updateValues.bind(panel.slideToggler)();
        //         }
        //     });
        // }

      });
    }
  }, {
    key: "initEventsTriggers",
    value: function initEventsTriggers() {
      var _this4 = this;

      var triggers = Array.prototype.slice.call(this.selector.querySelectorAll(".".concat(this.options.class.trigger))); // Get all triggers of main container

      triggers.forEach(function (trigger) {
        trigger.addEventListener('click', TabsCordion.onTogglerClick.bind(_this4));
        trigger.addEventListener('keydown', function (e) {
          return TabsCordion.onTogglerKeyDown.call(_this4, e, triggers);
        });
      });
    }
  }], [{
    key: "onTogglerClick",
    value: function onTogglerClick(e) {
      var clickedTrigger = e.target;
      var clickedId = clickedTrigger.id.replace('labled-', '');
      var currentId = this.selector.dataset.current;

      if (clickedId !== currentId) {
        this.switchTab(clickedTrigger);
      }
    }
  }, {
    key: "onTogglerKeyDown",
    value: function onTogglerKeyDown(e, triggers) {
      var currentTrigger = document.getElementById("labled-".concat(this.selector.dataset.current));
      var currentIndex = triggers.indexOf(currentTrigger);
      var firstTrigger = triggers[0];
      var lastTrigger = triggers[triggers.length - 1];

      if (e.keyCode === 36) {
        // strike home on a tab => 1st tab
        if (currentTrigger !== firstTrigger) {
          this.switchTab(firstTrigger);
        }

        e.preventDefault();
      } else if (e.keyCode === 35) {
        // strike end on a tab => last tab
        if (currentTrigger !== lastTrigger) {
          this.switchTab(lastTrigger);
        }

        e.preventDefault();
      } else if (e.keyCode === 37 && !e.ctrlKey) {
        // strike left on the tab => previous tab
        if (currentTrigger === firstTrigger) {
          this.switchTab(lastTrigger);
        } else {
          this.switchTab(triggers[currentIndex - 1]);
        }

        e.preventDefault();
      } else if (e.keyCode === 39 && !e.ctrlKey) {
        // strike right in the tab => next tab
        if (currentTrigger === lastTrigger) {
          this.switchTab(firstTrigger);
        } else {
          this.switchTab(triggers[currentIndex + 1]);
        }

        e.preventDefault();
      }
    }
  }]);

  return TabsCordion;
}();



/***/ }),
/* 500 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initMulticategoies;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);


var addValue = function addValue(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
};

var removeValue = function removeValue(arr, value) {
  var index = arr.indexOf(value);

  while (index !== -1) {
    arr.splice(index, 1);
    index = arr.indexOf(value);
  }
};

var getCategoryLength = function getCategoryLength(checkbox) {
  return checkbox.parentElement.querySelectorAll('input[type="checkbox"]').length;
};

var getSubcategories = function getSubcategories(checkbox) {
  return [].slice.call(checkbox.parentElement.lastElementChild.querySelectorAll('input[type="checkbox"]'));
};

var getParentCat = function getParentCat(checkbox) {
  var group = __WEBPACK_IMPORTED_MODULE_0__helpers__["g" /* findAncestor */](checkbox, 'checkbox-group');

  if (group !== null) {
    return group.querySelector('input[type="checkbox"]');
  }

  return group;
};

var getCheckedItems = function getCheckedItems(items) {
  var checkedItems = 1;
  items.forEach(function (item) {
    checkedItems = item.checked ? checkedItems + 1 : checkedItems;
  });
  return checkedItems;
};

var checkParent = function checkParent(checkbox, arr) {
  var parentCategory = getParentCat(checkbox);
  console.log(parentCategory);

  if (parentCategory === null) {
    return;
  }

  var categoryLength = getCategoryLength(parentCategory);
  var checkedItems = getCheckedItems(getSubcategories(parentCategory));
  console.log(parentCategory, checkedItems, categoryLength);
  parentCategory.checked = checkedItems === categoryLength;

  if (parentCategory.checked) {
    addValue(arr, parentCategory.value);
  } else {
    removeValue(arr, parentCategory.value);
  }

  checkParent(parentCategory.parentElement.parentElement, arr);
};

var handleCategories = function handleCategories(checkbox, arr) {
  if (checkbox.checked) {
    addValue(arr, checkbox.value);

    if (getSubcategories(checkbox).length) {
      getSubcategories(checkbox).forEach(function (subcategory) {
        subcategory.checked = true;
        addValue(arr, subcategory.value);
      });
    }
  } else {
    removeValue(arr, checkbox.value);

    if (getSubcategories(checkbox).length) {
      getSubcategories(checkbox).forEach(function (subcategory) {
        subcategory.checked = false;
        removeValue(arr, subcategory.value);
      });
    }
  }

  checkParent(checkbox, arr);
};

function initMulticategoies() {
  var output = document.querySelector('.js-get-categories');
  var input = [].slice.call(document.querySelectorAll('.js-set-categories'));

  if (output === null || input === null) {
    return;
  }

  var values = [];
  input.forEach(function (categorySet) {
    var checkboxes = [].slice.call(categorySet.querySelectorAll('input[type="checkbox"]'));
    checkboxes.forEach(function (checkbox) {
      checkbox.addEventListener('click', function () {
        handleCategories(checkbox, values);
        console.log(values);
        output.value = values.join(',');
      });
    });
  });
}

/***/ }),
/* 501 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initCarousels;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers__ = __webpack_require__(8);


function initCarousels() {
  var carousels = new __WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper___default.a('.js-swiper', {
    init: false,
    simulateTouch: false,
    watchOverflow: true,
    loop: false,
    autoplay: false,
    speed: 500,
    a11y: {
      enabled: false
    },
    pagination: {
      type: 'bullets',
      bulletElement: 'li',
      clickable: true,
      bulletClass: 'swiper-pagination__bullet',
      bulletActiveClass: '-is-active',
      renderBullet: function renderBullet(index, className) {
        return "\n                        <li class=\"".concat(className, "\" role=\"presentation\">\n                            <button class=\"swiper-pagination__bullet-btn\" role=\"tab\" aria-selected=\"false\">\n                                <span class=\"ghost\">").concat(index + 1, "</span>\n                            </button>\n                        </li>\n                        ");
      }
    }
  });

  var setCarouselWraps = function setCarouselWraps(carouselInstance) {
    var carouselContainer = carouselInstance.el;
    var carouselWrapper;

    for (var i = 0; i < carouselContainer.children.length; i++) {
      if (__WEBPACK_IMPORTED_MODULE_1__helpers__["m" /* hasClass */](carouselContainer.children[i], 'swiper-wrapper')) {
        carouselWrapper = carouselContainer.children[i];
      }
    }

    var carouselSlides = carouselWrapper.children;
    var carouselParentWrapper = carouselContainer.parentNode;
    var carouselArrows = carouselParentWrapper.querySelectorAll('button.-prev, button.-next');
    __WEBPACK_IMPORTED_MODULE_1__helpers__["a" /* addClass */](carouselContainer, 'swiper-container');

    for (var _i = 0; _i < carouselSlides.length; _i++) {
      __WEBPACK_IMPORTED_MODULE_1__helpers__["a" /* addClass */](carouselSlides[_i], 'swiper-slide');
    }

    for (var _i2 = 0; _i2 < carouselArrows.length; _i2++) {
      __WEBPACK_IMPORTED_MODULE_1__helpers__["a" /* addClass */](carouselArrows[_i2], 'js-swiper-control');
    }
  };

  var setControlsDisplay = function setControlsDisplay(carouselInstance, state) {
    var controls = carouselInstance.el.parentNode.querySelectorAll('.js-swiper-control');

    for (var i = 0; i < controls.length; i++) {
      var control = state ? __WEBPACK_IMPORTED_MODULE_1__helpers__["a" /* addClass */](controls[i], '-is-hidden') : __WEBPACK_IMPORTED_MODULE_1__helpers__["w" /* removeClass */](controls[i], '-is-hidden');
    }
  };

  var setControlsState = function setControlsState(carouselInstance) {
    var controls = carouselInstance.el.parentNode.querySelectorAll('.js-swiper-control');

    for (var i = 0; i < controls.length; i++) {
      var state = __WEBPACK_IMPORTED_MODULE_1__helpers__["m" /* hasClass */](controls[i], 'swiper-button-disabled');
      var control = state ? controls[i].setAttribute('disabled', true) : controls[i].removeAttribute('disabled');
    }
  };

  var setNavigation = function setNavigation(carouselInstance) {
    var instanceData = carouselInstance.el.dataset;
    var buttonNext;
    var buttonPrev;

    if (instanceData.outsideNavigation === 'true') {
      buttonNext = carouselInstance.el.parentNode.querySelector('button.-next');
      buttonPrev = carouselInstance.el.parentNode.querySelector('button.-prev');
    } else {
      buttonNext = carouselInstance.el.querySelector('button.-next');
      buttonPrev = carouselInstance.el.querySelector('button.-prev');
    }

    carouselInstance.params.navigation.nextEl = buttonNext;
    carouselInstance.params.navigation.prevEl = buttonPrev;
  };

  var setBulletsAccessibility = function setBulletsAccessibility(carouselInstance) {
    var pagination = carouselInstance.el.parentNode.querySelector('.swiper-pagination');
    var bullets = pagination.querySelectorAll('.swiper-pagination__bullet .swiper-pagination__bullet-btn');
    var activeBullet = pagination.querySelector('.swiper-pagination__bullet.-is-active .swiper-pagination__bullet-btn');

    if (bullets !== null) {
      for (var j = 0; j < bullets.length; j++) {
        bullets[j].setAttribute('aria-selected', false);
        bullets[j].setAttribute('tabindex', -1);
      }

      if (activeBullet !== null) {
        activeBullet.setAttribute('aria-selected', true);
        activeBullet.setAttribute('tabindex', 0);
      }
    }
  };

  var setBulletEvent = function setBulletEvent(bullet) {
    bullet.addEventListener('keydown', function (event) {
      var activeElement = event.target.parentNode;
      var firstElement = activeElement.parentNode.firstElementChild;
      var lastElement = activeElement.parentNode.lastElementChild;

      if (!event.ctrlKey && !event.shiftKey && event.keyCode !== 9) {
        if (event.keyCode === 37 || event.keyCode === 38) {
          if (activeElement === firstElement) {
            lastElement.click();
            setTimeout(function () {
              lastElement.querySelector('button').focus();
            }, 0);
          } else {
            activeElement.previousElementSibling.click();
            setTimeout(function () {
              activeElement.previousElementSibling.querySelector('button').focus();
            }, 0);
          }
        } else if (event.keyCode === 39 || event.keyCode === 40) {
          if (activeElement === lastElement) {
            firstElement.click();
            setTimeout(function () {
              firstElement.querySelector('button').focus();
            }, 0);
          } else {
            activeElement.nextElementSibling.click();
            setTimeout(function () {
              activeElement.nextElementSibling.querySelector('button').focus();
            }, 0);
          }
        } else if (event.keyCode === 36) {
          firstElement.click();
          setTimeout(function () {
            firstElement.querySelector('button').focus();
          }, 0);
        } else if (event.keyCode === 35) {
          lastElement.click();
          setTimeout(function () {
            lastElement.querySelector('button').focus();
          }, 0);
        }

        event.preventDefault();
      }
    });
  };

  var setBreakpoints = function setBreakpoints(carouselInstance) {
    var instanceData = carouselInstance.el.dataset;
    var breakpoints = {};
    var itemsPerView;
    var itemsToSlide;

    for (var data in instanceData) {
      if (data === 'autoplay') {
        if (instanceData[data] === 'false') {
          carouselInstance.params.autoplay = false;
        } else {
          carouselInstance.params.autoplay.enabled = true;
          carouselInstance.params.autoplay.delay = isNaN(Number(instanceData[data])) ? 0 : Number(instanceData[data]);
        }
      }

      if (data === 'loop') {
        carouselInstance.params.loop = instanceData[data] !== 'false';
      }

      if (data === 'items') {
        itemsPerView = instanceData[data].split(', ');
      }

      if (data === 'slideByOne') {
        itemsToSlide = instanceData[data] === true;
      }

      if (data === 'pagination') {
        (function () {
          var pagination = void 0;

          if (instanceData[data] === 'outside') {
            pagination = carouselInstance.el.parentNode.querySelector('.swiper-pagination');
          } else {
            pagination = carouselInstance.el.querySelector('.swiper-pagination');
          }

          if (pagination !== null) {
            carouselInstance.params.pagination.el = pagination;
            carouselInstance.pagination.render();
            setTimeout(function () {
              var bullets = [].slice.call(pagination.querySelectorAll('.swiper-pagination__bullet'));
              setBulletsAccessibility(carouselInstance);
              bullets.forEach(function (bullet) {
                return setBulletEvent(bullet);
              });
            }, 100);
          }
        })();
      }

      if (itemsPerView === undefined) {
        breakpoints['1980'] = {
          slidesPerView: 1,
          slidesPerGroup: 1
        };
      } else {
        switch (itemsPerView.length) {
          case 1:
            breakpoints['1980'] = {
              slidesPerView: itemsPerView[0],
              slidesPerGroup: itemsToSlide === undefined ? itemsPerView[0] : 1
            };
            break;

          case 2:
            breakpoints['1279'] = {
              slidesPerView: itemsPerView[1],
              slidesPerGroup: itemsToSlide === undefined ? itemsPerView[1] : 1
            };
            breakpoints['1980'] = {
              slidesPerView: itemsPerView[0],
              slidesPerGroup: itemsToSlide === undefined ? itemsPerView[0] : 1
            };
            break;

          case 3:
            breakpoints['767'] = {
              slidesPerView: itemsPerView[2],
              slidesPerGroup: itemsToSlide === undefined ? itemsPerView[2] : 1
            };
            breakpoints['1279'] = {
              slidesPerView: itemsPerView[1],
              slidesPerGroup: itemsToSlide === undefined ? itemsPerView[1] : 1
            };
            breakpoints['1980'] = {
              slidesPerView: itemsPerView[0],
              slidesPerGroup: itemsToSlide === undefined ? itemsPerView[0] : 1
            };
            break;

          default:
            breakpoints['1980'] = {
              slidesPerView: 1,
              slidesPerGroup: 1
            };
            break;
        }
      }
    }

    return breakpoints;
  };

  var setSlidesAccessibility = function setSlidesAccessibility(carouselInstance, activeIndex) {
    var slides = carouselInstance.el.querySelectorAll('.swiper-slide');
    var slidesToShow = carouselInstance.params.breakpoints;
    var screenWidth = window.innerWidth;
    var loopMode = carouselInstance.params.loop;
    var slideActive = carouselInstance.el.querySelector(".swiper-slide-active[data-swiper-slide-index=\"".concat(activeIndex, "\"]"));
    var stateCounter = true;

    if (slideActive === null && loopMode) {
      slideActive = carouselInstance.el.querySelector('.swiper-slide-active[data-swiper-slide-index="0"]');
    }

    for (var view in slidesToShow) {
      if (screenWidth <= Number(view)) {
        if (slides.length > slidesToShow[view].slidesPerView && stateCounter) {
          stateCounter = false; // Add aria-hidden to all slides

          for (var i = 0; i < slides.length; i++) {
            slides[i].setAttribute('aria-hidden', true);
            __WEBPACK_IMPORTED_MODULE_1__helpers__["B" /* setTabindex */](slides[i], -1);
          }

          var itemsMustShow = slidesToShow[view].slidesPerView;

          for (var _i3 = 0; _i3 < itemsMustShow; _i3++) {
            if (loopMode) {
              var slidesArray = [].slice.call(slides);
              var realIndex = slidesArray.indexOf(slideActive);
              slideActive.setAttribute('aria-hidden', false);

              slidesArray[realIndex + _i3].setAttribute('aria-hidden', false);

              __WEBPACK_IMPORTED_MODULE_1__helpers__["B" /* setTabindex */](slideActive, 0);
              __WEBPACK_IMPORTED_MODULE_1__helpers__["B" /* setTabindex */](slidesArray[realIndex + _i3], 0);
            } else {
              slides[activeIndex].setAttribute('aria-hidden', false);

              slides[activeIndex + _i3].setAttribute('aria-hidden', false);

              __WEBPACK_IMPORTED_MODULE_1__helpers__["B" /* setTabindex */](slides[activeIndex], 0);
              __WEBPACK_IMPORTED_MODULE_1__helpers__["B" /* setTabindex */](slides[activeIndex + _i3], 0);
            }
          }
        }
      }
    }
  };

  var manageAutoplayState = function manageAutoplayState(carouselInstance, state) {
    var actionsContainer = carouselInstance.el.parentNode.querySelector('.swiper-actions');
    var play = actionsContainer.querySelector('.js-swiper-play');
    var pause = actionsContainer.querySelector('.js-swiper-pause'); // reset state

    play.setAttribute('aria-hidden', true);
    pause.setAttribute('aria-hidden', true);
    __WEBPACK_IMPORTED_MODULE_1__helpers__["w" /* removeClass */](pause, '-is-active');
    __WEBPACK_IMPORTED_MODULE_1__helpers__["w" /* removeClass */](play, '-is-active');

    if (state) {
      pause.setAttribute('aria-hidden', false);
      __WEBPACK_IMPORTED_MODULE_1__helpers__["a" /* addClass */](pause, '-is-active'); // pause.focus();
    } else {
      play.setAttribute('aria-hidden', false);
      __WEBPACK_IMPORTED_MODULE_1__helpers__["a" /* addClass */](play, '-is-active'); // play.focus();
    }
  };

  var videoState = function videoState(video, state) {
    if (state) {
      video.play();
    } else {
      video.pause();
    }
  };

  var videoInSlider = function videoInSlider(carouselInstance) {
    var videoItemWrap = carouselInstance.el.querySelectorAll('.-has-video');
    var videoItem = carouselInstance.el.querySelectorAll('.-has-video video');

    if (videoItemWrap === null) {
      return;
    }

    for (var i = 0; i < videoItemWrap.length; i++) {
      if (__WEBPACK_IMPORTED_MODULE_1__helpers__["m" /* hasClass */](videoItemWrap[i], 'swiper-slide-active')) {
        videoState(videoItemWrap[i].querySelector('video'), false);
        carouselInstance.autoplay.stop();
      }
    }

    for (var _i4 = 0; _i4 < videoItem.length; _i4++) {
      videoItem[_i4].addEventListener('ended', function () {
        carouselInstance.autoplay.start();
      });
    }
  };

  var setControlsPosition = function setControlsPosition(carouselInstance) {
    var controls = carouselInstance.el.parentNode.querySelectorAll('.projects__focus-control');
    var block = carouselInstance.el.querySelector('.swiper-slide-active .projects__focus-info');

    if (controls === null || block === null) {
      return;
    }

    var blockHeight = block.offsetHeight;
    var offset = blockHeight / 2;

    for (var i = 0; i < controls.length; i++) {
      controls[i].removeAttribute('style');

      if (window.responsive === 'desktop') {
        controls[i].style.top = "".concat(offset - 40, "px");
      } else {
        controls[i].style.bottom = "".concat(offset - 40, "px");
      }
    }
  };

  var checkCarouselBeforeInit = function checkCarouselBeforeInit(carouselInstance, breakpoints) {
    var screenWidth = window.innerWidth;
    var instanceSlides = carouselInstance.el.querySelectorAll('.swiper-slide').length;
    setControlsDisplay(carouselInstance, true);

    if (!__WEBPACK_IMPORTED_MODULE_1__helpers__["m" /* hasClass */](carouselInstance.el, 'swiper-container-horizontal')) {
      carouselInstance.init();
    }

    for (var item in breakpoints) {
      if (screenWidth <= Number(item)) {
        if (instanceSlides > breakpoints[item].slidesPerView) {
          setControlsDisplay(carouselInstance, false);
          setControlsState(carouselInstance);
        }
      }
    }
  }; // Init all carousel instances


  [].concat(carousels || []).filter(function (carousel) {
    return !!carousel.el;
  }).forEach(function (carousel) {
    carousel.params.breakpoints = setBreakpoints(carousel);
    setNavigation(carousel);
    setCarouselWraps(carousel);
    carousel.on('init', function () {
      setSlidesAccessibility(carousel, carousel.realIndex);
      setControlsState(carousel);
      videoInSlider(carousel);
      setControlsPosition(carousel);
    });
    checkCarouselBeforeInit(carousel, setBreakpoints(carousel));
    window.addEventListener('resize', function () {
      setSlidesAccessibility(carousel, carousel.realIndex);
      checkCarouselBeforeInit(carousel, setBreakpoints(carousel));
      setControlsPosition(carousel);
    });
  });
  var carouselInstances = document.querySelectorAll('.js-swiper');

  var _loop = function _loop(i) {
    var instance = carouselInstances[i].swiper;
    var play = instance.el.parentNode.querySelector('.js-swiper-play');
    var pause = instance.el.parentNode.querySelector('.js-swiper-pause');
    var autoplayState = instance.autoplay.running;
    instance.on('slideChange', function () {
      setControlsState(instance);
    });
    instance.on('slideChangeTransitionStart', function () {
      videoInSlider(instance);
      setControlsPosition(instance);
    });
    instance.on('slideChangeTransitionEnd', function () {
      setSlidesAccessibility(instance, instance.realIndex);

      if (pause) {
        if (!instance.autoplay.running && __WEBPACK_IMPORTED_MODULE_1__helpers__["m" /* hasClass */](pause, '-is-active')) {
          instance.autoplay.start();
        }
      }
    });

    if (play !== null && pause !== null) {
      manageAutoplayState(instance, autoplayState);
      play.addEventListener('click', function () {
        instance.autoplay.start();
        autoplayState = instance.autoplay.running;
        manageAutoplayState(instance, autoplayState);
      });
      pause.addEventListener('click', function () {
        instance.autoplay.stop();
        autoplayState = instance.autoplay.running;
        manageAutoplayState(instance, autoplayState);
      });
    }
  };

  for (var i = 0; i < carouselInstances.length; i++) {
    _loop(i);
  }
}

/***/ }),
/* 502 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initMultiselect;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_components_dropdown__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__js_helpers__ = __webpack_require__(8);


/**
 *
 * @author Sereja Smerechevskiy - OSI
 *
 * Data options:
 *
 * data-show-count - show count of selected categories in field
 * data-prefix - manage field prefix if data-show-count - on
 * data-suffix - manage field suffix if data-show-count - on
 * data-placeholder - manage field placeholder (if you don't check any category and default state)
 * data-relations - (required field) - set relation between multiselect and hidden input field, shoud be equal to hidden field id
 *
 */

var getCheckboxes = function getCheckboxes(element) {
  return [].slice.call(element.parentElement.querySelectorAll("input[type=\"checkbox\"]:not([id=".concat(element.id, "])")));
};

var getCategoriesValue = function getCategoriesValue(multiselect) {
  var checkedItems = [].slice.call(multiselect.querySelectorAll('input[type="checkbox"]:checked'));
  return checkedItems.map(function (checkbox) {
    return checkbox.value;
  }).join(',');
};

var getCategoriesNames = function getCategoriesNames(multiselect) {
  var checkedItems = [].slice.call(multiselect.querySelectorAll('input[type="checkbox"]:checked + label'));
  var placeholder = multiselect.getAttribute('data-placeholder') || 'Toutes les categories';
  var prefix = multiselect.getAttribute('data-prefix') || 'selected';
  var suffix = multiselect.getAttribute('data-suffix') || 'categories';
  var showCount = multiselect.getAttribute('data-show-count') || false;
  var string = placeholder;

  if (checkedItems.length) {
    if (showCount && checkedItems.length === 1) {
      string = checkedItems[0].innerHTML;
    } else if (showCount && checkedItems.length > 1) {
      string = "".concat(prefix, " ").concat(checkedItems.length, " ").concat(suffix);
    } else {
      string = checkedItems.map(function (label) {
        return label.innerHTML;
      }).join(', ');
    }
  }

  return string;
};

var getParentCategories = function getParentCategories(checkbox) {
  var categoriesArray = [];
  var parentCategory = checkbox.parentElement.parentElement;

  while (!__WEBPACK_IMPORTED_MODULE_1__js_helpers__["m" /* hasClass */](parentCategory, 'checkbox')) {
    categoriesArray.push(parentCategory.querySelector('input[type="checkbox"]'));
    parentCategory = parentCategory.parentElement;
  }

  return categoriesArray;
};

var getState = function getState(checkbox) {
  var items = getCheckboxes(checkbox);
  var itemsCount = items.length;
  var checkedItems = 0;
  var state = 'unchecked';

  if (itemsCount > 0) {
    items.forEach(function (item) {
      checkedItems = item.checked ? checkedItems + 1 : checkedItems;
    });

    if (checkedItems === itemsCount) {
      state = 'checked';
    } else if (checkedItems > 0 && checkedItems < itemsCount) {
      state = 'indeterminate';
    }
  } else {
    if (checkbox.checked) {
      state = 'checked';
    }
  }

  return state;
};

var hasSubcategory = function hasSubcategory(checkbox) {
  return getCheckboxes(checkbox).length > 0;
};

var setAttributesByState = function setAttributesByState(checkbox, state) {
  switch (state) {
    case 'checked':
      checkbox.checked = true;
      checkbox.indeterminate = false;
      checkbox.setAttribute('aria-checked', true);
      break;

    case 'indeterminate':
      checkbox.checked = false;
      checkbox.indeterminate = true;
      checkbox.setAttribute('aria-checked', 'mixed');
      break;

    default:
      checkbox.indeterminate = false;
      checkbox.checked = false;
      checkbox.setAttribute('aria-checked', false);
      break;
  }
};

var manageCategoryBranch = function manageCategoryBranch(checkbox) {
  var parents = getParentCategories(checkbox);
  var children = hasSubcategory(checkbox) ? getCheckboxes(checkbox) : null;
  checkbox.setAttribute('aria-checked', checkbox.checked);

  if (children !== null) {
    children.forEach(function (item) {
      item.checked = checkbox.checked;
    });
  }

  if (parents.length) {
    parents.forEach(function (parent) {
      setAttributesByState(parent, getState(parent));
    });
  }
};

var handleMultiselectControls = function handleMultiselectControls(multiselect) {
  var multiselectToggle = multiselect.querySelector('.multiselect__toggle'); // Relation field

  var dataId = multiselect.getAttribute('data-relations');
  var multiselectInput = document.getElementById(dataId);

  if (dataId === undefined) {
    console.error('data-relations attribute missed, please add it');
    return;
  }

  if (multiselectInput === null) {
    console.error('relation input missed, please add it');
    return;
  }

  multiselectInput.value = getCategoriesValue(multiselect);
  multiselectToggle.innerHTML = getCategoriesNames(multiselect);
};

function handleMultiselectCategories(checkboxes, multiselect) {
  var checkboxesArray = [].slice.call(checkboxes);
  var checkedArray = checkboxesArray.filter(function (checkbox) {
    return checkbox.checked;
  });
  handleMultiselectControls(multiselect);
  checkedArray.forEach(function (checkbox) {
    return manageCategoryBranch(checkbox);
  });
  checkboxesArray.forEach(function (checkbox) {
    checkbox.addEventListener('change', function () {
      manageCategoryBranch(checkbox);
      handleMultiselectControls(multiselect);
    });
  });
}

function handleMultiselect() {
  var multiselect = document.querySelectorAll('.multiselect');

  if (multiselect !== null) {
    for (var i = 0; i < multiselect.length; i++) {
      var multiselectEl = multiselect[i];
      var checkboxes = multiselectEl.querySelectorAll('input[type="checkbox"]');
      handleMultiselectCategories(checkboxes, multiselectEl);
    }
  }
}

function initMultiselect() {
  // Multiselect
  var multiselect = document.querySelectorAll('.multiselect');

  if (multiselect !== null) {
    var multiselectObj = new __WEBPACK_IMPORTED_MODULE_0__js_components_dropdown__["a" /* default */]('.multiselect', {
      wrapperClass: 'multiselect',
      dropdownClass: 'multiselect__dropdown',
      btnClass: 'multiselect__toggle',
      onInit: handleMultiselect
    });
  }
}

/***/ }),
/* 503 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formsHandler;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);


var setDate = function setDate(datepicker) {
  if (datepicker.value.length > 0) {
    var dateArray = datepicker.value.split('-');
    var day = document.getElementById('date-day');
    var month = document.getElementById('date-month');
    var year = document.getElementById('date-year');
    day.value = dateArray[2];
    month.value = dateArray[1];
    year.value = dateArray[0];
  }
};

var setSelectYear = function setSelectYear(dateSelect) {
  var select = dateSelect.parentNode.querySelector('select');

  if (!select) {
    return;
  }

  var selectedOption = select.querySelector("option[value=\"".concat(select.value, "\"]"));

  if (!selectedOption) {
    return;
  }

  var group = selectedOption.parentNode;

  if (group && group.nodeName === 'OPTGROUP' && group.hasAttribute('label')) {
    dateSelect.setAttribute('value', group.getAttribute('label'));
  }
};

var removeNameAttribute = function removeNameAttribute(name, form) {
  var field = form.querySelector("[name=\"".concat(name, "\"]"));

  if (field !== null) {
    if (field.value === '0' || field.value === '') {
      field.removeAttribute('name');
    }
  }
};

var checkControllerNameAttribute = function checkControllerNameAttribute(name, form) {
  var relatedFields = [];

  if (name === 'tx_news_pi1[search][subject]') {
    relatedFields = relatedFields.concat(['tx_news_pi1[__referrer][@request]', 'tx_news_pi1[__referrer][@extension]', 'tx_news_pi1[__referrer][@vendor]', 'tx_news_pi1[__referrer][@controller]', 'tx_news_pi1[__referrer][@action]', 'tx_news_pi1[__referrer][arguments]', 'tx_news_pi1[__trustedProperties]']);
  }

  if (name === 'tx_news_pi1[overwriteDemand][datecomplete]') {
    relatedFields = relatedFields.concat(['tx_news_pi1[overwriteDemand][startFromThisDate]']);
  }

  if (name === 'tx_stratismap_location[keyword]') {
    relatedFields = relatedFields.concat(['tx_stratismap_location[__referrer][@extension]', 'tx_stratismap_location[__referrer][@vendor]', 'tx_stratismap_location[__referrer][@controller]', 'tx_stratismap_location[__referrer][@action]', 'tx_stratismap_location[__referrer][arguments]', 'tx_stratismap_location[__referrer][@request]', 'tx_stratismap_location[__trustedProperties]']);
  }

  removeNameAttribute(name, form);
  relatedFields.forEach(function (relatedField) {
    removeNameAttribute(relatedField, form);
  });
};

function formsHandler() {
  var forms = [].slice.call(document.querySelectorAll('form'));
  /**
   * TODO : Replace jquery code on vanillajs code
   */

  $('button[type="reset"]').click(function () {
    var multiselect = $(this).parents('form').find('.multiselect');
    $(this).parents('form').find(':radio, :checkbox').prop('indeterminate', false);
    $(this).parents('form').find(':radio, :checkbox').prop('checked', false);
    $(this).parents('form').find('textarea:enabled, input:enabled:not([readonly]), select:enabled').val('');

    if (multiselect.length > 0) {
      var placeholder = multiselect.attr('data-placeholder');
      multiselect.find('.multiselect__toggle').text(placeholder);
    }

    return false;
  });

  if (forms.length) {
    forms.forEach(function (form) {
      form.addEventListener('submit', function (e) {
        var datepicker = document.getElementById('input-date-hidden');

        if (datepicker !== null) {
          setDate(datepicker);
        }

        var dateSelect = document.getElementById('tx_news_year');

        if (dateSelect !== null) {
          setSelectYear(dateSelect);
        }

        var fieldsNameToRemove = ['tx_news_pi1[overwriteDemand][period]', 'tx_news_pi1[overwriteDemand][related]', 'tx_news_pi1[overwriteDemand][categories]', 'tx_news_pi1[overwriteDemand][day]', 'tx_news_pi1[overwriteDemand][month]', 'tx_news_pi1[overwriteDemand][year]', 'tx_news_pi1[overwriteDemand][keywords]', 'tx_news_pi1[overwriteDemand][datecomplete]', 'tx_news_pi1[search][subject]', 'tx_news_pi1[overwriteDemand][tags]', 'tx_news_pi1[overwriteDemand][relatedLinks]', 'tx_news_pi1[overwriteDemand][related]', 'tx_news_pi1[overwriteDemand][relatedLocations]', 'tx_news_pi1[overwriteDemand][relatedAreas]', 'tx_simplepoll_polllisting[category]', 'tx_simplepoll_polllisting[status]', 'tx_stratismap_location[search][keywords]', 'tx_stratismap_location[search][categories][]'];
        fieldsNameToRemove.forEach(function (field) {
          checkControllerNameAttribute(field, form);
        });
      });
    });
  }
}

/***/ }),
/* 504 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = buttonsStateToggle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);

function buttonsStateToggle() {
  var iconToggleElements = [].slice.call(document.querySelectorAll('[data-toggle-icon]'));
  var textToggleElements = [].slice.call(document.querySelectorAll('[data-toggle-text]'));

  if (iconToggleElements !== null) {
    iconToggleElements.forEach(function (toggleElem) {
      var defaultLoadIcon = toggleElem.className;
      var stateClass = toggleElem.getAttribute('data-toggle-class');

      if (stateClass && __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggleElem, stateClass)) {
        toggleElem.innerText = toggleElem.getAttribute('data-toggle-icon');
        toggleElem.setAttribute('data-toggle-icon', defaultLoadIcon);
      }

      toggleElem.addEventListener('click', function () {
        var defaultIcon = toggleElem.className;
        toggleElem.className = toggleElem.getAttribute('data-toggle-icon');
        toggleElem.setAttribute('data-toggle-icon', defaultIcon);
      });
    });
  }

  if (textToggleElements !== null) {
    textToggleElements.forEach(function (toggleElem) {
      var defaultLoadText = toggleElem.innerText;
      var stateClass = toggleElem.getAttribute('data-toggle-class');

      if (stateClass && __WEBPACK_IMPORTED_MODULE_0__helpers__["m" /* hasClass */](toggleElem, stateClass)) {
        toggleElem.innerText = toggleElem.getAttribute('data-toggle-text');
        toggleElem.setAttribute('data-toggle-text', defaultLoadText);
      }

      toggleElem.addEventListener('click', function () {
        var defaultText = toggleElem.innerText;
        toggleElem.innerText = toggleElem.getAttribute('data-toggle-text');
        toggleElem.setAttribute('data-toggle-text', defaultText);
      });
    });
  }
}

/***/ }),
/* 505 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = projectVideo;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__js_helpers__ = __webpack_require__(8);

function projectVideo() {
  var videoWrap = document.querySelector('.projects__focus-video');

  if (videoWrap === null) {
    return;
  }

  var video = document.querySelector('.projects__focus-video video');
  var actionsContainer = document.querySelector('.projects__focus-actions');
  var play = actionsContainer.querySelector('.projects__focus-action.-play');
  var pause = actionsContainer.querySelector('.projects__focus-action.-pause'); // video.play();

  video.addEventListener('ended', function () {
    video.play();
  });

  var managePlayPause = function managePlayPause(state) {
    // reset state
    play.setAttribute('aria-hidden', true);
    pause.setAttribute('aria-hidden', true);
    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](pause, '-is-active');
    __WEBPACK_IMPORTED_MODULE_0__js_helpers__["w" /* removeClass */](play, '-is-active');

    if (state) {
      pause.setAttribute('aria-hidden', false);
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](pause, '-is-active');
    } else {
      play.setAttribute('aria-hidden', false);
      __WEBPACK_IMPORTED_MODULE_0__js_helpers__["a" /* addClass */](play, '-is-active');
    }
  };

  managePlayPause(true);
  play.addEventListener('click', function () {
    video.play();
    managePlayPause(false);
  });
  pause.addEventListener('click', function () {
    video.pause();
    managePlayPause(true);
  });
}

/***/ }),
/* 506 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Geocode; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_whatwg_fetch__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers__ = __webpack_require__(8);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



/**
 *  Get you location address
 */

var Geocode =
/*#__PURE__*/
function () {
  /**
   * Create geocode instance
   *
   * @param {Node} selector - selector for geocode button
   * @param {Object} options - geocode options
   */
  function Geocode() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-geocode]';
    var options = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, Geocode);

    this.selector = selector;
    this.input = null;
    this.geolocationSettings = {
      maximumAge: 50000,
      timeout: 20000,
      enableHighAccuracy: true
    };
    this.options = {
      useOSMGeocoder: true,
      osmZoom: 18,
      useGoogleGeocoder: false,
      googleKey: window.location.origin.indexOf('stratis.fr') !== -1 || window.location.origin.indexOf('localhost') !== -1 ? 'AIzaSyC6c3QpD7OJ-cREM-y8rDDzKCSQXbk5PS4' : null
    };

    if (options instanceof Object) {
      this.options = __WEBPACK_IMPORTED_MODULE_1__helpers__["f" /* extendDefaults */](this.options, options);
    }

    this.checkBeforeInit();
  }

  _createClass(Geocode, [{
    key: "checkBeforeInit",
    value: function checkBeforeInit() {
      if (typeof this.selector === 'string') {
        var elements = [].slice.call(document.querySelectorAll(this.selector));
        elements.forEach(function (element) {
          var instance = new Geocode(element);
        });
      } else if (this.selector instanceof Element) {
        this.init();
      } else {
        throw new Error("".concat(this.selector, " should be a DOM Object or string"));
      }
    }
  }, {
    key: "init",
    value: function init() {
      this.input = this.selector.parentNode.querySelector('[data-geocode-field]');
      this.geocodeButtonHandler();
    }
  }, {
    key: "tryGeolocation",
    value: function tryGeolocation() {
      // Use browser geolocation
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(this.handleSuccess.bind(this), this.handleError.bind(this), this.geolocationSettings);
      } else {
        alert('Votre navigateur ne prend pas en charge la géolocalisation. Veuillez le mettre à jour ou utiliser un navigateur plus récent.');
      }
    }
  }, {
    key: "getGeolocationAddress",
    value: function getGeolocationAddress(position) {
      var _this = this;

      // Use google Geocoder
      if (this.options.useGoogleGeocoder) {
        if (this.options.googleKey === null) {
          throw new Error('Your google API key is invalid');
        } // Get data from google api


        fetch("https://maps.googleapis.com/maps/api/geocode/json?latlng=".concat(position.lat, ",").concat(position.lng, "&key=").concat(this.options.googleKey), {
          method: 'GET'
        }).then(function (response) {
          if (response.status >= 200 && response.status < 300) {
            // if status OK return response text
            return response.text();
          } // or throw error


          throw new Error(response.statusText);
        }).then(function (response) {
          // conver text from response to JSON
          var responseData = JSON.parse(response);

          if (responseData.status !== 'OK' || !responseData.results.length) {
            // if we have troubles with api KEY (example QUERY_LIMITS) throw error
            throw new Error(responseData.error_message);
          } // or return location information


          return responseData.results[0];
        }).then(function (results) {
          if (_this.input === null) {
            // throw error if we haven't field to ouput information
            throw new Error('Can\'t find input with [data-geocode-field] parameter, it shoud be in one wrapper with data-geocode button');
          } // paste address to input field


          _this.input.value = results.formatted_address;
        });
      } // Use OSM geocoder


      if (this.options.useOSMGeocoder) {
        // get data from OSM api
        fetch("https://nominatim.openstreetmap.org/reverse?format=json&lat=".concat(position.lat, "&lon=").concat(position.lng, "&zoom=").concat(this.options.osmZoom, "&addressdetails=1"), {
          method: 'GET'
        }).then(function (response) {
          if (response.status >= 200 && response.status < 300) {
            // If status OK return JSON
            return response.json();
          } // Or throw error


          throw new Error(response.statusText || 'Invalid query URL');
        }).then(function (results) {
          if (_this.input === null) {
            // throw error if we haven't field to ouput information
            throw new Error('Can\'t find input with [data-geocode-field] parameter, it shoud be in one wrapper with data-geocode button');
          } // paste address to input field


          _this.input.value = results.display_name;
        });
      }
    }
  }, {
    key: "handleSuccess",
    value: function handleSuccess(position) {
      this.getGeolocationAddress({
        lat: position.coords.latitude,
        lng: position.coords.longitude
      });
    }
  }, {
    key: "handleError",
    value: function handleError(error) {
      switch (error.code) {
        case error.TIMEOUT:
          alert('Votre géolocalisation prend trop de temps. Veuillez recommencer ultérieurement.');
          break;

        case error.POSITION_UNAVAILABLE:
          alert('La géolocalisation n\'est pas disponible sur votre navigateur. Rechargez la page et autorisez la géolocalisation lorsqu\'elle vous sera demandées.');
          break;

        default:
          console.warn("ERROR(".concat(error.code, "): ").concat(error.message));
      }
    }
  }, {
    key: "geocodeButtonHandler",
    value: function geocodeButtonHandler() {
      // Bind click on the button
      this.selector.addEventListener('click', this.tryGeolocation.bind(this));
    }
  }]);

  return Geocode;
}();



/***/ }),
/* 507 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TarteaucitronCookies; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 *  Class representing 'tarteaucitron' cookies manager
 */

var TarteaucitronCookies =
/*#__PURE__*/
function () {
  /**
   * Create options for 'tarteaucitron' cookies manager
   * @param options - object with plugin settings https://opt-out.ferank.eu/en/install/
   */
  function TarteaucitronCookies(options) {
    _classCallCheck(this, TarteaucitronCookies);

    this.language = options.language || 'fr';
    this.customText = options.customText || null;
    this.options = {
      hashtag: '#tarteaucitron',

      /* Open the panel with this hashtag */
      highPrivacy: true,

      /* Disable auto consent */
      orientation: 'bottom',

      /* Banner position (top - bottom) */
      adblocker: false,

      /* Show a Warning if an adblocker is detected */
      showAlertSmall: false,

      /* Show the small banner on bottom right */
      cookieslist: false,

      /* Show the cookie list */
      removeCredit: true,

      /* Remove credit link */
      useExternalCss: true
      /* If false, the tarteaucitron.css file will be loaded */
      // cookieDomain: '.example.com' /* Shared cookie for subdomain website */

    };

    if (options instanceof Object) {
      this.options = __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](this.options, options.config);
    }

    this.init();
  }
  /**
   * initialise 'tarteaucitron' cookies manager
   */


  _createClass(TarteaucitronCookies, [{
    key: "init",
    value: function init() {
      if (tarteaucitronForceLanguage !== undefined) {
        tarteaucitronForceLanguage = this.language;
      }

      if (tarteaucitronCustomText !== undefined && this.customText !== null) {
        tarteaucitronCustomText = this.customText;
      }

      if (tarteaucitron) {
        tarteaucitron.init(this.options);
      }
    }
    /**
     * Add services to cookies list
     * @param services - {String} services list
     */

  }, {
    key: "addServices",
    value: function addServices(services) {
      var servicesArray = services.split(',');
      servicesArray.forEach(function (service) {
        (tarteaucitron.job = tarteaucitron.job || []).push(service.trim());
      });
    }
  }]);

  return TarteaucitronCookies;
}();



/***/ }),
/* 508 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchContent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helpers__ = __webpack_require__(8);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var SearchContent =
/*#__PURE__*/
function () {
  function SearchContent(selector) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SearchContent);

    this.selector = selector;
    this.config = {
      search: null,
      searchButton: null,
      item: null
    };

    if (config instanceof Object) {
      this.config = __WEBPACK_IMPORTED_MODULE_0__helpers__["f" /* extendDefaults */](this.config, config);
    }

    if (this.config.search && this.config.searchButton && this.config.item) {
      this.button = document.querySelector(this.config.searchButton);
      this.items = document.querySelectorAll(this.config.item);
      this.checkBeforeInit();
    } else {
      console.log('Not all config are filled in this object');
    }
  }

  _createClass(SearchContent, [{
    key: "checkBeforeInit",
    value: function checkBeforeInit() {
      if (typeof this.selector !== 'string') {
        return this.selector === null ? false : this.init();
      }

      if (typeof this.selector === 'string') {
        var els = document.querySelectorAll(this.selector);

        if (els === null) {
          return;
        }

        for (var i = 0; i < els.length; i++) {
          var el = new SearchContent(els[i], this.config);
        }
      }
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;

      var fields = [];
      this.button.addEventListener('click', function (event) {
        event.preventDefault();
        var count = 0; // Check number of fields

        for (var i = 0; i < _this.config.search.length; i++) {
          var field = document.querySelector(_this.config.search[i]);
          fields[i] = field;
        }

        for (var _i = 0; _i < _this.items.length; _i++) {
          // Array with terms
          var itemsTermes = Array.from(_this.items[_i].querySelectorAll('.js-terme'), function (itemsTerme) {
            return itemsTerme.textContent.toUpperCase();
          }); // Dual search

          if (fields[0].value.length > 0 && fields[1].value.length > 0) {
            if (typeof itemsTermes[0] !== 'undefined' && itemsTermes[0].indexOf(fields[0].value.toUpperCase()) >= 0 && (typeof itemsTermes[1] !== 'undefined' && itemsTermes[1].indexOf(fields[1].value.toUpperCase()) >= 0 || typeof itemsTermes[2] !== 'undefined' && itemsTermes[2].indexOf(fields[1].value.toUpperCase()) >= 0 || typeof itemsTermes[3] !== 'undefined' && itemsTermes[3].indexOf(fields[1].value.toUpperCase()) >= 0 || // Default option on the select
            fields[1].value === '0')) {
              _this.showElement(_this.items[_i]);

              count += 1;
            } else {
              _this.hideElement(_this.items[_i]);
            }
          } else if (fields[0].value.length === 0 && fields[1].value.length > 0) {
            // Search on the second field
            if (typeof itemsTermes[1] !== 'undefined' && itemsTermes[1].indexOf(fields[1].value.toUpperCase()) >= 0 || typeof itemsTermes[2] !== 'undefined' && itemsTermes[2].indexOf(fields[1].value.toUpperCase()) >= 0 || typeof itemsTermes[3] !== 'undefined' && itemsTermes[3].indexOf(fields[1].value.toUpperCase()) >= 0 || // Default option on the select
            fields[1].value === '0') {
              _this.showElement(_this.items[_i]);

              count += 1;
            } else {
              _this.hideElement(_this.items[_i]);
            }
          } else if (fields[0].value.length > 0 && fields[1].value.length === 0) {
            // Search on the first field
            if (typeof itemsTermes[0] !== 'undefined' && itemsTermes[0].indexOf(fields[0].value.toUpperCase()) >= 0) {
              _this.showElement(_this.items[_i]);

              count += 1;
            } else {
              _this.hideElement(_this.items[_i]);
            }
          } else if (fields[0].value.length === 0 && fields[1].value.length === 0) {
            // empty
            _this.showElement(_this.items[_i]);

            count += 1;
          }
        }

        _this.updateListResults(count);
      });
      this.initlistResults();
    }
  }, {
    key: "hideElement",
    value: function hideElement(item) {
      item.classList.add('-hide');
    }
  }, {
    key: "showElement",
    value: function showElement(item) {
      item.classList.remove('-hide');
    }
  }, {
    key: "results",
    value: function results(count) {
      var plural = '';

      if (count > 1) {
        plural = 's';
      }

      if (count === 0) {
        return "".concat(l10n.noResult);
      }

      return "".concat(l10n.displaying, " ").concat(count, " ").concat(l10n.result).concat(plural, " ").concat(l10n.of, " ").concat(this.items.length);
    }
  }, {
    key: "initlistResults",
    value: function initlistResults() {
      var noResultPTemp = this.selector.querySelector('.js-number-articles');
      var count = this.items.length;

      if (!noResultPTemp) {
        var list = this.selector;
        var listParent = list.parentNode;
        var noResultP = document.createElement('p');
        addClass(noResultP, ['js-number-articles', 'number-articles']);
        noResultP.setAttribute('aria-live', 'polite');
        listParent.insertBefore(noResultP, list);
        document.querySelector('.js-number-articles').innerHTML = this.results(count);
      }
    }
  }, {
    key: "updateListResults",
    value: function updateListResults(count) {
      document.querySelector('.js-number-articles').innerHTML = this.results(count);
      this.noResults();
    }
  }, {
    key: "noResults",
    value: function noResults() {
      var titles = this.selector.querySelectorAll('.contact .title');

      for (var i = 0; i < titles.length; i++) {
        var title = titles[i];

        for (var j = 0; j < title.nextElementSibling.children.length; j++) {
          if (!title.nextElementSibling.children[j].classList.contains('-hide')) {
            title.classList.remove('-hide');
            break;
          } else {
            title.classList.add('-hide');
          }
        }
      }
    }
  }]);

  return SearchContent;
}();



/***/ }),
/* 509 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = publicationSlider;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__js_helpers__ = __webpack_require__(8);


function publicationSlider() {
  var publicationBlock = document.querySelector('.publications-block.-composite');

  if (publicationBlock === null) {
    return;
  }

  var swiper = new __WEBPACK_IMPORTED_MODULE_0_swiper_dist_js_swiper___default.a('.publications-block__carousel', {
    effect: 'coverflow',
    grabCursor: true,
    centeredSlides: true,
    slidesPerView: 'auto',
    loop: true,
    coverflowEffect: {
      rotate: 25,
      stretch: 100,
      depth: 250,
      modifier: 1,
      slideShadows: false
    },
    navigation: {
      nextEl: '.publications-block__control.-next',
      prevEl: '.publications-block__control.-prev'
    }
  });
  var publicationCarousel = document.querySelector('.publications-block__carousel');
  var publicationControl = document.querySelectorAll('.publications-block__control');

  if (__WEBPACK_IMPORTED_MODULE_1__js_helpers__["m" /* hasClass */](publicationCarousel, 'swiper-container-horizontal')) {
    for (var i = 0; i < publicationControl.length; i++) {
      publicationControl[i].style.display = 'block';
    }
  }

  window.addEventListener('resize', function () {
    swiper.init();
  });
}

/***/ }),
/* 510 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = interactiveMap;
function interactiveMap() {
  var map = document.querySelector('.svg-map svg');
  if (!map) return;
  var slice = Array.prototype.slice;
  var cache = {};
  var areas = slice.call(map.querySelectorAll('.area')),
      activeArea = null,
      activeLocation = null,
      infos = slice.call(document.querySelectorAll('.info li')),
      activeInfo = null,
      currentHoveredElem = null,
      tooltip = null,
      requestID = null,
      tooltipWidth,
      pageX,
      pageY;
  var objId = 0;
  init();

  function init() {
    map.addEventListener('mouseenter', function (e) {
      console.log('enter');
      requestID = requestAnimationFrame(function f() {
        if (tooltip) {
          tooltip.style.left = pageX + 'px';
          tooltip.style.top = pageY + 'px';
        }

        requestID = requestAnimationFrame(f);
      });
      document.addEventListener('mousemove', moveHandler, false);
      map.addEventListener('mouseover', overHandler, false);
      map.addEventListener('mouseout', outHandler, false);
    }, false);
    map.addEventListener('mouseleave', function (e) {
      document.removeEventListener('mousemove', moveHandler, false);
      map.removeEventListener('mouseover', overHandler, false);
      map.removeEventListener('mouseout', outHandler, false);
      cancelAnimationFrame(requestID);
    }, false);
    map.addEventListener('mouseover', function (e) {
      //e.preventDefault();
      if (e.target.tagName.toLowerCase() === 'path') {
        var area = e.target,
            areaName = area.getAttribute('data-area');

        if (area !== activeArea) {//toggleArea(areaName);
        }
      }
    }, false);
  }

  function overHandler(e) {
    if (currentHoveredElem || !e.target.classList.contains('area')) {
      return;
    }

    var target = e.target;

    while (target !== this) {
      if (target.tagName === 'path' && target.classList.contains) break;
      target = target.parentNode;
    }

    if (target === this) return;
    currentHoveredElem = target;
    tooltip = createTooltip(currentHoveredElem.getAttribute('data-area') || '');
    tooltipWidth = tooltip.offsetWidth;
    pageX = e.target.pageX + tooltipWidth;
    pageY = e.target.pageY - 15;
  }

  function outHandler(e) {
    if (!currentHoveredElem) return;
    var relatedTarget = e.relatedTarget;

    if (relatedTarget && relatedTarget !== this) {
      while (relatedTarget) {
        if (relatedTarget === currentHoveredElem) return;
        relatedTarget = relatedTarget.parentNode;
      }
    }

    document.body.removeChild(tooltip);
    tooltip = currentHoveredElem = null;
  }

  function moveHandler(e) {
    pageX = e.pageX + tooltipWidth / 2;
    pageY = e.pageY - 15;
  }

  function createTooltip(txt) {
    var tooltip = document.createElement('div');
    tooltip.className = 'interactive-map-tooltip';
    tooltip.textContent = txt;
    document.body.appendChild(tooltip);
    return tooltip;
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=core.bundle.js.map